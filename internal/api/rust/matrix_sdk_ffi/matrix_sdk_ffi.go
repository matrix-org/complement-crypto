package matrix_sdk_ffi

// #include <matrix_sdk_ffi.h>
// #cgo LDFLAGS: -lmatrix_sdk_ffi
import "C"

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"github.com/matrix-org/complement-crypto/internal/api/rust/matrix_sdk"
	"github.com/matrix-org/complement-crypto/internal/api/rust/matrix_sdk_base"
	"github.com/matrix-org/complement-crypto/internal/api/rust/matrix_sdk_common"
	"github.com/matrix-org/complement-crypto/internal/api/rust/matrix_sdk_crypto"
	"github.com/matrix-org/complement-crypto/internal/api/rust/matrix_sdk_ui"
	"io"
	"math"
	"runtime"
	"runtime/cgo"
	"sync"
	"sync/atomic"
	"time"
	"unsafe"
)

// This is needed, because as of go 1.24
// type RustBuffer C.RustBuffer cannot have methods,
// RustBuffer is treated as non-local type
type GoRustBuffer struct {
	inner C.RustBuffer
}

type RustBufferI interface {
	AsReader() *bytes.Reader
	Free()
	ToGoBytes() []byte
	Data() unsafe.Pointer
	Len() uint64
	Capacity() uint64
}

func RustBufferFromExternal(b RustBufferI) GoRustBuffer {
	return GoRustBuffer{
		inner: C.RustBuffer{
			capacity: C.uint64_t(b.Capacity()),
			len:      C.uint64_t(b.Len()),
			data:     (*C.uchar)(b.Data()),
		},
	}
}

func (cb GoRustBuffer) Capacity() uint64 {
	return uint64(cb.inner.capacity)
}

func (cb GoRustBuffer) Len() uint64 {
	return uint64(cb.inner.len)
}

func (cb GoRustBuffer) Data() unsafe.Pointer {
	return unsafe.Pointer(cb.inner.data)
}

func (cb GoRustBuffer) AsReader() *bytes.Reader {
	b := unsafe.Slice((*byte)(cb.inner.data), C.uint64_t(cb.inner.len))
	return bytes.NewReader(b)
}

func (cb GoRustBuffer) Free() {
	rustCall(func(status *C.RustCallStatus) bool {
		C.ffi_matrix_sdk_ffi_rustbuffer_free(cb.inner, status)
		return false
	})
}

func (cb GoRustBuffer) ToGoBytes() []byte {
	return C.GoBytes(unsafe.Pointer(cb.inner.data), C.int(cb.inner.len))
}

func stringToRustBuffer(str string) C.RustBuffer {
	return bytesToRustBuffer([]byte(str))
}

func bytesToRustBuffer(b []byte) C.RustBuffer {
	if len(b) == 0 {
		return C.RustBuffer{}
	}
	// We can pass the pointer along here, as it is pinned
	// for the duration of this call
	foreign := C.ForeignBytes{
		len:  C.int(len(b)),
		data: (*C.uchar)(unsafe.Pointer(&b[0])),
	}

	return rustCall(func(status *C.RustCallStatus) C.RustBuffer {
		return C.ffi_matrix_sdk_ffi_rustbuffer_from_bytes(foreign, status)
	})
}

type BufLifter[GoType any] interface {
	Lift(value RustBufferI) GoType
}

type BufLowerer[GoType any] interface {
	Lower(value GoType) C.RustBuffer
}

type BufReader[GoType any] interface {
	Read(reader io.Reader) GoType
}

type BufWriter[GoType any] interface {
	Write(writer io.Writer, value GoType)
}

func LowerIntoRustBuffer[GoType any](bufWriter BufWriter[GoType], value GoType) C.RustBuffer {
	// This might be not the most efficient way but it does not require knowing allocation size
	// beforehand
	var buffer bytes.Buffer
	bufWriter.Write(&buffer, value)

	bytes, err := io.ReadAll(&buffer)
	if err != nil {
		panic(fmt.Errorf("reading written data: %w", err))
	}
	return bytesToRustBuffer(bytes)
}

func LiftFromRustBuffer[GoType any](bufReader BufReader[GoType], rbuf RustBufferI) GoType {
	defer rbuf.Free()
	reader := rbuf.AsReader()
	item := bufReader.Read(reader)
	if reader.Len() > 0 {
		// TODO: Remove this
		leftover, _ := io.ReadAll(reader)
		panic(fmt.Errorf("Junk remaining in buffer after lifting: %s", string(leftover)))
	}
	return item
}

func rustCallWithError[E any, U any](converter BufReader[*E], callback func(*C.RustCallStatus) U) (U, *E) {
	var status C.RustCallStatus
	returnValue := callback(&status)
	err := checkCallStatus(converter, status)
	return returnValue, err
}

func checkCallStatus[E any](converter BufReader[*E], status C.RustCallStatus) *E {
	switch status.code {
	case 0:
		return nil
	case 1:
		return LiftFromRustBuffer(converter, GoRustBuffer{inner: status.errorBuf})
	case 2:
		// when the rust code sees a panic, it tries to construct a rustBuffer
		// with the message.  but if that code panics, then it just sends back
		// an empty buffer.
		if status.errorBuf.len > 0 {
			panic(fmt.Errorf("%s", FfiConverterStringINSTANCE.Lift(GoRustBuffer{inner: status.errorBuf})))
		} else {
			panic(fmt.Errorf("Rust panicked while handling Rust panic"))
		}
	default:
		panic(fmt.Errorf("unknown status code: %d", status.code))
	}
}

func checkCallStatusUnknown(status C.RustCallStatus) error {
	switch status.code {
	case 0:
		return nil
	case 1:
		panic(fmt.Errorf("function not returning an error returned an error"))
	case 2:
		// when the rust code sees a panic, it tries to construct a C.RustBuffer
		// with the message.  but if that code panics, then it just sends back
		// an empty buffer.
		if status.errorBuf.len > 0 {
			panic(fmt.Errorf("%s", FfiConverterStringINSTANCE.Lift(GoRustBuffer{
				inner: status.errorBuf,
			})))
		} else {
			panic(fmt.Errorf("Rust panicked while handling Rust panic"))
		}
	default:
		return fmt.Errorf("unknown status code: %d", status.code)
	}
}

func rustCall[U any](callback func(*C.RustCallStatus) U) U {
	returnValue, err := rustCallWithError[error](nil, callback)
	if err != nil {
		panic(err)
	}
	return returnValue
}

type NativeError interface {
	AsError() error
}

func writeInt8(writer io.Writer, value int8) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeUint8(writer io.Writer, value uint8) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeInt16(writer io.Writer, value int16) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeUint16(writer io.Writer, value uint16) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeInt32(writer io.Writer, value int32) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeUint32(writer io.Writer, value uint32) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeInt64(writer io.Writer, value int64) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeUint64(writer io.Writer, value uint64) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeFloat32(writer io.Writer, value float32) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeFloat64(writer io.Writer, value float64) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func readInt8(reader io.Reader) int8 {
	var result int8
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readUint8(reader io.Reader) uint8 {
	var result uint8
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readInt16(reader io.Reader) int16 {
	var result int16
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readUint16(reader io.Reader) uint16 {
	var result uint16
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readInt32(reader io.Reader) int32 {
	var result int32
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readUint32(reader io.Reader) uint32 {
	var result uint32
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readInt64(reader io.Reader) int64 {
	var result int64
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readUint64(reader io.Reader) uint64 {
	var result uint64
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readFloat32(reader io.Reader) float32 {
	var result float32
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readFloat64(reader io.Reader) float64 {
	var result float64
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func init() {

	FfiConverterCallbackInterfaceAccountDataListenerINSTANCE.register()
	FfiConverterCallbackInterfaceBackupStateListenerINSTANCE.register()
	FfiConverterCallbackInterfaceBackupSteadyStateListenerINSTANCE.register()
	FfiConverterCallbackInterfaceClientDelegateINSTANCE.register()
	FfiConverterCallbackInterfaceClientSessionDelegateINSTANCE.register()
	FfiConverterCallbackInterfaceEnableRecoveryProgressListenerINSTANCE.register()
	FfiConverterCallbackInterfaceIdentityStatusChangeListenerINSTANCE.register()
	FfiConverterCallbackInterfaceIgnoredUsersListenerINSTANCE.register()
	FfiConverterCallbackInterfaceKnockRequestsListenerINSTANCE.register()
	FfiConverterCallbackInterfaceLiveLocationShareListenerINSTANCE.register()
	FfiConverterCallbackInterfaceMediaPreviewConfigListenerINSTANCE.register()
	FfiConverterCallbackInterfaceNotificationSettingsDelegateINSTANCE.register()
	FfiConverterCallbackInterfacePaginationStatusListenerINSTANCE.register()
	FfiConverterCallbackInterfaceProgressWatcherINSTANCE.register()
	FfiConverterCallbackInterfaceQrLoginProgressListenerINSTANCE.register()
	FfiConverterCallbackInterfaceRecoveryStateListenerINSTANCE.register()
	FfiConverterCallbackInterfaceRoomAccountDataListenerINSTANCE.register()
	FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListenerINSTANCE.register()
	FfiConverterCallbackInterfaceRoomInfoListenerINSTANCE.register()
	FfiConverterCallbackInterfaceRoomListEntriesListenerINSTANCE.register()
	FfiConverterCallbackInterfaceRoomListLoadingStateListenerINSTANCE.register()
	FfiConverterCallbackInterfaceRoomListServiceStateListenerINSTANCE.register()
	FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListenerINSTANCE.register()
	FfiConverterCallbackInterfaceSendQueueRoomErrorListenerINSTANCE.register()
	FfiConverterCallbackInterfaceSessionVerificationControllerDelegateINSTANCE.register()
	FfiConverterCallbackInterfaceSyncServiceStateObserverINSTANCE.register()
	FfiConverterCallbackInterfaceTimelineListenerINSTANCE.register()
	FfiConverterCallbackInterfaceTypingNotificationsListenerINSTANCE.register()
	FfiConverterCallbackInterfaceUnableToDecryptDelegateINSTANCE.register()
	FfiConverterCallbackInterfaceVerificationStateListenerINSTANCE.register()
	FfiConverterCallbackInterfaceWidgetCapabilitiesProviderINSTANCE.register()
	uniffiCheckChecksums()
}

func uniffiCheckChecksums() {
	// Get the bindings contract version from our ComponentInterface
	bindingsContractVersion := 26
	// Get the scaffolding contract version by calling the into the dylib
	scaffoldingContractVersion := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint32_t {
		return C.ffi_matrix_sdk_ffi_uniffi_contract_version()
	})
	if bindingsContractVersion != int(scaffoldingContractVersion) {
		// If this happens try cleaning and rebuilding your project
		panic("matrix_sdk_ffi: UniFFI contract version mismatch")
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_func_content_without_relation_from_message()
		})
		if checksum != 1366 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_func_content_without_relation_from_message: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_func_create_caption_edit()
		})
		if checksum != 33992 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_func_create_caption_edit: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_func_gen_transaction_id()
		})
		if checksum != 15808 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_func_gen_transaction_id: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_func_generate_webview_url()
		})
		if checksum != 48529 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_func_generate_webview_url: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_func_get_element_call_required_permissions()
		})
		if checksum != 30181 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_func_get_element_call_required_permissions: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_func_init_platform()
		})
		if checksum != 35062 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_func_init_platform: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_func_is_room_alias_format_valid()
		})
		if checksum != 54845 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_func_is_room_alias_format_valid: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_func_log_event()
		})
		if checksum != 62286 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_func_log_event: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_func_make_element_well_known()
		})
		if checksum != 21379 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_func_make_element_well_known: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_func_make_widget_driver()
		})
		if checksum != 34206 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_func_make_widget_driver: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_func_matrix_to_room_alias_permalink()
		})
		if checksum != 13776 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_func_matrix_to_room_alias_permalink: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_func_matrix_to_user_permalink()
		})
		if checksum != 46473 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_func_matrix_to_user_permalink: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html()
		})
		if checksum != 37203 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html_as_emote()
		})
		if checksum != 8938 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html_as_emote: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown()
		})
		if checksum != 58385 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown_as_emote()
		})
		if checksum != 20152 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown_as_emote: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_func_message_event_content_new()
		})
		if checksum != 57839 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_func_message_event_content_new: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_func_new_virtual_element_call_widget()
		})
		if checksum != 4988 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_func_new_virtual_element_call_widget: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_func_parse_matrix_entity_from()
		})
		if checksum != 49710 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_func_parse_matrix_entity_from: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_func_room_alias_name_from_room_display_name()
		})
		if checksum != 65010 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_func_room_alias_name_from_room_display_name: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_func_sdk_git_sha()
		})
		if checksum != 4038 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_func_sdk_git_sha: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_func_suggested_power_level_for_role()
		})
		if checksum != 61777 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_func_suggested_power_level_for_role: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_func_suggested_role_for_power_level()
		})
		if checksum != 48532 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_func_suggested_role_for_power_level: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roommessageeventcontentwithoutrelation_with_mentions()
		})
		if checksum != 8867 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roommessageeventcontentwithoutrelation_with_mentions: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_abort_oidc_auth()
		})
		if checksum != 53440 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_abort_oidc_auth: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_account_data()
		})
		if checksum != 50433 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_account_data: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_account_url()
		})
		if checksum != 42373 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_account_url: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_available_sliding_sync_versions()
		})
		if checksum != 35296 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_available_sliding_sync_versions: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_avatar_url()
		})
		if checksum != 27867 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_avatar_url: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_await_room_remote_echo()
		})
		if checksum != 18126 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_await_room_remote_echo: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_cached_avatar_url()
		})
		if checksum != 50226 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_cached_avatar_url: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_can_deactivate_account()
		})
		if checksum != 39890 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_can_deactivate_account: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_clear_caches()
		})
		if checksum != 47085 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_clear_caches: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_create_room()
		})
		if checksum != 52700 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_create_room: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_custom_login_with_jwt()
		})
		if checksum != 19710 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_custom_login_with_jwt: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_deactivate_account()
		})
		if checksum != 20658 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_deactivate_account: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_delete_pusher()
		})
		if checksum != 45990 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_delete_pusher: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_device_id()
		})
		if checksum != 44340 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_device_id: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_display_name()
		})
		if checksum != 56259 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_display_name: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_enable_all_send_queues()
		})
		if checksum != 30834 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_enable_all_send_queues: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_encryption()
		})
		if checksum != 9657 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_encryption: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_get_dm_room()
		})
		if checksum != 5137 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_get_dm_room: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_get_invite_avatars_display_policy()
		})
		if checksum != 3997 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_get_invite_avatars_display_policy: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_get_media_content()
		})
		if checksum != 40308 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_get_media_content: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_get_media_file()
		})
		if checksum != 52604 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_get_media_file: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_get_media_preview_display_policy()
		})
		if checksum != 55631 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_get_media_preview_display_policy: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_get_media_thumbnail()
		})
		if checksum != 52601 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_get_media_thumbnail: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_get_notification_settings()
		})
		if checksum != 49769 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_get_notification_settings: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_get_profile()
		})
		if checksum != 60062 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_get_profile: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_get_recently_visited_rooms()
		})
		if checksum != 22399 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_get_recently_visited_rooms: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_get_room()
		})
		if checksum != 30376 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_get_room: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_alias()
		})
		if checksum != 7674 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_alias: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_id()
		})
		if checksum != 36348 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_id: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_get_session_verification_controller()
		})
		if checksum != 55934 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_get_session_verification_controller: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_get_url()
		})
		if checksum != 50489 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_get_url: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_homeserver()
		})
		if checksum != 26427 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_homeserver: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_homeserver_login_details()
		})
		if checksum != 63487 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_homeserver_login_details: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_ignore_user()
		})
		if checksum != 14588 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_ignore_user: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_ignored_users()
		})
		if checksum != 49620 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_ignored_users: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_is_report_room_api_supported()
		})
		if checksum != 17934 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_is_report_room_api_supported: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_is_room_alias_available()
		})
		if checksum != 23322 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_is_room_alias_available: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id()
		})
		if checksum != 64032 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id_or_alias()
		})
		if checksum != 18521 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id_or_alias: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_knock()
		})
		if checksum != 48652 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_knock: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_login()
		})
		if checksum != 33276 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_login: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_login_with_email()
		})
		if checksum != 11789 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_login_with_email: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_login_with_oidc_callback()
		})
		if checksum != 32591 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_login_with_oidc_callback: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_logout()
		})
		if checksum != 42911 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_logout: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_notification_client()
		})
		if checksum != 37308 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_notification_client: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_observe_account_data_event()
		})
		if checksum != 13906 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_observe_account_data_event: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_observe_room_account_data_event()
		})
		if checksum != 15699 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_observe_room_account_data_event: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_remove_avatar()
		})
		if checksum != 29033 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_remove_avatar: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_reset_server_capabilities()
		})
		if checksum != 39651 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_reset_server_capabilities: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_resolve_room_alias()
		})
		if checksum != 3551 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_resolve_room_alias: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_restore_session()
		})
		if checksum != 56125 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_restore_session: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_restore_session_with()
		})
		if checksum != 20927 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_restore_session_with: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_room_alias_exists()
		})
		if checksum != 20359 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_room_alias_exists: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_room_directory_search()
		})
		if checksum != 39855 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_room_directory_search: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_rooms()
		})
		if checksum != 29558 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_rooms: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_search_users()
		})
		if checksum != 42927 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_search_users: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_server()
		})
		if checksum != 63276 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_server: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_session()
		})
		if checksum != 8085 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_session: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_set_account_data()
		})
		if checksum != 18256 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_set_account_data: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_set_delegate()
		})
		if checksum != 46437 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_set_delegate: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_set_display_name()
		})
		if checksum != 15292 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_set_display_name: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_set_invite_avatars_display_policy()
		})
		if checksum != 48457 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_set_invite_avatars_display_policy: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_set_media_preview_display_policy()
		})
		if checksum != 24080 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_set_media_preview_display_policy: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_set_media_retention_policy()
		})
		if checksum != 2414 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_set_media_retention_policy: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_set_pusher()
		})
		if checksum != 41975 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_set_pusher: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_set_utd_delegate()
		})
		if checksum != 37720 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_set_utd_delegate: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_sliding_sync_version()
		})
		if checksum != 4957 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_sliding_sync_version: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_start_sso_login()
		})
		if checksum != 34571 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_start_sso_login: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_ignored_users()
		})
		if checksum != 23285 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_ignored_users: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_media_preview_config()
		})
		if checksum != 47047 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_media_preview_config: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_send_queue_status()
		})
		if checksum != 57403 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_send_queue_status: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_sync_service()
		})
		if checksum != 52812 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_sync_service: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_track_recently_visited_room()
		})
		if checksum != 56986 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_track_recently_visited_room: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_unignore_user()
		})
		if checksum != 8489 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_unignore_user: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_upload_avatar()
		})
		if checksum != 64486 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_upload_avatar: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_upload_media()
		})
		if checksum != 51195 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_upload_media: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_url_for_oidc()
		})
		if checksum != 28386 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_url_for_oidc: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_user_id()
		})
		if checksum != 40531 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_user_id: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_client_user_id_server_name()
		})
		if checksum != 57725 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_client_user_id_server_name: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_add_root_certificates()
		})
		if checksum != 14763 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_add_root_certificates: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_backups()
		})
		if checksum != 44502 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_backups: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_cross_signing()
		})
		if checksum != 37167 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_cross_signing: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_backup_download_strategy()
		})
		if checksum != 11959 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_backup_download_strategy: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build()
		})
		if checksum != 56018 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build_with_qr_code()
		})
		if checksum != 42452 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build_with_qr_code: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_cross_process_store_locks_holder_name()
		})
		if checksum != 46627 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_cross_process_store_locks_holder_name: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_automatic_token_refresh()
		})
		if checksum != 43839 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_automatic_token_refresh: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_built_in_root_certificates()
		})
		if checksum != 47525 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_built_in_root_certificates: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_ssl_verification()
		})
		if checksum != 2334 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_ssl_verification: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_enable_oidc_refresh_lock()
		})
		if checksum != 42214 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_enable_oidc_refresh_lock: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_homeserver_url()
		})
		if checksum != 28347 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_homeserver_url: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_proxy()
		})
		if checksum != 5659 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_proxy: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_request_config()
		})
		if checksum != 58783 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_request_config: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_decryption_trust_requirement()
		})
		if checksum != 2776 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_decryption_trust_requirement: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_key_recipient_strategy()
		})
		if checksum != 41183 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_key_recipient_strategy: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name()
		})
		if checksum != 29096 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name_or_homeserver_url()
		})
		if checksum != 30022 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name_or_homeserver_url: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_cache_size()
		})
		if checksum != 32604 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_cache_size: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_journal_size_limit()
		})
		if checksum != 21378 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_journal_size_limit: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_passphrase()
		})
		if checksum != 55403 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_passphrase: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_paths()
		})
		if checksum != 54230 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_paths: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_pool_max_size()
		})
		if checksum != 6011 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_pool_max_size: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_set_session_delegate()
		})
		if checksum != 8576 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_set_session_delegate: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_sliding_sync_version_builder()
		})
		if checksum != 39381 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_sliding_sync_version_builder: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_system_is_memory_constrained()
		})
		if checksum != 6898 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_system_is_memory_constrained: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_user_agent()
		})
		if checksum != 13719 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_user_agent: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_username()
		})
		if checksum != 45302 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_username: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_exists_on_server()
		})
		if checksum != 45490 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_exists_on_server: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state()
		})
		if checksum != 51049 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state_listener()
		})
		if checksum != 14246 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state_listener: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_encryption_curve25519_key()
		})
		if checksum != 58425 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_encryption_curve25519_key: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_encryption_disable_recovery()
		})
		if checksum != 18699 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_encryption_disable_recovery: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_encryption_ed25519_key()
		})
		if checksum != 11864 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_encryption_ed25519_key: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_backups()
		})
		if checksum != 55446 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_backups: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_recovery()
		})
		if checksum != 64351 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_recovery: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_encryption_is_last_device()
		})
		if checksum != 27955 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_encryption_is_last_device: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_encryption_recover()
		})
		if checksum != 33712 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_encryption_recover: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_encryption_recover_and_reset()
		})
		if checksum != 12902 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_encryption_recover_and_reset: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state()
		})
		if checksum != 54051 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state_listener()
		})
		if checksum != 36612 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state_listener: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_identity()
		})
		if checksum != 13780 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_identity: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_recovery_key()
		})
		if checksum != 20380 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_recovery_key: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_encryption_user_identity()
		})
		if checksum != 20644 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_encryption_user_identity: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state()
		})
		if checksum != 29114 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state_listener()
		})
		if checksum != 59806 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state_listener: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_backup_upload_steady_state()
		})
		if checksum != 37503 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_backup_upload_steady_state: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_e2ee_initialization_tasks()
		})
		if checksum != 41585 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_e2ee_initialization_tasks: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_sliding_sync_version()
		})
		if checksum != 36573 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_sliding_sync_version: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supported_oidc_prompts()
		})
		if checksum != 63396 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supported_oidc_prompts: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_oidc_login()
		})
		if checksum != 46090 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_oidc_login: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_password_login()
		})
		if checksum != 33501 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_password_login: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_url()
		})
		if checksum != 61326 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_url: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_auth_type()
		})
		if checksum != 43501 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_auth_type: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_cancel()
		})
		if checksum != 57622 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_cancel: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_reset()
		})
		if checksum != 11997 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_reset: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event()
		})
		if checksum != 51792 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event_id()
		})
		if checksum != 5876 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event_id: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_accept()
		})
		if checksum != 25656 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_accept: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline()
		})
		if checksum != 65054 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline_and_ban()
		})
		if checksum != 26242 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline_and_ban: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_mark_as_seen()
		})
		if checksum != 36036 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_mark_as_seen: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_contains_only_emojis()
		})
		if checksum != 5211 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_contains_only_emojis: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_debug_info()
		})
		if checksum != 55450 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_debug_info: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_send_handle()
		})
		if checksum != 46057 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_send_handle: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_shields()
		})
		if checksum != 12518 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_shields: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_path()
		})
		if checksum != 16357 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_path: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_persist()
		})
		if checksum != 12883 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_persist: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_mediasource_to_json()
		})
		if checksum != 23306 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_mediasource_to_json: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_mediasource_url()
		})
		if checksum != 62692 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_mediasource_url: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notification()
		})
		if checksum != 2524 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notification: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notifications()
		})
		if checksum != 30600 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notifications: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_room()
		})
		if checksum != 26581 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_room: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_homeserver_push_encrypted_event_to_device()
		})
		if checksum != 37323 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_homeserver_push_encrypted_event_to_device: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_push_encrypted_event_to_device()
		})
		if checksum != 21251 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_push_encrypted_event_to_device: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_contains_keywords_rules()
		})
		if checksum != 60025 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_contains_keywords_rules: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_default_room_notification_mode()
		})
		if checksum != 36211 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_default_room_notification_mode: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_room_notification_settings()
		})
		if checksum != 55295 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_room_notification_settings: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_rooms_with_user_defined_rules()
		})
		if checksum != 19849 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_rooms_with_user_defined_rules: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_user_defined_room_notification_mode()
		})
		if checksum != 18228 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_user_defined_room_notification_mode: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_call_enabled()
		})
		if checksum != 12210 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_call_enabled: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_invite_for_me_enabled()
		})
		if checksum != 533 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_invite_for_me_enabled: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_room_mention_enabled()
		})
		if checksum != 13304 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_room_mention_enabled: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_user_mention_enabled()
		})
		if checksum != 49857 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_user_mention_enabled: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_restore_default_room_notification_mode()
		})
		if checksum != 35399 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_restore_default_room_notification_mode: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_call_enabled()
		})
		if checksum != 16823 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_call_enabled: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_custom_push_rule()
		})
		if checksum != 465 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_custom_push_rule: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_default_room_notification_mode()
		})
		if checksum != 9426 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_default_room_notification_mode: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_delegate()
		})
		if checksum != 57636 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_delegate: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_invite_for_me_enabled()
		})
		if checksum != 11988 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_invite_for_me_enabled: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_mention_enabled()
		})
		if checksum != 31650 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_mention_enabled: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_notification_mode()
		})
		if checksum != 4135 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_notification_mode: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_user_mention_enabled()
		})
		if checksum != 56594 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_user_mention_enabled: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_unmute_room()
		})
		if checksum != 47580 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_unmute_room: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_qrcodedata_server_name()
		})
		if checksum != 30173 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_qrcodedata_server_name: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_active_members_count()
		})
		if checksum != 61905 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_active_members_count: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_active_room_call_participants()
		})
		if checksum != 41533 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_active_room_call_participants: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_alternative_aliases()
		})
		if checksum != 28555 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_alternative_aliases: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_apply_power_level_changes()
		})
		if checksum != 44206 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_apply_power_level_changes: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_avatar_url()
		})
		if checksum != 34637 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_avatar_url: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_ban_user()
		})
		if checksum != 35046 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_ban_user: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_can_user_ban()
		})
		if checksum != 64711 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_can_user_ban: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_can_user_invite()
		})
		if checksum != 62459 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_can_user_invite: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_can_user_kick()
		})
		if checksum != 12773 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_can_user_kick: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_can_user_pin_unpin()
		})
		if checksum != 8341 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_can_user_pin_unpin: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_can_user_redact_other()
		})
		if checksum != 13274 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_can_user_redact_other: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_can_user_redact_own()
		})
		if checksum != 57442 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_can_user_redact_own: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_can_user_send_message()
		})
		if checksum != 36743 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_can_user_send_message: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_can_user_send_state()
		})
		if checksum != 19062 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_can_user_send_state: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_can_user_trigger_room_notification()
		})
		if checksum != 18832 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_can_user_trigger_room_notification: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_canonical_alias()
		})
		if checksum != 19786 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_canonical_alias: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_clear_composer_draft()
		})
		if checksum != 39667 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_clear_composer_draft: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_clear_event_cache_storage()
		})
		if checksum != 13838 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_clear_event_cache_storage: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_discard_room_key()
		})
		if checksum != 18081 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_discard_room_key: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_display_name()
		})
		if checksum != 64194 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_display_name: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_edit()
		})
		if checksum != 61956 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_edit: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_enable_encryption()
		})
		if checksum != 14669 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_enable_encryption: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_enable_send_queue()
		})
		if checksum != 23914 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_enable_send_queue: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_encryption_state()
		})
		if checksum != 9101 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_encryption_state: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_forget()
		})
		if checksum != 37840 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_forget: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_get_power_levels()
		})
		if checksum != 54094 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_get_power_levels: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_get_room_visibility()
		})
		if checksum != 412 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_get_room_visibility: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_has_active_room_call()
		})
		if checksum != 33588 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_has_active_room_call: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_heroes()
		})
		if checksum != 22313 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_heroes: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_id()
		})
		if checksum != 61990 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_id: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_ignore_device_trust_and_resend()
		})
		if checksum != 39984 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_ignore_device_trust_and_resend: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_ignore_user()
		})
		if checksum != 62239 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_ignore_user: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_invite_user_by_id()
		})
		if checksum != 41133 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_invite_user_by_id: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_invited_members_count()
		})
		if checksum != 1023 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_invited_members_count: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_is_direct()
		})
		if checksum != 10462 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_is_direct: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_is_encrypted()
		})
		if checksum != 63995 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_is_encrypted: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_is_public()
		})
		if checksum != 7336 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_is_public: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_is_send_queue_enabled()
		})
		if checksum != 36591 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_is_send_queue_enabled: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_is_space()
		})
		if checksum != 16919 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_is_space: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_is_tombstoned()
		})
		if checksum != 49186 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_is_tombstoned: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_join()
		})
		if checksum != 9240 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_join: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_joined_members_count()
		})
		if checksum != 55835 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_joined_members_count: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_kick_user()
		})
		if checksum != 28600 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_kick_user: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_latest_encryption_state()
		})
		if checksum != 16843 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_latest_encryption_state: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_latest_event()
		})
		if checksum != 39083 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_latest_event: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_leave()
		})
		if checksum != 63688 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_leave: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_load_composer_draft()
		})
		if checksum != 38115 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_load_composer_draft: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_mark_as_read()
		})
		if checksum != 57806 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_mark_as_read: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_event_permalink()
		})
		if checksum != 36705 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_event_permalink: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_permalink()
		})
		if checksum != 47781 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_permalink: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_member()
		})
		if checksum != 48980 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_member: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_member_avatar_url()
		})
		if checksum != 29492 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_member_avatar_url: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_member_display_name()
		})
		if checksum != 33206 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_member_display_name: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_member_with_sender_info()
		})
		if checksum != 64964 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_member_with_sender_info: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_members()
		})
		if checksum != 42691 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_members: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_members_no_sync()
		})
		if checksum != 3255 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_members_no_sync: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_membership()
		})
		if checksum != 45951 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_membership: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_own_user_id()
		})
		if checksum != 39510 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_own_user_id: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_preview_room()
		})
		if checksum != 60431 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_preview_room: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_publish_room_alias_in_room_directory()
		})
		if checksum != 13924 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_publish_room_alias_in_room_directory: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_raw_name()
		})
		if checksum != 15453 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_raw_name: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_redact()
		})
		if checksum != 45810 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_redact: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_remove_avatar()
		})
		if checksum != 7230 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_remove_avatar: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_remove_room_alias_from_room_directory()
		})
		if checksum != 16926 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_remove_room_alias_from_room_directory: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_report_content()
		})
		if checksum != 16529 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_report_content: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_report_room()
		})
		if checksum != 8059 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_report_room: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_reset_power_levels()
		})
		if checksum != 63622 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_reset_power_levels: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_room_events_debug_string()
		})
		if checksum != 37832 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_room_events_debug_string: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_room_info()
		})
		if checksum != 41146 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_room_info: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_save_composer_draft()
		})
		if checksum != 62232 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_save_composer_draft: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_send_call_notification()
		})
		if checksum != 43366 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_send_call_notification: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_send_call_notification_if_needed()
		})
		if checksum != 53551 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_send_call_notification_if_needed: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_send_live_location()
		})
		if checksum != 34248 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_send_live_location: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_send_raw()
		})
		if checksum != 20486 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_send_raw: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_set_is_favourite()
		})
		if checksum != 64403 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_set_is_favourite: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_set_is_low_priority()
		})
		if checksum != 48070 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_set_is_low_priority: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_set_name()
		})
		if checksum != 52127 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_set_name: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_set_topic()
		})
		if checksum != 5576 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_set_topic: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_set_unread_flag()
		})
		if checksum != 2381 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_set_unread_flag: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_start_live_location_share()
		})
		if checksum != 11488 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_start_live_location_share: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_stop_live_location_share()
		})
		if checksum != 19983 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_stop_live_location_share: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_identity_status_changes()
		})
		if checksum != 8526 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_identity_status_changes: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_knock_requests()
		})
		if checksum != 30649 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_knock_requests: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_live_location_shares()
		})
		if checksum != 57037 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_live_location_shares: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_room_info_updates()
		})
		if checksum != 48209 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_room_info_updates: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_typing_notifications()
		})
		if checksum != 38524 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_typing_notifications: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_suggested_role_for_user()
		})
		if checksum != 47787 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_suggested_role_for_user: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_timeline()
		})
		if checksum != 51477 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_timeline: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_timeline_with_configuration()
		})
		if checksum != 35159 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_timeline_with_configuration: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_topic()
		})
		if checksum != 59745 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_topic: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_typing_notice()
		})
		if checksum != 28642 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_typing_notice: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_unban_user()
		})
		if checksum != 1803 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_unban_user: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_update_canonical_alias()
		})
		if checksum != 25065 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_update_canonical_alias: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_update_history_visibility()
		})
		if checksum != 26248 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_update_history_visibility: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_update_join_rules()
		})
		if checksum != 49303 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_update_join_rules: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_update_power_levels_for_users()
		})
		if checksum != 52057 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_update_power_levels_for_users: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_update_room_visibility()
		})
		if checksum != 64724 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_update_room_visibility: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_upload_avatar()
		})
		if checksum != 19069 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_upload_avatar: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_room_withdraw_verification_and_resend()
		})
		if checksum != 33485 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_room_withdraw_verification_and_resend: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_is_at_last_page()
		})
		if checksum != 34221 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_is_at_last_page: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_loaded_pages()
		})
		if checksum != 2923 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_loaded_pages: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_next_page()
		})
		if checksum != 29305 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_next_page: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_results()
		})
		if checksum != 30207 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_results: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_search()
		})
		if checksum != 24438 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_search: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomlist_entries_with_dynamic_adapters()
		})
		if checksum != 36097 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomlist_entries_with_dynamic_adapters: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomlist_loading_state()
		})
		if checksum != 21585 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomlist_loading_state: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomlist_room()
		})
		if checksum != 62491 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomlist_room: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_add_one_page()
		})
		if checksum != 47748 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_add_one_page: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_reset_to_one_page()
		})
		if checksum != 61352 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_reset_to_one_page: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_set_filter()
		})
		if checksum != 61202 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_set_filter: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_controller()
		})
		if checksum != 36258 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_controller: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_entries_stream()
		})
		if checksum != 56632 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_entries_stream: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_all_rooms()
		})
		if checksum != 49704 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_all_rooms: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_room()
		})
		if checksum != 60695 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_room: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_state()
		})
		if checksum != 64650 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_state: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_subscribe_to_rooms()
		})
		if checksum != 59765 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_subscribe_to_rooms: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_sync_indicator()
		})
		if checksum != 16821 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_sync_indicator: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_len()
		})
		if checksum != 39835 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_len: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_next_chunk()
		})
		if checksum != 23186 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_next_chunk: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roompreview_forget()
		})
		if checksum != 18179 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roompreview_forget: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roompreview_info()
		})
		if checksum != 9145 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roompreview_info: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roompreview_inviter()
		})
		if checksum != 1297 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roompreview_inviter: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roompreview_leave()
		})
		if checksum != 21886 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roompreview_leave: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roompreview_own_membership_details()
		})
		if checksum != 46321 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roompreview_own_membership_details: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_cancel()
		})
		if checksum != 62384 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_cancel: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_join()
		})
		if checksum != 1903 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_join: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_sendhandle_abort()
		})
		if checksum != 11570 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_sendhandle_abort: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_sendhandle_try_resend()
		})
		if checksum != 28691 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_sendhandle_try_resend: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_accept_verification_request()
		})
		if checksum != 53466 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_accept_verification_request: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_acknowledge_verification_request()
		})
		if checksum != 37982 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_acknowledge_verification_request: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_approve_verification()
		})
		if checksum != 27140 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_approve_verification: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_cancel_verification()
		})
		if checksum != 32994 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_cancel_verification: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_decline_verification()
		})
		if checksum != 64345 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_decline_verification: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_device_verification()
		})
		if checksum != 4777 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_device_verification: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_user_verification()
		})
		if checksum != 26149 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_user_verification: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_set_delegate()
		})
		if checksum != 42324 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_set_delegate: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_start_sas_verification()
		})
		if checksum != 16328 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_start_sas_verification: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_description()
		})
		if checksum != 21346 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_description: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_symbol()
		})
		if checksum != 46075 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_symbol: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_span_enter()
		})
		if checksum != 8900 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_span_enter: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_span_exit()
		})
		if checksum != 47924 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_span_exit: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_span_is_none()
		})
		if checksum != 33327 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_span_is_none: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_ssohandler_finish()
		})
		if checksum != 64706 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_ssohandler_finish: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_ssohandler_url()
		})
		if checksum != 10889 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_ssohandler_url: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_syncservice_room_list_service()
		})
		if checksum != 26426 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_syncservice_room_list_service: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_syncservice_start()
		})
		if checksum != 16010 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_syncservice_start: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_syncservice_state()
		})
		if checksum != 61806 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_syncservice_state: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_syncservice_stop()
		})
		if checksum != 42435 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_syncservice_stop: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_finish()
		})
		if checksum != 22814 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_finish: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_cross_process_lock()
		})
		if checksum != 56326 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_cross_process_lock: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_offline_mode()
		})
		if checksum != 16958 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_offline_mode: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_taskhandle_cancel()
		})
		if checksum != 9124 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_taskhandle_cancel: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_taskhandle_is_finished()
		})
		if checksum != 29008 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_taskhandle_is_finished: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_threadsummary_latest_event()
		})
		if checksum != 52190 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_threadsummary_latest_event: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_add_listener()
		})
		if checksum != 18746 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_add_listener: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_create_message_content()
		})
		if checksum != 21811 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_create_message_content: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_create_poll()
		})
		if checksum != 37925 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_create_poll: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_edit()
		})
		if checksum != 42189 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_edit: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_end_poll()
		})
		if checksum != 32659 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_end_poll: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_details_for_event()
		})
		if checksum != 54068 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_details_for_event: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_members()
		})
		if checksum != 37994 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_members: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_get_event_timeline_item_by_event_id()
		})
		if checksum != 33999 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_get_event_timeline_item_by_event_id: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_load_reply_details()
		})
		if checksum != 54225 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_load_reply_details: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_mark_as_read()
		})
		if checksum != 16621 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_mark_as_read: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_backwards()
		})
		if checksum != 36829 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_backwards: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_forwards()
		})
		if checksum != 30268 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_forwards: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_pin_event()
		})
		if checksum != 41687 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_pin_event: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_redact_event()
		})
		if checksum != 48707 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_redact_event: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_retry_decryption()
		})
		if checksum != 21112 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_retry_decryption: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_send()
		})
		if checksum != 9553 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_send: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_audio()
		})
		if checksum != 22559 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_send_audio: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_file()
		})
		if checksum != 4588 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_send_file: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_image()
		})
		if checksum != 25436 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_send_image: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_location()
		})
		if checksum != 47400 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_send_location: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_poll_response()
		})
		if checksum != 7453 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_send_poll_response: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_read_receipt()
		})
		if checksum != 37532 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_send_read_receipt: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_reply()
		})
		if checksum != 31468 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_send_reply: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_video()
		})
		if checksum != 1445 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_send_video: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_send_voice_message()
		})
		if checksum != 50042 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_send_voice_message: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_subscribe_to_back_pagination_status()
		})
		if checksum != 46161 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_subscribe_to_back_pagination_status: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_toggle_reaction()
		})
		if checksum != 29303 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_toggle_reaction: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timeline_unpin_event()
		})
		if checksum != 52414 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timeline_unpin_event: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timelinediff_append()
		})
		if checksum != 8453 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timelinediff_append: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timelinediff_change()
		})
		if checksum != 4562 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timelinediff_change: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timelinediff_insert()
		})
		if checksum != 26630 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timelinediff_insert: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_back()
		})
		if checksum != 53464 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_back: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_front()
		})
		if checksum != 42084 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timelinediff_push_front: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timelinediff_remove()
		})
		if checksum != 74 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timelinediff_remove: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timelinediff_reset()
		})
		if checksum != 34118 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timelinediff_reset: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timelinediff_set()
		})
		if checksum != 13334 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timelinediff_set: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timelinediff_truncate()
		})
		if checksum != 34040 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timelinediff_truncate: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_id()
		})
		if checksum != 11088 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_id: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_type()
		})
		if checksum != 12922 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_type: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timelineevent_sender_id()
		})
		if checksum != 18142 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timelineevent_sender_id: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timelineevent_timestamp()
		})
		if checksum != 50929 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timelineevent_timestamp: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_event()
		})
		if checksum != 6106 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_event: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_virtual()
		})
		if checksum != 50960 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_virtual: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timelineitem_fmt_debug()
		})
		if checksum != 38094 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timelineitem_fmt_debug: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timelineitem_unique_id()
		})
		if checksum != 39945 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timelineitem_unique_id: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_has_notifications()
		})
		if checksum != 33024 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_has_notifications: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_highlight_count()
		})
		if checksum != 35997 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_highlight_count: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_notification_count()
		})
		if checksum != 35655 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_notification_count: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_useridentity_has_verification_violation()
		})
		if checksum != 2948 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_useridentity_has_verification_violation: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_useridentity_is_verified()
		})
		if checksum != 61954 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_useridentity_is_verified: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_useridentity_master_key()
		})
		if checksum != 4041 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_useridentity_master_key: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_useridentity_pin()
		})
		if checksum != 62925 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_useridentity_pin: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_useridentity_was_previously_verified()
		})
		if checksum != 41686 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_useridentity_was_previously_verified: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_useridentity_withdraw_verification()
		})
		if checksum != 3578 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_useridentity_withdraw_verification: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_widgetdriver_run()
		})
		if checksum != 7519 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_widgetdriver_run: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_recv()
		})
		if checksum != 2662 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_recv: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_send()
		})
		if checksum != 18689 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_send: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_constructor_clientbuilder_new()
		})
		if checksum != 27991 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_constructor_clientbuilder_new: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_json()
		})
		if checksum != 10564 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_json: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_url()
		})
		if checksum != 11983 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_url: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_constructor_qrcodedata_from_bytes()
		})
		if checksum != 32675 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_constructor_qrcodedata_from_bytes: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_constructor_span_current()
		})
		if checksum != 53698 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_constructor_span_current: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_constructor_span_new()
		})
		if checksum != 14105 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_constructor_span_new: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_exclude()
		})
		if checksum != 53805 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_exclude: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_include()
		})
		if checksum != 25498 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_include: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_accountdatalistener_on_change()
		})
		if checksum != 16189 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_accountdatalistener_on_change: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_backupstatelistener_on_update()
		})
		if checksum != 12849 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_backupstatelistener_on_update: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_backupsteadystatelistener_on_update()
		})
		if checksum != 41052 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_backupsteadystatelistener_on_update: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientdelegate_did_receive_auth_error()
		})
		if checksum != 26350 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientdelegate_did_receive_auth_error: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_retrieve_session_from_keychain()
		})
		if checksum != 43954 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_retrieve_session_from_keychain: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_save_session_in_keychain()
		})
		if checksum != 53223 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_save_session_in_keychain: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_enablerecoveryprogresslistener_on_update()
		})
		if checksum != 13538 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_enablerecoveryprogresslistener_on_update: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_identitystatuschangelistener_call()
		})
		if checksum != 57311 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_identitystatuschangelistener_call: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_ignoreduserslistener_call()
		})
		if checksum != 47519 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_ignoreduserslistener_call: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_knockrequestslistener_call()
		})
		if checksum != 10077 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_knockrequestslistener_call: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_livelocationsharelistener_call()
		})
		if checksum != 34519 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_livelocationsharelistener_call: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_mediapreviewconfiglistener_on_change()
		})
		if checksum != 42142 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_mediapreviewconfiglistener_on_change: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_notificationsettingsdelegate_settings_did_change()
		})
		if checksum != 51708 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_notificationsettingsdelegate_settings_did_change: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_paginationstatuslistener_on_update()
		})
		if checksum != 65318 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_paginationstatuslistener_on_update: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_progresswatcher_transmission_progress()
		})
		if checksum != 41133 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_progresswatcher_transmission_progress: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_qrloginprogresslistener_on_update()
		})
		if checksum != 9758 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_qrloginprogresslistener_on_update: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_recoverystatelistener_on_update()
		})
		if checksum != 64575 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_recoverystatelistener_on_update: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomaccountdatalistener_on_change()
		})
		if checksum != 58105 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomaccountdatalistener_on_change: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearchentrieslistener_on_update()
		})
		if checksum != 41968 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearchentrieslistener_on_update: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roominfolistener_call()
		})
		if checksum != 44934 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roominfolistener_call: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieslistener_on_update()
		})
		if checksum != 12576 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieslistener_on_update: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomlistloadingstatelistener_on_update()
		})
		if checksum != 23169 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomlistloadingstatelistener_on_update: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomlistservicestatelistener_on_update()
		})
		if checksum != 24823 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomlistservicestatelistener_on_update: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_roomlistservicesyncindicatorlistener_on_update()
		})
		if checksum != 36937 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_roomlistservicesyncindicatorlistener_on_update: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_sendqueueroomerrorlistener_on_error()
		})
		if checksum != 38224 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_sendqueueroomerrorlistener_on_error: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_request()
		})
		if checksum != 3417 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_request: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_accept_verification_request()
		})
		if checksum != 3733 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_accept_verification_request: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_start_sas_verification()
		})
		if checksum != 56833 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_start_sas_verification: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_data()
		})
		if checksum != 30840 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_data: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_fail()
		})
		if checksum != 32164 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_fail: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_cancel()
		})
		if checksum != 3367 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_cancel: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_finish()
		})
		if checksum != 37905 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_finish: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_syncservicestateobserver_on_update()
		})
		if checksum != 62231 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_syncservicestateobserver_on_update: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_timelinelistener_on_update()
		})
		if checksum != 30147 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_timelinelistener_on_update: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_typingnotificationslistener_call()
		})
		if checksum != 64299 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_typingnotificationslistener_call: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_unabletodecryptdelegate_on_utd()
		})
		if checksum != 61791 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_unabletodecryptdelegate_on_utd: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_verificationstatelistener_on_update()
		})
		if checksum != 38998 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_verificationstatelistener_on_update: UniFFI API checksum mismatch")
		}
	}
	{
		checksum := rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
			return C.uniffi_matrix_sdk_ffi_checksum_method_widgetcapabilitiesprovider_acquire_capabilities()
		})
		if checksum != 12846 {
			// If this happens try cleaning and rebuilding your project
			panic("matrix_sdk_ffi: uniffi_matrix_sdk_ffi_checksum_method_widgetcapabilitiesprovider_acquire_capabilities: UniFFI API checksum mismatch")
		}
	}
}

type FfiConverterUint8 struct{}

var FfiConverterUint8INSTANCE = FfiConverterUint8{}

func (FfiConverterUint8) Lower(value uint8) C.uint8_t {
	return C.uint8_t(value)
}

func (FfiConverterUint8) Write(writer io.Writer, value uint8) {
	writeUint8(writer, value)
}

func (FfiConverterUint8) Lift(value C.uint8_t) uint8 {
	return uint8(value)
}

func (FfiConverterUint8) Read(reader io.Reader) uint8 {
	return readUint8(reader)
}

type FfiDestroyerUint8 struct{}

func (FfiDestroyerUint8) Destroy(_ uint8) {}

type FfiConverterUint16 struct{}

var FfiConverterUint16INSTANCE = FfiConverterUint16{}

func (FfiConverterUint16) Lower(value uint16) C.uint16_t {
	return C.uint16_t(value)
}

func (FfiConverterUint16) Write(writer io.Writer, value uint16) {
	writeUint16(writer, value)
}

func (FfiConverterUint16) Lift(value C.uint16_t) uint16 {
	return uint16(value)
}

func (FfiConverterUint16) Read(reader io.Reader) uint16 {
	return readUint16(reader)
}

type FfiDestroyerUint16 struct{}

func (FfiDestroyerUint16) Destroy(_ uint16) {}

type FfiConverterUint32 struct{}

var FfiConverterUint32INSTANCE = FfiConverterUint32{}

func (FfiConverterUint32) Lower(value uint32) C.uint32_t {
	return C.uint32_t(value)
}

func (FfiConverterUint32) Write(writer io.Writer, value uint32) {
	writeUint32(writer, value)
}

func (FfiConverterUint32) Lift(value C.uint32_t) uint32 {
	return uint32(value)
}

func (FfiConverterUint32) Read(reader io.Reader) uint32 {
	return readUint32(reader)
}

type FfiDestroyerUint32 struct{}

func (FfiDestroyerUint32) Destroy(_ uint32) {}

type FfiConverterInt32 struct{}

var FfiConverterInt32INSTANCE = FfiConverterInt32{}

func (FfiConverterInt32) Lower(value int32) C.int32_t {
	return C.int32_t(value)
}

func (FfiConverterInt32) Write(writer io.Writer, value int32) {
	writeInt32(writer, value)
}

func (FfiConverterInt32) Lift(value C.int32_t) int32 {
	return int32(value)
}

func (FfiConverterInt32) Read(reader io.Reader) int32 {
	return readInt32(reader)
}

type FfiDestroyerInt32 struct{}

func (FfiDestroyerInt32) Destroy(_ int32) {}

type FfiConverterUint64 struct{}

var FfiConverterUint64INSTANCE = FfiConverterUint64{}

func (FfiConverterUint64) Lower(value uint64) C.uint64_t {
	return C.uint64_t(value)
}

func (FfiConverterUint64) Write(writer io.Writer, value uint64) {
	writeUint64(writer, value)
}

func (FfiConverterUint64) Lift(value C.uint64_t) uint64 {
	return uint64(value)
}

func (FfiConverterUint64) Read(reader io.Reader) uint64 {
	return readUint64(reader)
}

type FfiDestroyerUint64 struct{}

func (FfiDestroyerUint64) Destroy(_ uint64) {}

type FfiConverterInt64 struct{}

var FfiConverterInt64INSTANCE = FfiConverterInt64{}

func (FfiConverterInt64) Lower(value int64) C.int64_t {
	return C.int64_t(value)
}

func (FfiConverterInt64) Write(writer io.Writer, value int64) {
	writeInt64(writer, value)
}

func (FfiConverterInt64) Lift(value C.int64_t) int64 {
	return int64(value)
}

func (FfiConverterInt64) Read(reader io.Reader) int64 {
	return readInt64(reader)
}

type FfiDestroyerInt64 struct{}

func (FfiDestroyerInt64) Destroy(_ int64) {}

type FfiConverterFloat64 struct{}

var FfiConverterFloat64INSTANCE = FfiConverterFloat64{}

func (FfiConverterFloat64) Lower(value float64) C.double {
	return C.double(value)
}

func (FfiConverterFloat64) Write(writer io.Writer, value float64) {
	writeFloat64(writer, value)
}

func (FfiConverterFloat64) Lift(value C.double) float64 {
	return float64(value)
}

func (FfiConverterFloat64) Read(reader io.Reader) float64 {
	return readFloat64(reader)
}

type FfiDestroyerFloat64 struct{}

func (FfiDestroyerFloat64) Destroy(_ float64) {}

type FfiConverterBool struct{}

var FfiConverterBoolINSTANCE = FfiConverterBool{}

func (FfiConverterBool) Lower(value bool) C.int8_t {
	if value {
		return C.int8_t(1)
	}
	return C.int8_t(0)
}

func (FfiConverterBool) Write(writer io.Writer, value bool) {
	if value {
		writeInt8(writer, 1)
	} else {
		writeInt8(writer, 0)
	}
}

func (FfiConverterBool) Lift(value C.int8_t) bool {
	return value != 0
}

func (FfiConverterBool) Read(reader io.Reader) bool {
	return readInt8(reader) != 0
}

type FfiDestroyerBool struct{}

func (FfiDestroyerBool) Destroy(_ bool) {}

type FfiConverterString struct{}

var FfiConverterStringINSTANCE = FfiConverterString{}

func (FfiConverterString) Lift(rb RustBufferI) string {
	defer rb.Free()
	reader := rb.AsReader()
	b, err := io.ReadAll(reader)
	if err != nil {
		panic(fmt.Errorf("reading reader: %w", err))
	}
	return string(b)
}

func (FfiConverterString) Read(reader io.Reader) string {
	length := readInt32(reader)
	buffer := make([]byte, length)
	read_length, err := reader.Read(buffer)
	if err != nil && err != io.EOF {
		panic(err)
	}
	if read_length != int(length) {
		panic(fmt.Errorf("bad read length when reading string, expected %d, read %d", length, read_length))
	}
	return string(buffer)
}

func (FfiConverterString) Lower(value string) C.RustBuffer {
	return stringToRustBuffer(value)
}

func (FfiConverterString) Write(writer io.Writer, value string) {
	if len(value) > math.MaxInt32 {
		panic("String is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	write_length, err := io.WriteString(writer, value)
	if err != nil {
		panic(err)
	}
	if write_length != len(value) {
		panic(fmt.Errorf("bad write length when writing string, expected %d, written %d", len(value), write_length))
	}
}

type FfiDestroyerString struct{}

func (FfiDestroyerString) Destroy(_ string) {}

type FfiConverterBytes struct{}

var FfiConverterBytesINSTANCE = FfiConverterBytes{}

func (c FfiConverterBytes) Lower(value []byte) C.RustBuffer {
	return LowerIntoRustBuffer[[]byte](c, value)
}

func (c FfiConverterBytes) Write(writer io.Writer, value []byte) {
	if len(value) > math.MaxInt32 {
		panic("[]byte is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	write_length, err := writer.Write(value)
	if err != nil {
		panic(err)
	}
	if write_length != len(value) {
		panic(fmt.Errorf("bad write length when writing []byte, expected %d, written %d", len(value), write_length))
	}
}

func (c FfiConverterBytes) Lift(rb RustBufferI) []byte {
	return LiftFromRustBuffer[[]byte](c, rb)
}

func (c FfiConverterBytes) Read(reader io.Reader) []byte {
	length := readInt32(reader)
	buffer := make([]byte, length)
	read_length, err := reader.Read(buffer)
	if err != nil && err != io.EOF {
		panic(err)
	}
	if read_length != int(length) {
		panic(fmt.Errorf("bad read length when reading []byte, expected %d, read %d", length, read_length))
	}
	return buffer
}

type FfiDestroyerBytes struct{}

func (FfiDestroyerBytes) Destroy(_ []byte) {}

// FfiConverterDuration converts between uniffi duration and Go duration.
type FfiConverterDuration struct{}

var FfiConverterDurationINSTANCE = FfiConverterDuration{}

func (c FfiConverterDuration) Lift(rb RustBufferI) time.Duration {
	return LiftFromRustBuffer[time.Duration](c, rb)
}

func (c FfiConverterDuration) Read(reader io.Reader) time.Duration {
	sec := readUint64(reader)
	nsec := readUint32(reader)
	return time.Duration(sec*1_000_000_000 + uint64(nsec))
}

func (c FfiConverterDuration) Lower(value time.Duration) C.RustBuffer {
	return LowerIntoRustBuffer[time.Duration](c, value)
}

func (c FfiConverterDuration) Write(writer io.Writer, value time.Duration) {
	if value.Nanoseconds() < 0 {
		// Rust does not support negative durations:
		// https://www.reddit.com/r/rust/comments/ljl55u/why_rusts_duration_not_supporting_negative_values/
		// This panic is very bad, because it depends on user input, and in Go user input related
		// error are supposed to be returned as errors, and not cause panics. However, with the
		// current architecture, its not possible to return an error from here, so panic is used as
		// the only other option to signal an error.
		panic("negative duration is not allowed")
	}

	writeUint64(writer, uint64(value)/1_000_000_000)
	writeUint32(writer, uint32(uint64(value)%1_000_000_000))
}

type FfiDestroyerDuration struct{}

func (FfiDestroyerDuration) Destroy(_ time.Duration) {}

// Below is an implementation of synchronization requirements outlined in the link.
// https://github.com/mozilla/uniffi-rs/blob/0dc031132d9493ca812c3af6e7dd60ad2ea95bf0/uniffi_bindgen/src/bindings/kotlin/templates/ObjectRuntime.kt#L31

type FfiObject struct {
	pointer       unsafe.Pointer
	callCounter   atomic.Int64
	cloneFunction func(unsafe.Pointer, *C.RustCallStatus) unsafe.Pointer
	freeFunction  func(unsafe.Pointer, *C.RustCallStatus)
	destroyed     atomic.Bool
}

func newFfiObject(
	pointer unsafe.Pointer,
	cloneFunction func(unsafe.Pointer, *C.RustCallStatus) unsafe.Pointer,
	freeFunction func(unsafe.Pointer, *C.RustCallStatus),
) FfiObject {
	return FfiObject{
		pointer:       pointer,
		cloneFunction: cloneFunction,
		freeFunction:  freeFunction,
	}
}

func (ffiObject *FfiObject) incrementPointer(debugName string) unsafe.Pointer {
	for {
		counter := ffiObject.callCounter.Load()
		if counter <= -1 {
			panic(fmt.Errorf("%v object has already been destroyed", debugName))
		}
		if counter == math.MaxInt64 {
			panic(fmt.Errorf("%v object call counter would overflow", debugName))
		}
		if ffiObject.callCounter.CompareAndSwap(counter, counter+1) {
			break
		}
	}

	return rustCall(func(status *C.RustCallStatus) unsafe.Pointer {
		return ffiObject.cloneFunction(ffiObject.pointer, status)
	})
}

func (ffiObject *FfiObject) decrementPointer() {
	if ffiObject.callCounter.Add(-1) == -1 {
		ffiObject.freeRustArcPtr()
	}
}

func (ffiObject *FfiObject) destroy() {
	if ffiObject.destroyed.CompareAndSwap(false, true) {
		if ffiObject.callCounter.Add(-1) == -1 {
			ffiObject.freeRustArcPtr()
		}
	}
}

func (ffiObject *FfiObject) freeRustArcPtr() {
	rustCall(func(status *C.RustCallStatus) int32 {
		ffiObject.freeFunction(ffiObject.pointer, status)
		return 0
	})
}

type ClientInterface interface {
	// Aborts an existing OIDC login operation that might have been cancelled,
	// failed etc.
	AbortOidcAuth(authorizationData *matrix_sdk.OAuthAuthorizationData)
	// Get the content of the event of the given type out of the account data
	// store.
	//
	// It will be returned as a JSON string.
	AccountData(eventType string) (*string, error)
	AccountUrl(action *AccountManagementAction) (*string, error)
	// Find all sliding sync versions that are available.
	//
	// Be careful: This method may hit the store and will send new requests for
	// each call. It can be costly to call it repeatedly.
	//
	// If `.well-known` or `/versions` is unreachable, it will simply move
	// potential sliding sync versions aside. No error will be reported.
	AvailableSlidingSyncVersions() []SlidingSyncVersion
	// Sends a request to retrieve the avatar URL. Will fill the cache used by
	// [`Self::cached_avatar_url`] on success.
	AvatarUrl() (*string, error)
	// Waits until an at least partially synced room is received, and returns
	// it.
	//
	// **Note: this function will loop endlessly until either it finds the room
	// or an externally set timeout happens.**
	AwaitRoomRemoteEcho(roomId string) (*Room, error)
	// Retrieves an avatar cached from a previous call to [`Self::avatar_url`].
	CachedAvatarUrl() (*string, error)
	// Lets the user know whether this is an `m.login.password` based
	// auth and if the account can actually be deactivated
	CanDeactivateAccount() bool
	// Clear all the non-critical caches for this Client instance.
	//
	// - This will empty all the room's persisted event caches, so all rooms
	// will start as if they were empty.
	// - This will empty the media cache according to the current media
	// retention policy.
	ClearCaches() error
	CreateRoom(request CreateRoomParameters) (string, error)
	// Login using JWT
	// This is an implementation of the custom_login https://docs.rs/matrix-sdk/latest/matrix_sdk/matrix_auth/struct.MatrixAuth.html#method.login_custom
	// For more information on logging in with JWT: https://element-hq.github.io/synapse/latest/jwt.html
	CustomLoginWithJwt(jwt string, initialDeviceName *string, deviceId *string) error
	// Deactivate this account definitively.
	// Similarly to `encryption::reset_identity` this
	// will only work with password-based authentication (`m.login.password`)
	//
	// # Arguments
	//
	// * `auth_data` - This request uses the [User-Interactive Authentication
	// API][uiaa]. The first request needs to set this to `None` and will
	// always fail and the same request needs to be made but this time with
	// some `auth_data` provided.
	DeactivateAccount(authData *AuthData, eraseData bool) error
	// Deletes a pusher of given pusher ids
	DeletePusher(identifiers PusherIdentifiers) error
	DeviceId() (string, error)
	DisplayName() (string, error)
	// Enables or disables all the room send queues at once.
	//
	// When connectivity is lost on a device, it is recommended to disable the
	// room sending queues.
	//
	// This can be controlled for individual rooms, using
	// [`Room::enable_send_queue`].
	EnableAllSendQueues(enable bool)
	Encryption() *Encryption
	GetDmRoom(userId string) (**Room, error)
	// Get the invite request avatars display policy
	// currently stored in the cache.
	GetInviteAvatarsDisplayPolicy() (InviteAvatars, error)
	GetMediaContent(mediaSource *MediaSource) ([]byte, error)
	GetMediaFile(mediaSource *MediaSource, filename *string, mimeType string, useCache bool, tempDir *string) (*MediaFileHandle, error)
	// Get the media previews timeline display policy
	// currently stored in the cache.
	GetMediaPreviewDisplayPolicy() (MediaPreviews, error)
	GetMediaThumbnail(mediaSource *MediaSource, width uint64, height uint64) ([]byte, error)
	GetNotificationSettings() *NotificationSettings
	GetProfile(userId string) (UserProfile, error)
	GetRecentlyVisitedRooms() ([]string, error)
	// Get a room by its ID.
	//
	// # Arguments
	//
	// * `room_id` - The ID of the room to get.
	//
	// # Returns
	//
	// A `Result` containing an optional room, or a `ClientError`.
	// This method will not initialize the room's timeline or populate it with
	// events.
	GetRoom(roomId string) (**Room, error)
	// Given a room alias, get the preview of a room, to interact with it.
	GetRoomPreviewFromRoomAlias(roomAlias string) (*RoomPreview, error)
	// Given a room id, get the preview of a room, to interact with it.
	//
	// The list of `via_servers` must be a list of servers that know
	// about the room and can resolve it, and that may appear as a `via`
	// parameter in e.g. a permalink URL. This list can be empty.
	GetRoomPreviewFromRoomId(roomId string, viaServers []string) (*RoomPreview, error)
	GetSessionVerificationController() (*SessionVerificationController, error)
	// Allows generic GET requests to be made through the SDKs internal HTTP
	// client
	GetUrl(url string) (string, error)
	// The homeserver this client is configured to use.
	Homeserver() string
	// Information about login options for the client's homeserver.
	HomeserverLoginDetails() *HomeserverLoginDetails
	IgnoreUser(userId string) error
	IgnoredUsers() ([]string, error)
	// Checks if the server supports the report room API.
	IsReportRoomApiSupported() (bool, error)
	// Checks if a room alias is not in use yet.
	//
	// Returns:
	// - `Ok(true)` if the room alias is available.
	// - `Ok(false)` if it's not (the resolve alias request returned a `404`
	// status code).
	// - An `Err` otherwise.
	IsRoomAliasAvailable(alias string) (bool, error)
	// Join a room by its ID.
	//
	// Use this method when the homeserver already knows of the given room ID.
	// Otherwise use `join_room_by_id_or_alias` so you can pass a list of
	// server names for the homeserver to find the room.
	JoinRoomById(roomId string) (*Room, error)
	// Join a room by its ID or alias.
	//
	// When supplying the room's ID, you can also supply a list of server names
	// for the homeserver to find the room. Typically these server names
	// come from a permalink's `via` parameters, or from resolving a room's
	// alias into an ID.
	JoinRoomByIdOrAlias(roomIdOrAlias string, serverNames []string) (*Room, error)
	// Knock on a room to join it using its ID or alias.
	Knock(roomIdOrAlias string, reason *string, serverNames []string) (*Room, error)
	// Login using a username and password.
	Login(username string, password string, initialDeviceName *string, deviceId *string) error
	// Login using an email and password.
	LoginWithEmail(email string, password string, initialDeviceName *string, deviceId *string) error
	// Completes the OIDC login process.
	LoginWithOidcCallback(callbackUrl string) error
	// Log the current user out.
	Logout() error
	NotificationClient(processSetup NotificationProcessSetup) (*NotificationClient, error)
	// Subscribe to updates of global account data events.
	//
	// Be careful that only the most recent value can be observed. Subscribers
	// are notified when a new value is sent, but there is no guarantee that
	// they will see all values.
	ObserveAccountDataEvent(eventType AccountDataEventType, listener AccountDataListener) *TaskHandle
	// Subscribe to updates of room account data events.
	//
	// Be careful that only the most recent value can be observed. Subscribers
	// are notified when a new value is sent, but there is no guarantee that
	// they will see all values.
	ObserveRoomAccountDataEvent(roomId string, eventType RoomAccountDataEventType, listener RoomAccountDataListener) (*TaskHandle, error)
	RemoveAvatar() error
	// Empty the server version and unstable features cache.
	//
	// Since the SDK caches server capabilities (versions and unstable
	// features), it's possible to have a stale entry in the cache. This
	// functions makes it possible to force reset it.
	ResetServerCapabilities() error
	// Resolves the given room alias to a room ID (and a list of servers), if
	// possible.
	ResolveRoomAlias(roomAlias string) (*ResolvedRoomAlias, error)
	// Restores the client from a `Session`.
	//
	// It reloads the entire set of rooms from the previous session.
	//
	// If you want to control the amount of rooms to reloads, check
	// [`Client::restore_session_with`].
	RestoreSession(session Session) error
	// Restores the client from a `Session`.
	//
	// It reloads a set of rooms controlled by [`RoomLoadSettings`].
	RestoreSessionWith(session Session, roomLoadSettings RoomLoadSettings) error
	// Checks if a room alias exists in the current homeserver.
	RoomAliasExists(roomAlias string) (bool, error)
	RoomDirectorySearch() *RoomDirectorySearch
	Rooms() []*Room
	SearchUsers(searchTerm string, limit uint64) (SearchUsersResults, error)
	// The URL of the server.
	//
	// Not to be confused with the `Self::homeserver`. `server` is usually
	// the server part in a user ID, e.g. with `@mnt_io:matrix.org`, here
	// `matrix.org` is the server, whilst `matrix-client.matrix.org` is the
	// homeserver (at the time of writing — 2024-08-28).
	//
	// This value is optional depending on how the `Client` has been built.
	// If it's been built from a homeserver URL directly, we don't know the
	// server. However, if the `Client` has been built from a server URL or
	// name, then the homeserver has been discovered, and we know both.
	Server() *string
	Session() (Session, error)
	// Set the given account data content for the given event type.
	//
	// It should be supplied as a JSON string.
	SetAccountData(eventType string, content string) error
	// Sets the [ClientDelegate] which will inform about authentication errors.
	// Returns an error if the delegate was already set.
	SetDelegate(delegate *ClientDelegate) (**TaskHandle, error)
	SetDisplayName(name string) error
	// Set the invite request avatars display policy
	SetInviteAvatarsDisplayPolicy(policy InviteAvatars) error
	// Set the media previews timeline display policy
	SetMediaPreviewDisplayPolicy(policy MediaPreviews) error
	// Set the media retention policy.
	SetMediaRetentionPolicy(policy matrix_sdk_base.MediaRetentionPolicy) error
	// Registers a pusher with given parameters
	SetPusher(identifiers PusherIdentifiers, kind PusherKind, appDisplayName string, deviceDisplayName string, profileTag *string, lang string) error
	// Sets the [UnableToDecryptDelegate] which will inform about UTDs.
	// Returns an error if the delegate was already set.
	SetUtdDelegate(utdDelegate UnableToDecryptDelegate) error
	// The sliding sync version.
	SlidingSyncVersion() SlidingSyncVersion
	// Returns a handler to start the SSO login process.
	StartSsoLogin(redirectUrl string, idpId *string) (*SsoHandler, error)
	SubscribeToIgnoredUsers(listener IgnoredUsersListener) *TaskHandle
	// Subscribe to changes in the media preview configuration.
	SubscribeToMediaPreviewConfig(listener MediaPreviewConfigListener) (*TaskHandle, error)
	// Subscribe to the global enablement status of the send queue, at the
	// client-wide level.
	//
	// The given listener will be immediately called with the initial value of
	// the enablement status.
	SubscribeToSendQueueStatus(listener SendQueueRoomErrorListener) *TaskHandle
	SyncService() *SyncServiceBuilder
	TrackRecentlyVisitedRoom(room string) error
	UnignoreUser(userId string) error
	UploadAvatar(mimeType string, data []byte) error
	UploadMedia(mimeType string, data []byte, progressWatcher *ProgressWatcher) (string, error)
	// Requests the URL needed for opening a web view using OIDC. Once the web
	// view has succeeded, call `login_with_oidc_callback` with the callback it
	// returns. If a failure occurs and a callback isn't available, make sure
	// to call `abort_oidc_auth` to inform the client of this.
	//
	// # Arguments
	//
	// * `oidc_configuration` - The configuration used to load the credentials
	// of the client if it is already registered with the authorization
	// server, or register the client and store its credentials if it isn't.
	//
	// * `prompt` - The desired user experience in the web UI. No value means
	// that the user wishes to login into an existing account, and a value of
	// `Create` means that the user wishes to register a new account.
	//
	// * `login_hint` - A generic login hint that an identity provider can use
	// to pre-fill the login form. The format of this hint is not restricted
	// by the spec as external providers all have their own way to handle the hint.
	// However, it should be noted that when providing a user ID as a hint
	// for MAS (with no upstream provider), then the format to use is defined
	// by [MSC4198]: https://github.com/matrix-org/matrix-spec-proposals/pull/4198
	UrlForOidc(oidcConfiguration OidcConfiguration, prompt *OidcPrompt, loginHint *string) (*matrix_sdk.OAuthAuthorizationData, error)
	UserId() (string, error)
	// The server name part of the current user ID
	UserIdServerName() (string, error)
}
type Client struct {
	ffiObject FfiObject
}

// Aborts an existing OIDC login operation that might have been cancelled,
// failed etc.
func (_self *Client) AbortOidcAuth(authorizationData *matrix_sdk.OAuthAuthorizationData) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_abort_oidc_auth(
			_pointer, matrix_sdk.FfiConverterOAuthAuthorizationDataINSTANCE.Lower(authorizationData)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

}

// Get the content of the event of the given type out of the account data
// store.
//
// It will be returned as a JSON string.
func (_self *Client) AccountData(eventType string) (*string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) *string {
			return FfiConverterOptionalStringINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_account_data(
			_pointer, FfiConverterStringINSTANCE.Lower(eventType)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

func (_self *Client) AccountUrl(action *AccountManagementAction) (*string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) *string {
			return FfiConverterOptionalStringINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_account_url(
			_pointer, FfiConverterOptionalAccountManagementActionINSTANCE.Lower(action)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// Find all sliding sync versions that are available.
//
// Be careful: This method may hit the store and will send new requests for
// each call. It can be costly to call it repeatedly.
//
// If `.well-known` or `/versions` is unreachable, it will simply move
// potential sliding sync versions aside. No error will be reported.
func (_self *Client) AvailableSlidingSyncVersions() []SlidingSyncVersion {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, _ := uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) []SlidingSyncVersion {
			return FfiConverterSequenceSlidingSyncVersionINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_available_sliding_sync_versions(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res
}

// Sends a request to retrieve the avatar URL. Will fill the cache used by
// [`Self::cached_avatar_url`] on success.
func (_self *Client) AvatarUrl() (*string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) *string {
			return FfiConverterOptionalStringINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_avatar_url(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// Waits until an at least partially synced room is received, and returns
// it.
//
// **Note: this function will loop endlessly until either it finds the room
// or an externally set timeout happens.**
func (_self *Client) AwaitRoomRemoteEcho(roomId string) (*Room, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *Room {
			return FfiConverterRoomINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_await_room_remote_echo(
			_pointer, FfiConverterStringINSTANCE.Lower(roomId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

// Retrieves an avatar cached from a previous call to [`Self::avatar_url`].
func (_self *Client) CachedAvatarUrl() (*string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) *string {
			return FfiConverterOptionalStringINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_cached_avatar_url(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// Lets the user know whether this is an `m.login.password` based
// auth and if the account can actually be deactivated
func (_self *Client) CanDeactivateAccount() bool {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_client_can_deactivate_account(
			_pointer, _uniffiStatus)
	}))
}

// Clear all the non-critical caches for this Client instance.
//
// - This will empty all the room's persisted event caches, so all rooms
// will start as if they were empty.
// - This will empty the media cache according to the current media
// retention policy.
func (_self *Client) ClearCaches() error {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_clear_caches(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Client) CreateRoom(request CreateRoomParameters) (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) string {
			return FfiConverterStringINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_create_room(
			_pointer, FfiConverterCreateRoomParametersINSTANCE.Lower(request)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// Login using JWT
// This is an implementation of the custom_login https://docs.rs/matrix-sdk/latest/matrix_sdk/matrix_auth/struct.MatrixAuth.html#method.login_custom
// For more information on logging in with JWT: https://element-hq.github.io/synapse/latest/jwt.html
func (_self *Client) CustomLoginWithJwt(jwt string, initialDeviceName *string, deviceId *string) error {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_custom_login_with_jwt(
			_pointer, FfiConverterStringINSTANCE.Lower(jwt), FfiConverterOptionalStringINSTANCE.Lower(initialDeviceName), FfiConverterOptionalStringINSTANCE.Lower(deviceId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Deactivate this account definitively.
// Similarly to `encryption::reset_identity` this
// will only work with password-based authentication (`m.login.password`)
//
// # Arguments
//
// * `auth_data` - This request uses the [User-Interactive Authentication
// API][uiaa]. The first request needs to set this to `None` and will
// always fail and the same request needs to be made but this time with
// some `auth_data` provided.
func (_self *Client) DeactivateAccount(authData *AuthData, eraseData bool) error {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_deactivate_account(
			_pointer, FfiConverterOptionalAuthDataINSTANCE.Lower(authData), FfiConverterBoolINSTANCE.Lower(eraseData)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Deletes a pusher of given pusher ids
func (_self *Client) DeletePusher(identifiers PusherIdentifiers) error {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_delete_pusher(
			_pointer, FfiConverterPusherIdentifiersINSTANCE.Lower(identifiers)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Client) DeviceId() (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[ClientError](FfiConverterClientError{}, func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_client_device_id(
				_pointer, _uniffiStatus),
		}
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue string
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterStringINSTANCE.Lift(_uniffiRV), nil
	}
}

func (_self *Client) DisplayName() (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) string {
			return FfiConverterStringINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_display_name(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// Enables or disables all the room send queues at once.
//
// When connectivity is lost on a device, it is recommended to disable the
// room sending queues.
//
// This can be controlled for individual rooms, using
// [`Room::enable_send_queue`].
func (_self *Client) EnableAllSendQueues(enable bool) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_enable_all_send_queues(
			_pointer, FfiConverterBoolINSTANCE.Lower(enable)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

}

func (_self *Client) Encryption() *Encryption {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterEncryptionINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_client_encryption(
			_pointer, _uniffiStatus)
	}))
}

func (_self *Client) GetDmRoom(userId string) (**Room, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[ClientError](FfiConverterClientError{}, func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_client_get_dm_room(
				_pointer, FfiConverterStringINSTANCE.Lower(userId), _uniffiStatus),
		}
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue **Room
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterOptionalRoomINSTANCE.Lift(_uniffiRV), nil
	}
}

// Get the invite request avatars display policy
// currently stored in the cache.
func (_self *Client) GetInviteAvatarsDisplayPolicy() (InviteAvatars, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) InviteAvatars {
			return FfiConverterInviteAvatarsINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_get_invite_avatars_display_policy(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

func (_self *Client) GetMediaContent(mediaSource *MediaSource) ([]byte, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) []byte {
			return FfiConverterBytesINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_get_media_content(
			_pointer, FfiConverterMediaSourceINSTANCE.Lower(mediaSource)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

func (_self *Client) GetMediaFile(mediaSource *MediaSource, filename *string, mimeType string, useCache bool, tempDir *string) (*MediaFileHandle, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *MediaFileHandle {
			return FfiConverterMediaFileHandleINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_get_media_file(
			_pointer, FfiConverterMediaSourceINSTANCE.Lower(mediaSource), FfiConverterOptionalStringINSTANCE.Lower(filename), FfiConverterStringINSTANCE.Lower(mimeType), FfiConverterBoolINSTANCE.Lower(useCache), FfiConverterOptionalStringINSTANCE.Lower(tempDir)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

// Get the media previews timeline display policy
// currently stored in the cache.
func (_self *Client) GetMediaPreviewDisplayPolicy() (MediaPreviews, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) MediaPreviews {
			return FfiConverterMediaPreviewsINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_get_media_preview_display_policy(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

func (_self *Client) GetMediaThumbnail(mediaSource *MediaSource, width uint64, height uint64) ([]byte, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) []byte {
			return FfiConverterBytesINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_get_media_thumbnail(
			_pointer, FfiConverterMediaSourceINSTANCE.Lower(mediaSource), FfiConverterUint64INSTANCE.Lower(width), FfiConverterUint64INSTANCE.Lower(height)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

func (_self *Client) GetNotificationSettings() *NotificationSettings {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, _ := uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *NotificationSettings {
			return FfiConverterNotificationSettingsINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_get_notification_settings(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res
}

func (_self *Client) GetProfile(userId string) (UserProfile, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) UserProfile {
			return FfiConverterUserProfileINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_get_profile(
			_pointer, FfiConverterStringINSTANCE.Lower(userId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

func (_self *Client) GetRecentlyVisitedRooms() ([]string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) []string {
			return FfiConverterSequenceStringINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_get_recently_visited_rooms(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// Get a room by its ID.
//
// # Arguments
//
// * `room_id` - The ID of the room to get.
//
// # Returns
//
// A `Result` containing an optional room, or a `ClientError`.
// This method will not initialize the room's timeline or populate it with
// events.
func (_self *Client) GetRoom(roomId string) (**Room, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[ClientError](FfiConverterClientError{}, func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_client_get_room(
				_pointer, FfiConverterStringINSTANCE.Lower(roomId), _uniffiStatus),
		}
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue **Room
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterOptionalRoomINSTANCE.Lift(_uniffiRV), nil
	}
}

// Given a room alias, get the preview of a room, to interact with it.
func (_self *Client) GetRoomPreviewFromRoomAlias(roomAlias string) (*RoomPreview, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *RoomPreview {
			return FfiConverterRoomPreviewINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_get_room_preview_from_room_alias(
			_pointer, FfiConverterStringINSTANCE.Lower(roomAlias)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

// Given a room id, get the preview of a room, to interact with it.
//
// The list of `via_servers` must be a list of servers that know
// about the room and can resolve it, and that may appear as a `via`
// parameter in e.g. a permalink URL. This list can be empty.
func (_self *Client) GetRoomPreviewFromRoomId(roomId string, viaServers []string) (*RoomPreview, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *RoomPreview {
			return FfiConverterRoomPreviewINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_get_room_preview_from_room_id(
			_pointer, FfiConverterStringINSTANCE.Lower(roomId), FfiConverterSequenceStringINSTANCE.Lower(viaServers)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

func (_self *Client) GetSessionVerificationController() (*SessionVerificationController, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *SessionVerificationController {
			return FfiConverterSessionVerificationControllerINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_get_session_verification_controller(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

// Allows generic GET requests to be made through the SDKs internal HTTP
// client
func (_self *Client) GetUrl(url string) (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) string {
			return FfiConverterStringINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_get_url(
			_pointer, FfiConverterStringINSTANCE.Lower(url)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// The homeserver this client is configured to use.
func (_self *Client) Homeserver() string {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_client_homeserver(
				_pointer, _uniffiStatus),
		}
	}))
}

// Information about login options for the client's homeserver.
func (_self *Client) HomeserverLoginDetails() *HomeserverLoginDetails {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, _ := uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *HomeserverLoginDetails {
			return FfiConverterHomeserverLoginDetailsINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_homeserver_login_details(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res
}

func (_self *Client) IgnoreUser(userId string) error {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_ignore_user(
			_pointer, FfiConverterStringINSTANCE.Lower(userId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Client) IgnoredUsers() ([]string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) []string {
			return FfiConverterSequenceStringINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_ignored_users(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// Checks if the server supports the report room API.
func (_self *Client) IsReportRoomApiSupported() (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_is_report_room_api_supported(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

// Checks if a room alias is not in use yet.
//
// Returns:
// - `Ok(true)` if the room alias is available.
// - `Ok(false)` if it's not (the resolve alias request returned a `404`
// status code).
// - An `Err` otherwise.
func (_self *Client) IsRoomAliasAvailable(alias string) (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_is_room_alias_available(
			_pointer, FfiConverterStringINSTANCE.Lower(alias)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

// Join a room by its ID.
//
// Use this method when the homeserver already knows of the given room ID.
// Otherwise use `join_room_by_id_or_alias` so you can pass a list of
// server names for the homeserver to find the room.
func (_self *Client) JoinRoomById(roomId string) (*Room, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *Room {
			return FfiConverterRoomINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_join_room_by_id(
			_pointer, FfiConverterStringINSTANCE.Lower(roomId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

// Join a room by its ID or alias.
//
// When supplying the room's ID, you can also supply a list of server names
// for the homeserver to find the room. Typically these server names
// come from a permalink's `via` parameters, or from resolving a room's
// alias into an ID.
func (_self *Client) JoinRoomByIdOrAlias(roomIdOrAlias string, serverNames []string) (*Room, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *Room {
			return FfiConverterRoomINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_join_room_by_id_or_alias(
			_pointer, FfiConverterStringINSTANCE.Lower(roomIdOrAlias), FfiConverterSequenceStringINSTANCE.Lower(serverNames)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

// Knock on a room to join it using its ID or alias.
func (_self *Client) Knock(roomIdOrAlias string, reason *string, serverNames []string) (*Room, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *Room {
			return FfiConverterRoomINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_knock(
			_pointer, FfiConverterStringINSTANCE.Lower(roomIdOrAlias), FfiConverterOptionalStringINSTANCE.Lower(reason), FfiConverterSequenceStringINSTANCE.Lower(serverNames)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

// Login using a username and password.
func (_self *Client) Login(username string, password string, initialDeviceName *string, deviceId *string) error {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_login(
			_pointer, FfiConverterStringINSTANCE.Lower(username), FfiConverterStringINSTANCE.Lower(password), FfiConverterOptionalStringINSTANCE.Lower(initialDeviceName), FfiConverterOptionalStringINSTANCE.Lower(deviceId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Login using an email and password.
func (_self *Client) LoginWithEmail(email string, password string, initialDeviceName *string, deviceId *string) error {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_login_with_email(
			_pointer, FfiConverterStringINSTANCE.Lower(email), FfiConverterStringINSTANCE.Lower(password), FfiConverterOptionalStringINSTANCE.Lower(initialDeviceName), FfiConverterOptionalStringINSTANCE.Lower(deviceId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Completes the OIDC login process.
func (_self *Client) LoginWithOidcCallback(callbackUrl string) error {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[OidcError](
		FfiConverterOidcErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_login_with_oidc_callback(
			_pointer, FfiConverterStringINSTANCE.Lower(callbackUrl)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Log the current user out.
func (_self *Client) Logout() error {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_logout(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Client) NotificationClient(processSetup NotificationProcessSetup) (*NotificationClient, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *NotificationClient {
			return FfiConverterNotificationClientINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_notification_client(
			_pointer, FfiConverterNotificationProcessSetupINSTANCE.Lower(processSetup)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

// Subscribe to updates of global account data events.
//
// Be careful that only the most recent value can be observed. Subscribers
// are notified when a new value is sent, but there is no guarantee that
// they will see all values.
func (_self *Client) ObserveAccountDataEvent(eventType AccountDataEventType, listener AccountDataListener) *TaskHandle {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTaskHandleINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_client_observe_account_data_event(
			_pointer, FfiConverterAccountDataEventTypeINSTANCE.Lower(eventType), FfiConverterCallbackInterfaceAccountDataListenerINSTANCE.Lower(listener), _uniffiStatus)
	}))
}

// Subscribe to updates of room account data events.
//
// Be careful that only the most recent value can be observed. Subscribers
// are notified when a new value is sent, but there is no guarantee that
// they will see all values.
func (_self *Client) ObserveRoomAccountDataEvent(roomId string, eventType RoomAccountDataEventType, listener RoomAccountDataListener) (*TaskHandle, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[ClientError](FfiConverterClientError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_client_observe_room_account_data_event(
			_pointer, FfiConverterStringINSTANCE.Lower(roomId), FfiConverterRoomAccountDataEventTypeINSTANCE.Lower(eventType), FfiConverterCallbackInterfaceRoomAccountDataListenerINSTANCE.Lower(listener), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *TaskHandle
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterTaskHandleINSTANCE.Lift(_uniffiRV), nil
	}
}

func (_self *Client) RemoveAvatar() error {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_remove_avatar(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Empty the server version and unstable features cache.
//
// Since the SDK caches server capabilities (versions and unstable
// features), it's possible to have a stale entry in the cache. This
// functions makes it possible to force reset it.
func (_self *Client) ResetServerCapabilities() error {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_reset_server_capabilities(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Resolves the given room alias to a room ID (and a list of servers), if
// possible.
func (_self *Client) ResolveRoomAlias(roomAlias string) (*ResolvedRoomAlias, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) *ResolvedRoomAlias {
			return FfiConverterOptionalResolvedRoomAliasINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_resolve_room_alias(
			_pointer, FfiConverterStringINSTANCE.Lower(roomAlias)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// Restores the client from a `Session`.
//
// It reloads the entire set of rooms from the previous session.
//
// If you want to control the amount of rooms to reloads, check
// [`Client::restore_session_with`].
func (_self *Client) RestoreSession(session Session) error {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_restore_session(
			_pointer, FfiConverterSessionINSTANCE.Lower(session)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Restores the client from a `Session`.
//
// It reloads a set of rooms controlled by [`RoomLoadSettings`].
func (_self *Client) RestoreSessionWith(session Session, roomLoadSettings RoomLoadSettings) error {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_restore_session_with(
			_pointer, FfiConverterSessionINSTANCE.Lower(session), FfiConverterRoomLoadSettingsINSTANCE.Lower(roomLoadSettings)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Checks if a room alias exists in the current homeserver.
func (_self *Client) RoomAliasExists(roomAlias string) (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_room_alias_exists(
			_pointer, FfiConverterStringINSTANCE.Lower(roomAlias)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

func (_self *Client) RoomDirectorySearch() *RoomDirectorySearch {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterRoomDirectorySearchINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_client_room_directory_search(
			_pointer, _uniffiStatus)
	}))
}

func (_self *Client) Rooms() []*Room {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceRoomINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_client_rooms(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *Client) SearchUsers(searchTerm string, limit uint64) (SearchUsersResults, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) SearchUsersResults {
			return FfiConverterSearchUsersResultsINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_search_users(
			_pointer, FfiConverterStringINSTANCE.Lower(searchTerm), FfiConverterUint64INSTANCE.Lower(limit)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// The URL of the server.
//
// Not to be confused with the `Self::homeserver`. `server` is usually
// the server part in a user ID, e.g. with `@mnt_io:matrix.org`, here
// `matrix.org` is the server, whilst `matrix-client.matrix.org` is the
// homeserver (at the time of writing — 2024-08-28).
//
// This value is optional depending on how the `Client` has been built.
// If it's been built from a homeserver URL directly, we don't know the
// server. However, if the `Client` has been built from a server URL or
// name, then the homeserver has been discovered, and we know both.
func (_self *Client) Server() *string {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_client_server(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *Client) Session() (Session, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[ClientError](FfiConverterClientError{}, func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_client_session(
				_pointer, _uniffiStatus),
		}
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue Session
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterSessionINSTANCE.Lift(_uniffiRV), nil
	}
}

// Set the given account data content for the given event type.
//
// It should be supplied as a JSON string.
func (_self *Client) SetAccountData(eventType string, content string) error {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_set_account_data(
			_pointer, FfiConverterStringINSTANCE.Lower(eventType), FfiConverterStringINSTANCE.Lower(content)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Sets the [ClientDelegate] which will inform about authentication errors.
// Returns an error if the delegate was already set.
func (_self *Client) SetDelegate(delegate *ClientDelegate) (**TaskHandle, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[ClientError](FfiConverterClientError{}, func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_client_set_delegate(
				_pointer, FfiConverterOptionalCallbackInterfaceClientDelegateINSTANCE.Lower(delegate), _uniffiStatus),
		}
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue **TaskHandle
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterOptionalTaskHandleINSTANCE.Lift(_uniffiRV), nil
	}
}

func (_self *Client) SetDisplayName(name string) error {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_set_display_name(
			_pointer, FfiConverterStringINSTANCE.Lower(name)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Set the invite request avatars display policy
func (_self *Client) SetInviteAvatarsDisplayPolicy(policy InviteAvatars) error {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_set_invite_avatars_display_policy(
			_pointer, FfiConverterInviteAvatarsINSTANCE.Lower(policy)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Set the media previews timeline display policy
func (_self *Client) SetMediaPreviewDisplayPolicy(policy MediaPreviews) error {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_set_media_preview_display_policy(
			_pointer, FfiConverterMediaPreviewsINSTANCE.Lower(policy)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Set the media retention policy.
func (_self *Client) SetMediaRetentionPolicy(policy matrix_sdk_base.MediaRetentionPolicy) error {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_set_media_retention_policy(
			_pointer, RustBufferFromExternal(matrix_sdk_base.FfiConverterMediaRetentionPolicyINSTANCE.Lower(policy))),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Registers a pusher with given parameters
func (_self *Client) SetPusher(identifiers PusherIdentifiers, kind PusherKind, appDisplayName string, deviceDisplayName string, profileTag *string, lang string) error {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_set_pusher(
			_pointer, FfiConverterPusherIdentifiersINSTANCE.Lower(identifiers), FfiConverterPusherKindINSTANCE.Lower(kind), FfiConverterStringINSTANCE.Lower(appDisplayName), FfiConverterStringINSTANCE.Lower(deviceDisplayName), FfiConverterOptionalStringINSTANCE.Lower(profileTag), FfiConverterStringINSTANCE.Lower(lang)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Sets the [UnableToDecryptDelegate] which will inform about UTDs.
// Returns an error if the delegate was already set.
func (_self *Client) SetUtdDelegate(utdDelegate UnableToDecryptDelegate) error {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_set_utd_delegate(
			_pointer, FfiConverterCallbackInterfaceUnableToDecryptDelegateINSTANCE.Lower(utdDelegate)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// The sliding sync version.
func (_self *Client) SlidingSyncVersion() SlidingSyncVersion {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSlidingSyncVersionINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_client_sliding_sync_version(
				_pointer, _uniffiStatus),
		}
	}))
}

// Returns a handler to start the SSO login process.
func (_self *Client) StartSsoLogin(redirectUrl string, idpId *string) (*SsoHandler, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[SsoError](
		FfiConverterSsoErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *SsoHandler {
			return FfiConverterSsoHandlerINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_start_sso_login(
			_pointer, FfiConverterStringINSTANCE.Lower(redirectUrl), FfiConverterOptionalStringINSTANCE.Lower(idpId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

func (_self *Client) SubscribeToIgnoredUsers(listener IgnoredUsersListener) *TaskHandle {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTaskHandleINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_ignored_users(
			_pointer, FfiConverterCallbackInterfaceIgnoredUsersListenerINSTANCE.Lower(listener), _uniffiStatus)
	}))
}

// Subscribe to changes in the media preview configuration.
func (_self *Client) SubscribeToMediaPreviewConfig(listener MediaPreviewConfigListener) (*TaskHandle, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *TaskHandle {
			return FfiConverterTaskHandleINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_media_preview_config(
			_pointer, FfiConverterCallbackInterfaceMediaPreviewConfigListenerINSTANCE.Lower(listener)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

// Subscribe to the global enablement status of the send queue, at the
// client-wide level.
//
// The given listener will be immediately called with the initial value of
// the enablement status.
func (_self *Client) SubscribeToSendQueueStatus(listener SendQueueRoomErrorListener) *TaskHandle {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTaskHandleINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_send_queue_status(
			_pointer, FfiConverterCallbackInterfaceSendQueueRoomErrorListenerINSTANCE.Lower(listener), _uniffiStatus)
	}))
}

func (_self *Client) SyncService() *SyncServiceBuilder {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSyncServiceBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_client_sync_service(
			_pointer, _uniffiStatus)
	}))
}

func (_self *Client) TrackRecentlyVisitedRoom(room string) error {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_track_recently_visited_room(
			_pointer, FfiConverterStringINSTANCE.Lower(room)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Client) UnignoreUser(userId string) error {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_unignore_user(
			_pointer, FfiConverterStringINSTANCE.Lower(userId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Client) UploadAvatar(mimeType string, data []byte) error {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_client_upload_avatar(
			_pointer, FfiConverterStringINSTANCE.Lower(mimeType), FfiConverterBytesINSTANCE.Lower(data)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Client) UploadMedia(mimeType string, data []byte, progressWatcher *ProgressWatcher) (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) string {
			return FfiConverterStringINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_upload_media(
			_pointer, FfiConverterStringINSTANCE.Lower(mimeType), FfiConverterBytesINSTANCE.Lower(data), FfiConverterOptionalCallbackInterfaceProgressWatcherINSTANCE.Lower(progressWatcher)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// Requests the URL needed for opening a web view using OIDC. Once the web
// view has succeeded, call `login_with_oidc_callback` with the callback it
// returns. If a failure occurs and a callback isn't available, make sure
// to call `abort_oidc_auth` to inform the client of this.
//
// # Arguments
//
// * `oidc_configuration` - The configuration used to load the credentials
// of the client if it is already registered with the authorization
// server, or register the client and store its credentials if it isn't.
//
// * `prompt` - The desired user experience in the web UI. No value means
// that the user wishes to login into an existing account, and a value of
// `Create` means that the user wishes to register a new account.
//
// * `login_hint` - A generic login hint that an identity provider can use
// to pre-fill the login form. The format of this hint is not restricted
// by the spec as external providers all have their own way to handle the hint.
// However, it should be noted that when providing a user ID as a hint
// for MAS (with no upstream provider), then the format to use is defined
// by [MSC4198]: https://github.com/matrix-org/matrix-spec-proposals/pull/4198
func (_self *Client) UrlForOidc(oidcConfiguration OidcConfiguration, prompt *OidcPrompt, loginHint *string) (*matrix_sdk.OAuthAuthorizationData, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[OidcError](
		FfiConverterOidcErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *matrix_sdk.OAuthAuthorizationData {
			return matrix_sdk.FfiConverterOAuthAuthorizationDataINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_client_url_for_oidc(
			_pointer, FfiConverterOidcConfigurationINSTANCE.Lower(oidcConfiguration), FfiConverterOptionalOidcPromptINSTANCE.Lower(prompt), FfiConverterOptionalStringINSTANCE.Lower(loginHint)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

func (_self *Client) UserId() (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[ClientError](FfiConverterClientError{}, func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_client_user_id(
				_pointer, _uniffiStatus),
		}
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue string
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterStringINSTANCE.Lift(_uniffiRV), nil
	}
}

// The server name part of the current user ID
func (_self *Client) UserIdServerName() (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Client")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[ClientError](FfiConverterClientError{}, func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_client_user_id_server_name(
				_pointer, _uniffiStatus),
		}
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue string
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterStringINSTANCE.Lift(_uniffiRV), nil
	}
}
func (object *Client) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterClient struct{}

var FfiConverterClientINSTANCE = FfiConverterClient{}

func (c FfiConverterClient) Lift(pointer unsafe.Pointer) *Client {
	result := &Client{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_client(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_client(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Client).Destroy)
	return result
}

func (c FfiConverterClient) Read(reader io.Reader) *Client {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterClient) Lower(value *Client) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Client")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterClient) Write(writer io.Writer, value *Client) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerClient struct{}

func (_ FfiDestroyerClient) Destroy(value *Client) {
	value.Destroy()
}

type ClientBuilderInterface interface {
	AddRootCertificates(certificates [][]byte) *ClientBuilder
	// Automatically create a backup version if no backup exists.
	AutoEnableBackups(autoEnableBackups bool) *ClientBuilder
	AutoEnableCrossSigning(autoEnableCrossSigning bool) *ClientBuilder
	// Select a strategy to download room keys from the backup. By default
	// we download after a decryption failure.
	//
	// Take a look at the [`BackupDownloadStrategy`] enum for more options.
	BackupDownloadStrategy(backupDownloadStrategy matrix_sdk.BackupDownloadStrategy) *ClientBuilder
	Build() (*Client, error)
	// Finish the building of the client and attempt to log in using the
	// provided [`QrCodeData`].
	//
	// This method will build the client and immediately attempt to log the
	// client in using the provided [`QrCodeData`] using the login
	// mechanism described in [MSC4108]. As such this methods requires OAuth
	// 2.0 support as well as sliding sync support.
	//
	// The usage of the progress_listener is required to transfer the
	// [`CheckCode`] to the existing client.
	//
	// [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
	BuildWithQrCode(qrCodeData *QrCodeData, oidcConfiguration OidcConfiguration, progressListener QrLoginProgressListener) (*Client, error)
	CrossProcessStoreLocksHolderName(holderName string) *ClientBuilder
	DisableAutomaticTokenRefresh() *ClientBuilder
	// Don't trust any system root certificates, only trust the certificates
	// provided through
	// [`add_root_certificates`][ClientBuilder::add_root_certificates].
	DisableBuiltInRootCertificates() *ClientBuilder
	DisableSslVerification() *ClientBuilder
	EnableOidcRefreshLock() *ClientBuilder
	HomeserverUrl(url string) *ClientBuilder
	Proxy(url string) *ClientBuilder
	// Add a default request config to this client.
	RequestConfig(config RequestConfig) *ClientBuilder
	// Set the trust requirement to be used when decrypting events.
	RoomDecryptionTrustRequirement(trustRequirement matrix_sdk_crypto.TrustRequirement) *ClientBuilder
	// Set the strategy to be used for picking recipient devices when sending
	// an encrypted message.
	RoomKeyRecipientStrategy(strategy matrix_sdk_crypto.CollectStrategy) *ClientBuilder
	ServerName(serverName string) *ClientBuilder
	ServerNameOrHomeserverUrl(serverNameOrUrl string) *ClientBuilder
	// Set the cache size for the SQLite stores given to
	// [`ClientBuilder::session_paths`].
	//
	// Each store exposes a SQLite connection. This method controls the cache
	// size, in **bytes (!)**.
	//
	// The cache represents data SQLite holds in memory at once per open
	// database file. The default cache implementation does not allocate the
	// full amount of cache memory all at once. Cache memory is allocated
	// in smaller chunks on an as-needed basis.
	//
	// See [`SqliteStoreConfig::cache_size`] to learn more.
	SessionCacheSize(cacheSize *uint32) *ClientBuilder
	// Set the size limit for the SQLite WAL files of stores given to
	// [`ClientBuilder::session_paths`].
	//
	// Each store uses the WAL journal mode. This method controls the size
	// limit of the WAL files, in **bytes (!)**.
	//
	// See [`SqliteStoreConfig::journal_size_limit`] to learn more.
	SessionJournalSizeLimit(limit *uint32) *ClientBuilder
	// Set the passphrase for the stores given to
	// [`ClientBuilder::session_paths`].
	SessionPassphrase(passphrase *string) *ClientBuilder
	// Sets the paths that the client will use to store its data and caches.
	// Both paths **must** be unique per session as the SDK stores aren't
	// capable of handling multiple users, however it is valid to use the
	// same path for both stores on a single session.
	//
	// Leaving this unset tells the client to use an in-memory data store.
	SessionPaths(dataPath string, cachePath string) *ClientBuilder
	// Set the pool max size for the SQLite stores given to
	// [`ClientBuilder::session_paths`].
	//
	// Each store exposes an async pool of connections. This method controls
	// the size of the pool. The larger the pool is, the more memory is
	// consumed, but also the more the app is reactive because it doesn't need
	// to wait on a pool to be available to run queries.
	//
	// See [`SqliteStoreConfig::pool_max_size`] to learn more.
	SessionPoolMaxSize(poolMaxSize *uint32) *ClientBuilder
	SetSessionDelegate(sessionDelegate ClientSessionDelegate) *ClientBuilder
	SlidingSyncVersionBuilder(versionBuilder SlidingSyncVersionBuilder) *ClientBuilder
	// Tell the client that the system is memory constrained, like in a push
	// notification process for example.
	//
	// So far, at the time of writing (2025-04-07), it changes the defaults of
	// [`SqliteStoreConfig`], so one might not need to call
	// [`ClientBuilder::session_cache_size`] and siblings for example. Please
	// check [`SqliteStoreConfig::with_low_memory_config`].
	SystemIsMemoryConstrained() *ClientBuilder
	UserAgent(userAgent string) *ClientBuilder
	Username(username string) *ClientBuilder
}
type ClientBuilder struct {
	ffiObject FfiObject
}

func NewClientBuilder() *ClientBuilder {
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_constructor_clientbuilder_new(_uniffiStatus)
	}))
}

func (_self *ClientBuilder) AddRootCertificates(certificates [][]byte) *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_add_root_certificates(
			_pointer, FfiConverterSequenceBytesINSTANCE.Lower(certificates), _uniffiStatus)
	}))
}

// Automatically create a backup version if no backup exists.
func (_self *ClientBuilder) AutoEnableBackups(autoEnableBackups bool) *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_auto_enable_backups(
			_pointer, FfiConverterBoolINSTANCE.Lower(autoEnableBackups), _uniffiStatus)
	}))
}

func (_self *ClientBuilder) AutoEnableCrossSigning(autoEnableCrossSigning bool) *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_auto_enable_cross_signing(
			_pointer, FfiConverterBoolINSTANCE.Lower(autoEnableCrossSigning), _uniffiStatus)
	}))
}

// Select a strategy to download room keys from the backup. By default
// we download after a decryption failure.
//
// Take a look at the [`BackupDownloadStrategy`] enum for more options.
func (_self *ClientBuilder) BackupDownloadStrategy(backupDownloadStrategy matrix_sdk.BackupDownloadStrategy) *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_backup_download_strategy(
			_pointer, RustBufferFromExternal(matrix_sdk.FfiConverterBackupDownloadStrategyINSTANCE.Lower(backupDownloadStrategy)), _uniffiStatus)
	}))
}

func (_self *ClientBuilder) Build() (*Client, error) {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientBuildError](
		FfiConverterClientBuildErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *Client {
			return FfiConverterClientINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_build(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

// Finish the building of the client and attempt to log in using the
// provided [`QrCodeData`].
//
// This method will build the client and immediately attempt to log the
// client in using the provided [`QrCodeData`] using the login
// mechanism described in [MSC4108]. As such this methods requires OAuth
// 2.0 support as well as sliding sync support.
//
// The usage of the progress_listener is required to transfer the
// [`CheckCode`] to the existing client.
//
// [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
func (_self *ClientBuilder) BuildWithQrCode(qrCodeData *QrCodeData, oidcConfiguration OidcConfiguration, progressListener QrLoginProgressListener) (*Client, error) {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[HumanQrLoginError](
		FfiConverterHumanQrLoginErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *Client {
			return FfiConverterClientINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_build_with_qr_code(
			_pointer, FfiConverterQrCodeDataINSTANCE.Lower(qrCodeData), FfiConverterOidcConfigurationINSTANCE.Lower(oidcConfiguration), FfiConverterCallbackInterfaceQrLoginProgressListenerINSTANCE.Lower(progressListener)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

func (_self *ClientBuilder) CrossProcessStoreLocksHolderName(holderName string) *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_cross_process_store_locks_holder_name(
			_pointer, FfiConverterStringINSTANCE.Lower(holderName), _uniffiStatus)
	}))
}

func (_self *ClientBuilder) DisableAutomaticTokenRefresh() *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_automatic_token_refresh(
			_pointer, _uniffiStatus)
	}))
}

// Don't trust any system root certificates, only trust the certificates
// provided through
// [`add_root_certificates`][ClientBuilder::add_root_certificates].
func (_self *ClientBuilder) DisableBuiltInRootCertificates() *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_built_in_root_certificates(
			_pointer, _uniffiStatus)
	}))
}

func (_self *ClientBuilder) DisableSslVerification() *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_ssl_verification(
			_pointer, _uniffiStatus)
	}))
}

func (_self *ClientBuilder) EnableOidcRefreshLock() *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_enable_oidc_refresh_lock(
			_pointer, _uniffiStatus)
	}))
}

func (_self *ClientBuilder) HomeserverUrl(url string) *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_homeserver_url(
			_pointer, FfiConverterStringINSTANCE.Lower(url), _uniffiStatus)
	}))
}

func (_self *ClientBuilder) Proxy(url string) *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_proxy(
			_pointer, FfiConverterStringINSTANCE.Lower(url), _uniffiStatus)
	}))
}

// Add a default request config to this client.
func (_self *ClientBuilder) RequestConfig(config RequestConfig) *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_request_config(
			_pointer, FfiConverterRequestConfigINSTANCE.Lower(config), _uniffiStatus)
	}))
}

// Set the trust requirement to be used when decrypting events.
func (_self *ClientBuilder) RoomDecryptionTrustRequirement(trustRequirement matrix_sdk_crypto.TrustRequirement) *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_room_decryption_trust_requirement(
			_pointer, RustBufferFromExternal(matrix_sdk_crypto.FfiConverterTrustRequirementINSTANCE.Lower(trustRequirement)), _uniffiStatus)
	}))
}

// Set the strategy to be used for picking recipient devices when sending
// an encrypted message.
func (_self *ClientBuilder) RoomKeyRecipientStrategy(strategy matrix_sdk_crypto.CollectStrategy) *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_room_key_recipient_strategy(
			_pointer, RustBufferFromExternal(matrix_sdk_crypto.FfiConverterCollectStrategyINSTANCE.Lower(strategy)), _uniffiStatus)
	}))
}

func (_self *ClientBuilder) ServerName(serverName string) *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name(
			_pointer, FfiConverterStringINSTANCE.Lower(serverName), _uniffiStatus)
	}))
}

func (_self *ClientBuilder) ServerNameOrHomeserverUrl(serverNameOrUrl string) *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name_or_homeserver_url(
			_pointer, FfiConverterStringINSTANCE.Lower(serverNameOrUrl), _uniffiStatus)
	}))
}

// Set the cache size for the SQLite stores given to
// [`ClientBuilder::session_paths`].
//
// Each store exposes a SQLite connection. This method controls the cache
// size, in **bytes (!)**.
//
// The cache represents data SQLite holds in memory at once per open
// database file. The default cache implementation does not allocate the
// full amount of cache memory all at once. Cache memory is allocated
// in smaller chunks on an as-needed basis.
//
// See [`SqliteStoreConfig::cache_size`] to learn more.
func (_self *ClientBuilder) SessionCacheSize(cacheSize *uint32) *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_cache_size(
			_pointer, FfiConverterOptionalUint32INSTANCE.Lower(cacheSize), _uniffiStatus)
	}))
}

// Set the size limit for the SQLite WAL files of stores given to
// [`ClientBuilder::session_paths`].
//
// Each store uses the WAL journal mode. This method controls the size
// limit of the WAL files, in **bytes (!)**.
//
// See [`SqliteStoreConfig::journal_size_limit`] to learn more.
func (_self *ClientBuilder) SessionJournalSizeLimit(limit *uint32) *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_journal_size_limit(
			_pointer, FfiConverterOptionalUint32INSTANCE.Lower(limit), _uniffiStatus)
	}))
}

// Set the passphrase for the stores given to
// [`ClientBuilder::session_paths`].
func (_self *ClientBuilder) SessionPassphrase(passphrase *string) *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_passphrase(
			_pointer, FfiConverterOptionalStringINSTANCE.Lower(passphrase), _uniffiStatus)
	}))
}

// Sets the paths that the client will use to store its data and caches.
// Both paths **must** be unique per session as the SDK stores aren't
// capable of handling multiple users, however it is valid to use the
// same path for both stores on a single session.
//
// Leaving this unset tells the client to use an in-memory data store.
func (_self *ClientBuilder) SessionPaths(dataPath string, cachePath string) *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_paths(
			_pointer, FfiConverterStringINSTANCE.Lower(dataPath), FfiConverterStringINSTANCE.Lower(cachePath), _uniffiStatus)
	}))
}

// Set the pool max size for the SQLite stores given to
// [`ClientBuilder::session_paths`].
//
// Each store exposes an async pool of connections. This method controls
// the size of the pool. The larger the pool is, the more memory is
// consumed, but also the more the app is reactive because it doesn't need
// to wait on a pool to be available to run queries.
//
// See [`SqliteStoreConfig::pool_max_size`] to learn more.
func (_self *ClientBuilder) SessionPoolMaxSize(poolMaxSize *uint32) *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_pool_max_size(
			_pointer, FfiConverterOptionalUint32INSTANCE.Lower(poolMaxSize), _uniffiStatus)
	}))
}

func (_self *ClientBuilder) SetSessionDelegate(sessionDelegate ClientSessionDelegate) *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_set_session_delegate(
			_pointer, FfiConverterCallbackInterfaceClientSessionDelegateINSTANCE.Lower(sessionDelegate), _uniffiStatus)
	}))
}

func (_self *ClientBuilder) SlidingSyncVersionBuilder(versionBuilder SlidingSyncVersionBuilder) *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_sliding_sync_version_builder(
			_pointer, FfiConverterSlidingSyncVersionBuilderINSTANCE.Lower(versionBuilder), _uniffiStatus)
	}))
}

// Tell the client that the system is memory constrained, like in a push
// notification process for example.
//
// So far, at the time of writing (2025-04-07), it changes the defaults of
// [`SqliteStoreConfig`], so one might not need to call
// [`ClientBuilder::session_cache_size`] and siblings for example. Please
// check [`SqliteStoreConfig::with_low_memory_config`].
func (_self *ClientBuilder) SystemIsMemoryConstrained() *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_system_is_memory_constrained(
			_pointer, _uniffiStatus)
	}))
}

func (_self *ClientBuilder) UserAgent(userAgent string) *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_user_agent(
			_pointer, FfiConverterStringINSTANCE.Lower(userAgent), _uniffiStatus)
	}))
}

func (_self *ClientBuilder) Username(username string) *ClientBuilder {
	_pointer := _self.ffiObject.incrementPointer("*ClientBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterClientBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_clientbuilder_username(
			_pointer, FfiConverterStringINSTANCE.Lower(username), _uniffiStatus)
	}))
}
func (object *ClientBuilder) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterClientBuilder struct{}

var FfiConverterClientBuilderINSTANCE = FfiConverterClientBuilder{}

func (c FfiConverterClientBuilder) Lift(pointer unsafe.Pointer) *ClientBuilder {
	result := &ClientBuilder{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_clientbuilder(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_clientbuilder(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ClientBuilder).Destroy)
	return result
}

func (c FfiConverterClientBuilder) Read(reader io.Reader) *ClientBuilder {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterClientBuilder) Lower(value *ClientBuilder) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ClientBuilder")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterClientBuilder) Write(writer io.Writer, value *ClientBuilder) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerClientBuilder struct{}

func (_ FfiDestroyerClientBuilder) Destroy(value *ClientBuilder) {
	value.Destroy()
}

type EncryptionInterface interface {
	// Does a backup exist on the server?
	//
	// Because the homeserver doesn't notify us about changes to the backup
	// version, the [`BackupState`] and its listener are a bit crippled.
	// The `BackupState::Unknown` state might mean there is no backup at all or
	// a backup exists but we don't have access to it.
	//
	// Therefore it is necessary to poll the server for an answer every time
	// you want to differentiate between those two states.
	BackupExistsOnServer() (bool, error)
	BackupState() BackupState
	BackupStateListener(listener BackupStateListener) *TaskHandle
	// Get the public curve25519 key of our own device in base64. This is
	// usually what is called the identity key of the device.
	Curve25519Key() *string
	DisableRecovery() error
	// Get the public ed25519 key of our own device. This is usually what is
	// called the fingerprint of the device.
	Ed25519Key() *string
	EnableBackups() error
	EnableRecovery(waitForBackupsToUpload bool, passphrase *string, progressListener EnableRecoveryProgressListener) (string, error)
	IsLastDevice() (bool, error)
	Recover(recoveryKey string) error
	RecoverAndReset(oldRecoveryKey string) (string, error)
	RecoveryState() RecoveryState
	RecoveryStateListener(listener RecoveryStateListener) *TaskHandle
	// Completely reset the current user's crypto identity: reset the cross
	// signing keys, delete the existing backup and recovery key.
	ResetIdentity() (**IdentityResetHandle, error)
	ResetRecoveryKey() (string, error)
	// Get the E2EE identity of a user.
	//
	// This method always tries to fetch the identity from the store, which we
	// only have if the user is tracked, meaning that we are both members
	// of the same encrypted room. If no user is found locally, a request will
	// be made to the homeserver.
	//
	// # Arguments
	//
	// * `user_id` - The ID of the user that the identity belongs to.
	//
	// Returns a `UserIdentity` if one is found. Returns an error if there
	// was an issue with the crypto store or with the request to the
	// homeserver.
	//
	// This will always return `None` if the client hasn't been logged in.
	UserIdentity(userId string) (**UserIdentity, error)
	VerificationState() VerificationState
	VerificationStateListener(listener VerificationStateListener) *TaskHandle
	WaitForBackupUploadSteadyState(progressListener *BackupSteadyStateListener) error
	// Waits for end-to-end encryption initialization tasks to finish, if any
	// was running in the background.
	WaitForE2eeInitializationTasks()
}
type Encryption struct {
	ffiObject FfiObject
}

// Does a backup exist on the server?
//
// Because the homeserver doesn't notify us about changes to the backup
// version, the [`BackupState`] and its listener are a bit crippled.
// The `BackupState::Unknown` state might mean there is no backup at all or
// a backup exists but we don't have access to it.
//
// Therefore it is necessary to poll the server for an answer every time
// you want to differentiate between those two states.
func (_self *Encryption) BackupExistsOnServer() (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*Encryption")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_encryption_backup_exists_on_server(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

func (_self *Encryption) BackupState() BackupState {
	_pointer := _self.ffiObject.incrementPointer("*Encryption")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBackupStateINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_encryption_backup_state(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *Encryption) BackupStateListener(listener BackupStateListener) *TaskHandle {
	_pointer := _self.ffiObject.incrementPointer("*Encryption")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTaskHandleINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_encryption_backup_state_listener(
			_pointer, FfiConverterCallbackInterfaceBackupStateListenerINSTANCE.Lower(listener), _uniffiStatus)
	}))
}

// Get the public curve25519 key of our own device in base64. This is
// usually what is called the identity key of the device.
func (_self *Encryption) Curve25519Key() *string {
	_pointer := _self.ffiObject.incrementPointer("*Encryption")
	defer _self.ffiObject.decrementPointer()
	res, _ := uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) *string {
			return FfiConverterOptionalStringINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_encryption_curve25519_key(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res
}

func (_self *Encryption) DisableRecovery() error {
	_pointer := _self.ffiObject.incrementPointer("*Encryption")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[RecoveryError](
		FfiConverterRecoveryErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_encryption_disable_recovery(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Get the public ed25519 key of our own device. This is usually what is
// called the fingerprint of the device.
func (_self *Encryption) Ed25519Key() *string {
	_pointer := _self.ffiObject.incrementPointer("*Encryption")
	defer _self.ffiObject.decrementPointer()
	res, _ := uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) *string {
			return FfiConverterOptionalStringINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_encryption_ed25519_key(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res
}

func (_self *Encryption) EnableBackups() error {
	_pointer := _self.ffiObject.incrementPointer("*Encryption")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[RecoveryError](
		FfiConverterRecoveryErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_encryption_enable_backups(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Encryption) EnableRecovery(waitForBackupsToUpload bool, passphrase *string, progressListener EnableRecoveryProgressListener) (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Encryption")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[RecoveryError](
		FfiConverterRecoveryErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) string {
			return FfiConverterStringINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_encryption_enable_recovery(
			_pointer, FfiConverterBoolINSTANCE.Lower(waitForBackupsToUpload), FfiConverterOptionalStringINSTANCE.Lower(passphrase), FfiConverterCallbackInterfaceEnableRecoveryProgressListenerINSTANCE.Lower(progressListener)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

func (_self *Encryption) IsLastDevice() (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*Encryption")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[RecoveryError](
		FfiConverterRecoveryErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_encryption_is_last_device(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

func (_self *Encryption) Recover(recoveryKey string) error {
	_pointer := _self.ffiObject.incrementPointer("*Encryption")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[RecoveryError](
		FfiConverterRecoveryErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_encryption_recover(
			_pointer, FfiConverterStringINSTANCE.Lower(recoveryKey)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Encryption) RecoverAndReset(oldRecoveryKey string) (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Encryption")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[RecoveryError](
		FfiConverterRecoveryErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) string {
			return FfiConverterStringINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_encryption_recover_and_reset(
			_pointer, FfiConverterStringINSTANCE.Lower(oldRecoveryKey)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

func (_self *Encryption) RecoveryState() RecoveryState {
	_pointer := _self.ffiObject.incrementPointer("*Encryption")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterRecoveryStateINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_encryption_recovery_state(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *Encryption) RecoveryStateListener(listener RecoveryStateListener) *TaskHandle {
	_pointer := _self.ffiObject.incrementPointer("*Encryption")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTaskHandleINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_encryption_recovery_state_listener(
			_pointer, FfiConverterCallbackInterfaceRecoveryStateListenerINSTANCE.Lower(listener), _uniffiStatus)
	}))
}

// Completely reset the current user's crypto identity: reset the cross
// signing keys, delete the existing backup and recovery key.
func (_self *Encryption) ResetIdentity() (**IdentityResetHandle, error) {
	_pointer := _self.ffiObject.incrementPointer("*Encryption")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) **IdentityResetHandle {
			return FfiConverterOptionalIdentityResetHandleINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_encryption_reset_identity(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

func (_self *Encryption) ResetRecoveryKey() (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Encryption")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[RecoveryError](
		FfiConverterRecoveryErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) string {
			return FfiConverterStringINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_encryption_reset_recovery_key(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// Get the E2EE identity of a user.
//
// This method always tries to fetch the identity from the store, which we
// only have if the user is tracked, meaning that we are both members
// of the same encrypted room. If no user is found locally, a request will
// be made to the homeserver.
//
// # Arguments
//
// * `user_id` - The ID of the user that the identity belongs to.
//
// Returns a `UserIdentity` if one is found. Returns an error if there
// was an issue with the crypto store or with the request to the
// homeserver.
//
// This will always return `None` if the client hasn't been logged in.
func (_self *Encryption) UserIdentity(userId string) (**UserIdentity, error) {
	_pointer := _self.ffiObject.incrementPointer("*Encryption")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) **UserIdentity {
			return FfiConverterOptionalUserIdentityINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_encryption_user_identity(
			_pointer, FfiConverterStringINSTANCE.Lower(userId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

func (_self *Encryption) VerificationState() VerificationState {
	_pointer := _self.ffiObject.incrementPointer("*Encryption")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterVerificationStateINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_encryption_verification_state(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *Encryption) VerificationStateListener(listener VerificationStateListener) *TaskHandle {
	_pointer := _self.ffiObject.incrementPointer("*Encryption")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTaskHandleINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_encryption_verification_state_listener(
			_pointer, FfiConverterCallbackInterfaceVerificationStateListenerINSTANCE.Lower(listener), _uniffiStatus)
	}))
}

func (_self *Encryption) WaitForBackupUploadSteadyState(progressListener *BackupSteadyStateListener) error {
	_pointer := _self.ffiObject.incrementPointer("*Encryption")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[SteadyStateError](
		FfiConverterSteadyStateErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_encryption_wait_for_backup_upload_steady_state(
			_pointer, FfiConverterOptionalCallbackInterfaceBackupSteadyStateListenerINSTANCE.Lower(progressListener)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Waits for end-to-end encryption initialization tasks to finish, if any
// was running in the background.
func (_self *Encryption) WaitForE2eeInitializationTasks() {
	_pointer := _self.ffiObject.incrementPointer("*Encryption")
	defer _self.ffiObject.decrementPointer()
	uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_encryption_wait_for_e2ee_initialization_tasks(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

}
func (object *Encryption) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterEncryption struct{}

var FfiConverterEncryptionINSTANCE = FfiConverterEncryption{}

func (c FfiConverterEncryption) Lift(pointer unsafe.Pointer) *Encryption {
	result := &Encryption{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_encryption(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_encryption(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Encryption).Destroy)
	return result
}

func (c FfiConverterEncryption) Read(reader io.Reader) *Encryption {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterEncryption) Lower(value *Encryption) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Encryption")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterEncryption) Write(writer io.Writer, value *Encryption) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerEncryption struct{}

func (_ FfiDestroyerEncryption) Destroy(value *Encryption) {
	value.Destroy()
}

type HomeserverLoginDetailsInterface interface {
	// The sliding sync version.
	SlidingSyncVersion() SlidingSyncVersion
	// The prompts advertised by the authentication issuer for use in the login
	// URL.
	SupportedOidcPrompts() []OidcPrompt
	// Whether the current homeserver supports login using OIDC.
	SupportsOidcLogin() bool
	// Whether the current homeserver supports the password login flow.
	SupportsPasswordLogin() bool
	// The URL of the currently configured homeserver.
	Url() string
}
type HomeserverLoginDetails struct {
	ffiObject FfiObject
}

// The sliding sync version.
func (_self *HomeserverLoginDetails) SlidingSyncVersion() SlidingSyncVersion {
	_pointer := _self.ffiObject.incrementPointer("*HomeserverLoginDetails")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSlidingSyncVersionINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_sliding_sync_version(
				_pointer, _uniffiStatus),
		}
	}))
}

// The prompts advertised by the authentication issuer for use in the login
// URL.
func (_self *HomeserverLoginDetails) SupportedOidcPrompts() []OidcPrompt {
	_pointer := _self.ffiObject.incrementPointer("*HomeserverLoginDetails")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceOidcPromptINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supported_oidc_prompts(
				_pointer, _uniffiStatus),
		}
	}))
}

// Whether the current homeserver supports login using OIDC.
func (_self *HomeserverLoginDetails) SupportsOidcLogin() bool {
	_pointer := _self.ffiObject.incrementPointer("*HomeserverLoginDetails")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_oidc_login(
			_pointer, _uniffiStatus)
	}))
}

// Whether the current homeserver supports the password login flow.
func (_self *HomeserverLoginDetails) SupportsPasswordLogin() bool {
	_pointer := _self.ffiObject.incrementPointer("*HomeserverLoginDetails")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_password_login(
			_pointer, _uniffiStatus)
	}))
}

// The URL of the currently configured homeserver.
func (_self *HomeserverLoginDetails) Url() string {
	_pointer := _self.ffiObject.incrementPointer("*HomeserverLoginDetails")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_url(
				_pointer, _uniffiStatus),
		}
	}))
}
func (object *HomeserverLoginDetails) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterHomeserverLoginDetails struct{}

var FfiConverterHomeserverLoginDetailsINSTANCE = FfiConverterHomeserverLoginDetails{}

func (c FfiConverterHomeserverLoginDetails) Lift(pointer unsafe.Pointer) *HomeserverLoginDetails {
	result := &HomeserverLoginDetails{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_homeserverlogindetails(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_homeserverlogindetails(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*HomeserverLoginDetails).Destroy)
	return result
}

func (c FfiConverterHomeserverLoginDetails) Read(reader io.Reader) *HomeserverLoginDetails {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterHomeserverLoginDetails) Lower(value *HomeserverLoginDetails) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*HomeserverLoginDetails")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterHomeserverLoginDetails) Write(writer io.Writer, value *HomeserverLoginDetails) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerHomeserverLoginDetails struct{}

func (_ FfiDestroyerHomeserverLoginDetails) Destroy(value *HomeserverLoginDetails) {
	value.Destroy()
}

type IdentityResetHandleInterface interface {
	// Get the underlying [`CrossSigningResetAuthType`] this identity reset
	// process is using.
	AuthType() CrossSigningResetAuthType
	Cancel()
	// This method starts the identity reset process and
	// will go through the following steps:
	//
	// 1. Disable backing up room keys and delete the active backup
	// 2. Disable recovery and delete secret storage
	// 3. Go through the cross-signing key reset flow
	// 4. Finally, re-enable key backups only if they were enabled before
	Reset(auth *AuthData) error
}
type IdentityResetHandle struct {
	ffiObject FfiObject
}

// Get the underlying [`CrossSigningResetAuthType`] this identity reset
// process is using.
func (_self *IdentityResetHandle) AuthType() CrossSigningResetAuthType {
	_pointer := _self.ffiObject.incrementPointer("*IdentityResetHandle")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterCrossSigningResetAuthTypeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_identityresethandle_auth_type(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *IdentityResetHandle) Cancel() {
	_pointer := _self.ffiObject.incrementPointer("*IdentityResetHandle")
	defer _self.ffiObject.decrementPointer()
	uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_identityresethandle_cancel(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

}

// This method starts the identity reset process and
// will go through the following steps:
//
// 1. Disable backing up room keys and delete the active backup
// 2. Disable recovery and delete secret storage
// 3. Go through the cross-signing key reset flow
// 4. Finally, re-enable key backups only if they were enabled before
func (_self *IdentityResetHandle) Reset(auth *AuthData) error {
	_pointer := _self.ffiObject.incrementPointer("*IdentityResetHandle")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_identityresethandle_reset(
			_pointer, FfiConverterOptionalAuthDataINSTANCE.Lower(auth)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}
func (object *IdentityResetHandle) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterIdentityResetHandle struct{}

var FfiConverterIdentityResetHandleINSTANCE = FfiConverterIdentityResetHandle{}

func (c FfiConverterIdentityResetHandle) Lift(pointer unsafe.Pointer) *IdentityResetHandle {
	result := &IdentityResetHandle{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_identityresethandle(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_identityresethandle(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*IdentityResetHandle).Destroy)
	return result
}

func (c FfiConverterIdentityResetHandle) Read(reader io.Reader) *IdentityResetHandle {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterIdentityResetHandle) Lower(value *IdentityResetHandle) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*IdentityResetHandle")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterIdentityResetHandle) Write(writer io.Writer, value *IdentityResetHandle) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerIdentityResetHandle struct{}

func (_ FfiDestroyerIdentityResetHandle) Destroy(value *IdentityResetHandle) {
	value.Destroy()
}

type InReplyToDetailsInterface interface {
	Event() RepliedToEventDetails
	EventId() string
}
type InReplyToDetails struct {
	ffiObject FfiObject
}

func (_self *InReplyToDetails) Event() RepliedToEventDetails {
	_pointer := _self.ffiObject.incrementPointer("*InReplyToDetails")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterRepliedToEventDetailsINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_inreplytodetails_event(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *InReplyToDetails) EventId() string {
	_pointer := _self.ffiObject.incrementPointer("*InReplyToDetails")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_inreplytodetails_event_id(
				_pointer, _uniffiStatus),
		}
	}))
}
func (object *InReplyToDetails) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterInReplyToDetails struct{}

var FfiConverterInReplyToDetailsINSTANCE = FfiConverterInReplyToDetails{}

func (c FfiConverterInReplyToDetails) Lift(pointer unsafe.Pointer) *InReplyToDetails {
	result := &InReplyToDetails{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_inreplytodetails(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_inreplytodetails(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*InReplyToDetails).Destroy)
	return result
}

func (c FfiConverterInReplyToDetails) Read(reader io.Reader) *InReplyToDetails {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterInReplyToDetails) Lower(value *InReplyToDetails) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*InReplyToDetails")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterInReplyToDetails) Write(writer io.Writer, value *InReplyToDetails) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerInReplyToDetails struct{}

func (_ FfiDestroyerInReplyToDetails) Destroy(value *InReplyToDetails) {
	value.Destroy()
}

// A set of actions to perform for a knock request.
type KnockRequestActionsInterface interface {
	// Accepts the knock request by inviting the user to the room.
	Accept() error
	// Declines the knock request by kicking the user from the room with an
	// optional reason.
	Decline(reason *string) error
	// Declines the knock request by banning the user from the room with an
	// optional reason.
	DeclineAndBan(reason *string) error
	// Marks the knock request as 'seen'.
	//
	// **IMPORTANT**: this won't update the current reference to this request,
	// a new one with the updated value should be emitted instead.
	MarkAsSeen() error
}

// A set of actions to perform for a knock request.
type KnockRequestActions struct {
	ffiObject FfiObject
}

// Accepts the knock request by inviting the user to the room.
func (_self *KnockRequestActions) Accept() error {
	_pointer := _self.ffiObject.incrementPointer("*KnockRequestActions")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_accept(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Declines the knock request by kicking the user from the room with an
// optional reason.
func (_self *KnockRequestActions) Decline(reason *string) error {
	_pointer := _self.ffiObject.incrementPointer("*KnockRequestActions")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_decline(
			_pointer, FfiConverterOptionalStringINSTANCE.Lower(reason)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Declines the knock request by banning the user from the room with an
// optional reason.
func (_self *KnockRequestActions) DeclineAndBan(reason *string) error {
	_pointer := _self.ffiObject.incrementPointer("*KnockRequestActions")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_decline_and_ban(
			_pointer, FfiConverterOptionalStringINSTANCE.Lower(reason)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Marks the knock request as 'seen'.
//
// **IMPORTANT**: this won't update the current reference to this request,
// a new one with the updated value should be emitted instead.
func (_self *KnockRequestActions) MarkAsSeen() error {
	_pointer := _self.ffiObject.incrementPointer("*KnockRequestActions")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_mark_as_seen(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}
func (object *KnockRequestActions) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterKnockRequestActions struct{}

var FfiConverterKnockRequestActionsINSTANCE = FfiConverterKnockRequestActions{}

func (c FfiConverterKnockRequestActions) Lift(pointer unsafe.Pointer) *KnockRequestActions {
	result := &KnockRequestActions{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_knockrequestactions(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_knockrequestactions(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*KnockRequestActions).Destroy)
	return result
}

func (c FfiConverterKnockRequestActions) Read(reader io.Reader) *KnockRequestActions {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterKnockRequestActions) Lower(value *KnockRequestActions) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*KnockRequestActions")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterKnockRequestActions) Write(writer io.Writer, value *KnockRequestActions) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerKnockRequestActions struct{}

func (_ FfiDestroyerKnockRequestActions) Destroy(value *KnockRequestActions) {
	value.Destroy()
}

// Wrapper to retrieve some timeline item info lazily.
type LazyTimelineItemProviderInterface interface {
	ContainsOnlyEmojis() bool
	// Returns some debug information for this event timeline item.
	DebugInfo() EventTimelineItemDebugInfo
	// For local echoes, return the associated send handle; returns `None` for
	// remote echoes.
	GetSendHandle() **SendHandle
	// Returns the shields for this event timeline item.
	GetShields(strict bool) *ShieldState
}

// Wrapper to retrieve some timeline item info lazily.
type LazyTimelineItemProvider struct {
	ffiObject FfiObject
}

func (_self *LazyTimelineItemProvider) ContainsOnlyEmojis() bool {
	_pointer := _self.ffiObject.incrementPointer("*LazyTimelineItemProvider")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_contains_only_emojis(
			_pointer, _uniffiStatus)
	}))
}

// Returns some debug information for this event timeline item.
func (_self *LazyTimelineItemProvider) DebugInfo() EventTimelineItemDebugInfo {
	_pointer := _self.ffiObject.incrementPointer("*LazyTimelineItemProvider")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterEventTimelineItemDebugInfoINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_debug_info(
				_pointer, _uniffiStatus),
		}
	}))
}

// For local echoes, return the associated send handle; returns `None` for
// remote echoes.
func (_self *LazyTimelineItemProvider) GetSendHandle() **SendHandle {
	_pointer := _self.ffiObject.incrementPointer("*LazyTimelineItemProvider")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalSendHandleINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_get_send_handle(
				_pointer, _uniffiStatus),
		}
	}))
}

// Returns the shields for this event timeline item.
func (_self *LazyTimelineItemProvider) GetShields(strict bool) *ShieldState {
	_pointer := _self.ffiObject.incrementPointer("*LazyTimelineItemProvider")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalShieldStateINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_get_shields(
				_pointer, FfiConverterBoolINSTANCE.Lower(strict), _uniffiStatus),
		}
	}))
}
func (object *LazyTimelineItemProvider) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterLazyTimelineItemProvider struct{}

var FfiConverterLazyTimelineItemProviderINSTANCE = FfiConverterLazyTimelineItemProvider{}

func (c FfiConverterLazyTimelineItemProvider) Lift(pointer unsafe.Pointer) *LazyTimelineItemProvider {
	result := &LazyTimelineItemProvider{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_lazytimelineitemprovider(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_lazytimelineitemprovider(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*LazyTimelineItemProvider).Destroy)
	return result
}

func (c FfiConverterLazyTimelineItemProvider) Read(reader io.Reader) *LazyTimelineItemProvider {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterLazyTimelineItemProvider) Lower(value *LazyTimelineItemProvider) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*LazyTimelineItemProvider")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterLazyTimelineItemProvider) Write(writer io.Writer, value *LazyTimelineItemProvider) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerLazyTimelineItemProvider struct{}

func (_ FfiDestroyerLazyTimelineItemProvider) Destroy(value *LazyTimelineItemProvider) {
	value.Destroy()
}

// A file handle that takes ownership of a media file on disk. When the handle
// is dropped, the file will be removed from the disk.
type MediaFileHandleInterface interface {
	// Get the media file's path.
	Path() (string, error)
	Persist(path string) (bool, error)
}

// A file handle that takes ownership of a media file on disk. When the handle
// is dropped, the file will be removed from the disk.
type MediaFileHandle struct {
	ffiObject FfiObject
}

// Get the media file's path.
func (_self *MediaFileHandle) Path() (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*MediaFileHandle")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[ClientError](FfiConverterClientError{}, func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_path(
				_pointer, _uniffiStatus),
		}
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue string
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterStringINSTANCE.Lift(_uniffiRV), nil
	}
}

func (_self *MediaFileHandle) Persist(path string) (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*MediaFileHandle")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[ClientError](FfiConverterClientError{}, func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_persist(
			_pointer, FfiConverterStringINSTANCE.Lower(path), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue bool
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterBoolINSTANCE.Lift(_uniffiRV), nil
	}
}
func (object *MediaFileHandle) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterMediaFileHandle struct{}

var FfiConverterMediaFileHandleINSTANCE = FfiConverterMediaFileHandle{}

func (c FfiConverterMediaFileHandle) Lift(pointer unsafe.Pointer) *MediaFileHandle {
	result := &MediaFileHandle{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_mediafilehandle(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_mediafilehandle(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*MediaFileHandle).Destroy)
	return result
}

func (c FfiConverterMediaFileHandle) Read(reader io.Reader) *MediaFileHandle {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterMediaFileHandle) Lower(value *MediaFileHandle) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*MediaFileHandle")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterMediaFileHandle) Write(writer io.Writer, value *MediaFileHandle) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerMediaFileHandle struct{}

func (_ FfiDestroyerMediaFileHandle) Destroy(value *MediaFileHandle) {
	value.Destroy()
}

type MediaSourceInterface interface {
	ToJson() string
	Url() string
}
type MediaSource struct {
	ffiObject FfiObject
}

func MediaSourceFromJson(json string) (*MediaSource, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[ClientError](FfiConverterClientError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_constructor_mediasource_from_json(FfiConverterStringINSTANCE.Lower(json), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *MediaSource
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterMediaSourceINSTANCE.Lift(_uniffiRV), nil
	}
}

func MediaSourceFromUrl(url string) (*MediaSource, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[ClientError](FfiConverterClientError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_constructor_mediasource_from_url(FfiConverterStringINSTANCE.Lower(url), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *MediaSource
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterMediaSourceINSTANCE.Lift(_uniffiRV), nil
	}
}

func (_self *MediaSource) ToJson() string {
	_pointer := _self.ffiObject.incrementPointer("*MediaSource")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_mediasource_to_json(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *MediaSource) Url() string {
	_pointer := _self.ffiObject.incrementPointer("*MediaSource")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_mediasource_url(
				_pointer, _uniffiStatus),
		}
	}))
}
func (object *MediaSource) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterMediaSource struct{}

var FfiConverterMediaSourceINSTANCE = FfiConverterMediaSource{}

func (c FfiConverterMediaSource) Lift(pointer unsafe.Pointer) *MediaSource {
	result := &MediaSource{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_mediasource(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_mediasource(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*MediaSource).Destroy)
	return result
}

func (c FfiConverterMediaSource) Read(reader io.Reader) *MediaSource {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterMediaSource) Lower(value *MediaSource) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*MediaSource")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterMediaSource) Write(writer io.Writer, value *MediaSource) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerMediaSource struct{}

func (_ FfiDestroyerMediaSource) Destroy(value *MediaSource) {
	value.Destroy()
}

type NotificationClientInterface interface {
	// See also documentation of
	// `MatrixNotificationClient::get_notification`.
	GetNotification(roomId string, eventId string) (*NotificationItem, error)
	// Get several notification items in a single batch.
	//
	// Returns an error if the flow failed when preparing to fetch the
	// notifications, and a [`HashMap`] containing either a
	// [`NotificationItem`] or no entry for it if it failed to fetch a
	// notification for the provided [`EventId`].
	GetNotifications(requests []NotificationItemsRequest) (map[string]NotificationItem, error)
	// Fetches a room by its ID using the in-memory state store backed client.
	//
	// Useful to retrieve room information after running the limited
	// notification client sliding sync loop.
	GetRoom(roomId string) (**Room, error)
}
type NotificationClient struct {
	ffiObject FfiObject
}

// See also documentation of
// `MatrixNotificationClient::get_notification`.
func (_self *NotificationClient) GetNotification(roomId string, eventId string) (*NotificationItem, error) {
	_pointer := _self.ffiObject.incrementPointer("*NotificationClient")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) *NotificationItem {
			return FfiConverterOptionalNotificationItemINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_notification(
			_pointer, FfiConverterStringINSTANCE.Lower(roomId), FfiConverterStringINSTANCE.Lower(eventId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// Get several notification items in a single batch.
//
// Returns an error if the flow failed when preparing to fetch the
// notifications, and a [`HashMap`] containing either a
// [`NotificationItem`] or no entry for it if it failed to fetch a
// notification for the provided [`EventId`].
func (_self *NotificationClient) GetNotifications(requests []NotificationItemsRequest) (map[string]NotificationItem, error) {
	_pointer := _self.ffiObject.incrementPointer("*NotificationClient")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) map[string]NotificationItem {
			return FfiConverterMapStringNotificationItemINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_notifications(
			_pointer, FfiConverterSequenceNotificationItemsRequestINSTANCE.Lower(requests)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// Fetches a room by its ID using the in-memory state store backed client.
//
// Useful to retrieve room information after running the limited
// notification client sliding sync loop.
func (_self *NotificationClient) GetRoom(roomId string) (**Room, error) {
	_pointer := _self.ffiObject.incrementPointer("*NotificationClient")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[ClientError](FfiConverterClientError{}, func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_room(
				_pointer, FfiConverterStringINSTANCE.Lower(roomId), _uniffiStatus),
		}
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue **Room
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterOptionalRoomINSTANCE.Lift(_uniffiRV), nil
	}
}
func (object *NotificationClient) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterNotificationClient struct{}

var FfiConverterNotificationClientINSTANCE = FfiConverterNotificationClient{}

func (c FfiConverterNotificationClient) Lift(pointer unsafe.Pointer) *NotificationClient {
	result := &NotificationClient{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_notificationclient(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_notificationclient(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*NotificationClient).Destroy)
	return result
}

func (c FfiConverterNotificationClient) Read(reader io.Reader) *NotificationClient {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterNotificationClient) Lower(value *NotificationClient) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*NotificationClient")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterNotificationClient) Write(writer io.Writer, value *NotificationClient) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerNotificationClient struct{}

func (_ FfiDestroyerNotificationClient) Destroy(value *NotificationClient) {
	value.Destroy()
}

type NotificationSettingsInterface interface {
	// Check whether [MSC 4028 push rule][rule] is enabled on the homeserver.
	//
	// [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
	CanHomeserverPushEncryptedEventToDevice() bool
	// Returns true if [MSC 4028 push rule][rule] is supported and enabled.
	//
	// [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
	CanPushEncryptedEventToDevice() bool
	// Get whether some enabled keyword rules exist.
	ContainsKeywordsRules() bool
	// Get the default room notification mode
	//
	// The mode will depend on the associated `PushRule` based on whether the
	// room is encrypted or not, and on the number of members.
	//
	// # Arguments
	//
	// * `is_encrypted` - whether the room is encrypted
	// * `is_one_to_one` - whether the room is a direct chats involving two
	// people
	GetDefaultRoomNotificationMode(isEncrypted bool, isOneToOne bool) RoomNotificationMode
	// Get the notification settings for a room.
	//
	// # Arguments
	//
	// * `room_id` - the room ID
	// * `is_encrypted` - whether the room is encrypted
	// * `is_one_to_one` - whether the room is a direct chat involving two
	// people
	GetRoomNotificationSettings(roomId string, isEncrypted bool, isOneToOne bool) (RoomNotificationSettings, error)
	// Get all room IDs for which a user-defined rule exists.
	GetRoomsWithUserDefinedRules(enabled *bool) []string
	// Get the user defined room notification mode
	GetUserDefinedRoomNotificationMode(roomId string) (*RoomNotificationMode, error)
	// Get whether the `.m.rule.call` push rule is enabled
	IsCallEnabled() (bool, error)
	// Get whether the `.m.rule.invite_for_me` push rule is enabled
	IsInviteForMeEnabled() (bool, error)
	// Get whether room mentions are enabled.
	IsRoomMentionEnabled() (bool, error)
	// Get whether user mentions are enabled.
	IsUserMentionEnabled() (bool, error)
	// Restore the default notification mode for a room
	RestoreDefaultRoomNotificationMode(roomId string) error
	// Set whether the `.m.rule.call` push rule is enabled
	SetCallEnabled(enabled bool) error
	// Sets a custom push rule with the given actions and conditions.
	SetCustomPushRule(ruleId string, ruleKind RuleKind, actions []Action, conditions []PushCondition) error
	// Set the default room notification mode
	//
	// # Arguments
	//
	// * `is_encrypted` - whether the mode is for encrypted rooms
	// * `is_one_to_one` - whether the mode is for direct chats involving two
	// people
	// * `mode` - the new default mode
	SetDefaultRoomNotificationMode(isEncrypted bool, isOneToOne bool, mode RoomNotificationMode) error
	SetDelegate(delegate *NotificationSettingsDelegate)
	// Set whether the `.m.rule.invite_for_me` push rule is enabled
	SetInviteForMeEnabled(enabled bool) error
	// Set whether room mentions are enabled.
	SetRoomMentionEnabled(enabled bool) error
	// Set the notification mode for a room.
	SetRoomNotificationMode(roomId string, mode RoomNotificationMode) error
	// Set whether user mentions are enabled.
	SetUserMentionEnabled(enabled bool) error
	// Unmute a room.
	//
	// # Arguments
	//
	// * `room_id` - the room to unmute
	// * `is_encrypted` - whether the room is encrypted
	// * `is_one_to_one` - whether the room is a direct chat involving two
	// people
	UnmuteRoom(roomId string, isEncrypted bool, isOneToOne bool) error
}
type NotificationSettings struct {
	ffiObject FfiObject
}

// Check whether [MSC 4028 push rule][rule] is enabled on the homeserver.
//
// [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
func (_self *NotificationSettings) CanHomeserverPushEncryptedEventToDevice() bool {
	_pointer := _self.ffiObject.incrementPointer("*NotificationSettings")
	defer _self.ffiObject.decrementPointer()
	res, _ := uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_can_homeserver_push_encrypted_event_to_device(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res
}

// Returns true if [MSC 4028 push rule][rule] is supported and enabled.
//
// [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
func (_self *NotificationSettings) CanPushEncryptedEventToDevice() bool {
	_pointer := _self.ffiObject.incrementPointer("*NotificationSettings")
	defer _self.ffiObject.decrementPointer()
	res, _ := uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_can_push_encrypted_event_to_device(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res
}

// Get whether some enabled keyword rules exist.
func (_self *NotificationSettings) ContainsKeywordsRules() bool {
	_pointer := _self.ffiObject.incrementPointer("*NotificationSettings")
	defer _self.ffiObject.decrementPointer()
	res, _ := uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_contains_keywords_rules(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res
}

// Get the default room notification mode
//
// The mode will depend on the associated `PushRule` based on whether the
// room is encrypted or not, and on the number of members.
//
// # Arguments
//
// * `is_encrypted` - whether the room is encrypted
// * `is_one_to_one` - whether the room is a direct chats involving two
// people
func (_self *NotificationSettings) GetDefaultRoomNotificationMode(isEncrypted bool, isOneToOne bool) RoomNotificationMode {
	_pointer := _self.ffiObject.incrementPointer("*NotificationSettings")
	defer _self.ffiObject.decrementPointer()
	res, _ := uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) RoomNotificationMode {
			return FfiConverterRoomNotificationModeINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_default_room_notification_mode(
			_pointer, FfiConverterBoolINSTANCE.Lower(isEncrypted), FfiConverterBoolINSTANCE.Lower(isOneToOne)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res
}

// Get the notification settings for a room.
//
// # Arguments
//
// * `room_id` - the room ID
// * `is_encrypted` - whether the room is encrypted
// * `is_one_to_one` - whether the room is a direct chat involving two
// people
func (_self *NotificationSettings) GetRoomNotificationSettings(roomId string, isEncrypted bool, isOneToOne bool) (RoomNotificationSettings, error) {
	_pointer := _self.ffiObject.incrementPointer("*NotificationSettings")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[NotificationSettingsError](
		FfiConverterNotificationSettingsErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) RoomNotificationSettings {
			return FfiConverterRoomNotificationSettingsINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_room_notification_settings(
			_pointer, FfiConverterStringINSTANCE.Lower(roomId), FfiConverterBoolINSTANCE.Lower(isEncrypted), FfiConverterBoolINSTANCE.Lower(isOneToOne)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// Get all room IDs for which a user-defined rule exists.
func (_self *NotificationSettings) GetRoomsWithUserDefinedRules(enabled *bool) []string {
	_pointer := _self.ffiObject.incrementPointer("*NotificationSettings")
	defer _self.ffiObject.decrementPointer()
	res, _ := uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) []string {
			return FfiConverterSequenceStringINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_rooms_with_user_defined_rules(
			_pointer, FfiConverterOptionalBoolINSTANCE.Lower(enabled)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res
}

// Get the user defined room notification mode
func (_self *NotificationSettings) GetUserDefinedRoomNotificationMode(roomId string) (*RoomNotificationMode, error) {
	_pointer := _self.ffiObject.incrementPointer("*NotificationSettings")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[NotificationSettingsError](
		FfiConverterNotificationSettingsErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) *RoomNotificationMode {
			return FfiConverterOptionalRoomNotificationModeINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_user_defined_room_notification_mode(
			_pointer, FfiConverterStringINSTANCE.Lower(roomId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// Get whether the `.m.rule.call` push rule is enabled
func (_self *NotificationSettings) IsCallEnabled() (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*NotificationSettings")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[NotificationSettingsError](
		FfiConverterNotificationSettingsErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_call_enabled(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

// Get whether the `.m.rule.invite_for_me` push rule is enabled
func (_self *NotificationSettings) IsInviteForMeEnabled() (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*NotificationSettings")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[NotificationSettingsError](
		FfiConverterNotificationSettingsErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_invite_for_me_enabled(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

// Get whether room mentions are enabled.
func (_self *NotificationSettings) IsRoomMentionEnabled() (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*NotificationSettings")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[NotificationSettingsError](
		FfiConverterNotificationSettingsErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_room_mention_enabled(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

// Get whether user mentions are enabled.
func (_self *NotificationSettings) IsUserMentionEnabled() (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*NotificationSettings")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[NotificationSettingsError](
		FfiConverterNotificationSettingsErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_user_mention_enabled(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

// Restore the default notification mode for a room
func (_self *NotificationSettings) RestoreDefaultRoomNotificationMode(roomId string) error {
	_pointer := _self.ffiObject.incrementPointer("*NotificationSettings")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[NotificationSettingsError](
		FfiConverterNotificationSettingsErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_restore_default_room_notification_mode(
			_pointer, FfiConverterStringINSTANCE.Lower(roomId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Set whether the `.m.rule.call` push rule is enabled
func (_self *NotificationSettings) SetCallEnabled(enabled bool) error {
	_pointer := _self.ffiObject.incrementPointer("*NotificationSettings")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[NotificationSettingsError](
		FfiConverterNotificationSettingsErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_call_enabled(
			_pointer, FfiConverterBoolINSTANCE.Lower(enabled)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Sets a custom push rule with the given actions and conditions.
func (_self *NotificationSettings) SetCustomPushRule(ruleId string, ruleKind RuleKind, actions []Action, conditions []PushCondition) error {
	_pointer := _self.ffiObject.incrementPointer("*NotificationSettings")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[NotificationSettingsError](
		FfiConverterNotificationSettingsErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_custom_push_rule(
			_pointer, FfiConverterStringINSTANCE.Lower(ruleId), FfiConverterRuleKindINSTANCE.Lower(ruleKind), FfiConverterSequenceActionINSTANCE.Lower(actions), FfiConverterSequencePushConditionINSTANCE.Lower(conditions)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Set the default room notification mode
//
// # Arguments
//
// * `is_encrypted` - whether the mode is for encrypted rooms
// * `is_one_to_one` - whether the mode is for direct chats involving two
// people
// * `mode` - the new default mode
func (_self *NotificationSettings) SetDefaultRoomNotificationMode(isEncrypted bool, isOneToOne bool, mode RoomNotificationMode) error {
	_pointer := _self.ffiObject.incrementPointer("*NotificationSettings")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[NotificationSettingsError](
		FfiConverterNotificationSettingsErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_default_room_notification_mode(
			_pointer, FfiConverterBoolINSTANCE.Lower(isEncrypted), FfiConverterBoolINSTANCE.Lower(isOneToOne), FfiConverterRoomNotificationModeINSTANCE.Lower(mode)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *NotificationSettings) SetDelegate(delegate *NotificationSettingsDelegate) {
	_pointer := _self.ffiObject.incrementPointer("*NotificationSettings")
	defer _self.ffiObject.decrementPointer()
	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_delegate(
			_pointer, FfiConverterOptionalCallbackInterfaceNotificationSettingsDelegateINSTANCE.Lower(delegate), _uniffiStatus)
		return false
	})
}

// Set whether the `.m.rule.invite_for_me` push rule is enabled
func (_self *NotificationSettings) SetInviteForMeEnabled(enabled bool) error {
	_pointer := _self.ffiObject.incrementPointer("*NotificationSettings")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[NotificationSettingsError](
		FfiConverterNotificationSettingsErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_invite_for_me_enabled(
			_pointer, FfiConverterBoolINSTANCE.Lower(enabled)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Set whether room mentions are enabled.
func (_self *NotificationSettings) SetRoomMentionEnabled(enabled bool) error {
	_pointer := _self.ffiObject.incrementPointer("*NotificationSettings")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[NotificationSettingsError](
		FfiConverterNotificationSettingsErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_mention_enabled(
			_pointer, FfiConverterBoolINSTANCE.Lower(enabled)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Set the notification mode for a room.
func (_self *NotificationSettings) SetRoomNotificationMode(roomId string, mode RoomNotificationMode) error {
	_pointer := _self.ffiObject.incrementPointer("*NotificationSettings")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[NotificationSettingsError](
		FfiConverterNotificationSettingsErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_notification_mode(
			_pointer, FfiConverterStringINSTANCE.Lower(roomId), FfiConverterRoomNotificationModeINSTANCE.Lower(mode)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Set whether user mentions are enabled.
func (_self *NotificationSettings) SetUserMentionEnabled(enabled bool) error {
	_pointer := _self.ffiObject.incrementPointer("*NotificationSettings")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[NotificationSettingsError](
		FfiConverterNotificationSettingsErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_user_mention_enabled(
			_pointer, FfiConverterBoolINSTANCE.Lower(enabled)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Unmute a room.
//
// # Arguments
//
// * `room_id` - the room to unmute
// * `is_encrypted` - whether the room is encrypted
// * `is_one_to_one` - whether the room is a direct chat involving two
// people
func (_self *NotificationSettings) UnmuteRoom(roomId string, isEncrypted bool, isOneToOne bool) error {
	_pointer := _self.ffiObject.incrementPointer("*NotificationSettings")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[NotificationSettingsError](
		FfiConverterNotificationSettingsErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_notificationsettings_unmute_room(
			_pointer, FfiConverterStringINSTANCE.Lower(roomId), FfiConverterBoolINSTANCE.Lower(isEncrypted), FfiConverterBoolINSTANCE.Lower(isOneToOne)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}
func (object *NotificationSettings) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterNotificationSettings struct{}

var FfiConverterNotificationSettingsINSTANCE = FfiConverterNotificationSettings{}

func (c FfiConverterNotificationSettings) Lift(pointer unsafe.Pointer) *NotificationSettings {
	result := &NotificationSettings{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_notificationsettings(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_notificationsettings(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*NotificationSettings).Destroy)
	return result
}

func (c FfiConverterNotificationSettings) Read(reader io.Reader) *NotificationSettings {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterNotificationSettings) Lower(value *NotificationSettings) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*NotificationSettings")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterNotificationSettings) Write(writer io.Writer, value *NotificationSettings) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerNotificationSettings struct{}

func (_ FfiDestroyerNotificationSettings) Destroy(value *NotificationSettings) {
	value.Destroy()
}

// Data for the QR code login mechanism.
//
// The [`QrCodeData`] can be serialized and encoded as a QR code or it can be
// decoded from a QR code.
type QrCodeDataInterface interface {
	// The server name contained within the scanned QR code data.
	//
	// Note: This value is only present when scanning a QR code the belongs to
	// a logged in client. The mode where the new client shows the QR code
	// will return `None`.
	ServerName() *string
}

// Data for the QR code login mechanism.
//
// The [`QrCodeData`] can be serialized and encoded as a QR code or it can be
// decoded from a QR code.
type QrCodeData struct {
	ffiObject FfiObject
}

// Attempt to decode a slice of bytes into a [`QrCodeData`] object.
//
// The slice of bytes would generally be returned by a QR code decoder.
func QrCodeDataFromBytes(bytes []byte) (*QrCodeData, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[QrCodeDecodeError](FfiConverterQrCodeDecodeError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_constructor_qrcodedata_from_bytes(FfiConverterBytesINSTANCE.Lower(bytes), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *QrCodeData
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterQrCodeDataINSTANCE.Lift(_uniffiRV), nil
	}
}

// The server name contained within the scanned QR code data.
//
// Note: This value is only present when scanning a QR code the belongs to
// a logged in client. The mode where the new client shows the QR code
// will return `None`.
func (_self *QrCodeData) ServerName() *string {
	_pointer := _self.ffiObject.incrementPointer("*QrCodeData")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_qrcodedata_server_name(
				_pointer, _uniffiStatus),
		}
	}))
}
func (object *QrCodeData) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterQrCodeData struct{}

var FfiConverterQrCodeDataINSTANCE = FfiConverterQrCodeData{}

func (c FfiConverterQrCodeData) Lift(pointer unsafe.Pointer) *QrCodeData {
	result := &QrCodeData{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_qrcodedata(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_qrcodedata(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*QrCodeData).Destroy)
	return result
}

func (c FfiConverterQrCodeData) Read(reader io.Reader) *QrCodeData {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterQrCodeData) Lower(value *QrCodeData) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*QrCodeData")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterQrCodeData) Write(writer io.Writer, value *QrCodeData) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerQrCodeData struct{}

func (_ FfiDestroyerQrCodeData) Destroy(value *QrCodeData) {
	value.Destroy()
}

type RoomInterface interface {
	ActiveMembersCount() uint64
	// Returns a Vec of userId's that participate in the room call.
	//
	// MatrixRTC memberships with application "m.call" and scope "m.room" are
	// considered. A user can occur twice if they join with two devices.
	// convert to a set depending if the different users are required or the
	// amount of sessions.
	//
	// The vector is ordered by oldest membership user to newest.
	ActiveRoomCallParticipants() []string
	AlternativeAliases() []string
	ApplyPowerLevelChanges(changes matrix_sdk.RoomPowerLevelChanges) error
	AvatarUrl() *string
	BanUser(userId string, reason *string) error
	CanUserBan(userId string) (bool, error)
	CanUserInvite(userId string) (bool, error)
	CanUserKick(userId string) (bool, error)
	CanUserPinUnpin(userId string) (bool, error)
	CanUserRedactOther(userId string) (bool, error)
	CanUserRedactOwn(userId string) (bool, error)
	CanUserSendMessage(userId string, message MessageLikeEventType) (bool, error)
	CanUserSendState(userId string, stateEvent StateEventType) (bool, error)
	CanUserTriggerRoomNotification(userId string) (bool, error)
	CanonicalAlias() *string
	// Remove the `ComposerDraft` stored in the state store for this room.
	ClearComposerDraft() error
	// Clear the event cache storage for the current room.
	//
	// This will remove all the information related to the event cache, in
	// memory and in the persisted storage, if enabled.
	ClearEventCacheStorage() error
	// Forces the currently active room key, which is used to encrypt messages,
	// to be rotated.
	//
	// A new room key will be crated and shared with all the room members the
	// next time a message will be sent. You don't have to call this method,
	// room keys will be rotated automatically when necessary. This method is
	// still useful for debugging purposes.
	DiscardRoomKey() error
	// Returns the room's name from the state event if available, otherwise
	// compute a room name based on the room's nature (DM or not) and number of
	// members.
	DisplayName() *string
	// Edit an event given its event id.
	//
	// Useful outside the context of a timeline, or when a timeline doesn't
	// have the full content of an event.
	Edit(eventId string, newContent *RoomMessageEventContentWithoutRelation) error
	// Enable End-to-end encryption in this room.
	EnableEncryption() error
	// Enable or disable the send queue for that particular room.
	EnableSendQueue(enable bool)
	EncryptionState() matrix_sdk_base.EncryptionState
	// Forget this room.
	//
	// This communicates to the homeserver that it should forget the room.
	//
	// Only left or banned-from rooms can be forgotten.
	Forget() error
	GetPowerLevels() (RoomPowerLevels, error)
	// Returns the visibility for this room in the room directory.
	//
	// [Public](`RoomVisibility::Public`) rooms are listed in the room
	// directory and can be found using it.
	GetRoomVisibility() (RoomVisibility, error)
	// Is there a non expired membership with application "m.call" and scope
	// "m.room" in this room.
	HasActiveRoomCall() bool
	// Returns the room heroes for this room.
	Heroes() []RoomHero
	Id() string
	// Set the local trust for the given devices to `LocalTrust::Ignored`
	// and resend messages that failed to send because said devices are
	// unverified (in response to
	// `SessionRecipientCollectionError::VerifiedUserHasUnsignedDevice`).
	// # Arguments
	//
	// * `devices` - The map of users identifiers to device identifiers
	// received in the error
	// * `transaction_id` - The send queue transaction identifier of the local
	// echo the send error applies to
	IgnoreDeviceTrustAndResend(devices map[string][]string, sendHandle *SendHandle) error
	// Ignores a user.
	//
	// # Arguments
	//
	// * `user_id` - The ID of the user to ignore.
	IgnoreUser(userId string) error
	InviteUserById(userId string) error
	InvitedMembersCount() uint64
	IsDirect() bool
	// Checks whether the room is encrypted or not.
	//
	// **Note**: this info may not be reliable if you don't set up
	// `m.room.encryption` as required state.
	IsEncrypted() bool
	IsPublic() bool
	// Returns whether the send queue for that particular room is enabled or
	// not.
	IsSendQueueEnabled() bool
	IsSpace() bool
	IsTombstoned() bool
	// Join this room.
	//
	// Only invited and left rooms can be joined via this method.
	Join() error
	JoinedMembersCount() uint64
	KickUser(userId string, reason *string) error
	LatestEncryptionState() (matrix_sdk_base.EncryptionState, error)
	LatestEvent() *EventTimelineItem
	// Leave this room.
	//
	// Only invited and joined rooms can be left.
	Leave() error
	// Retrieve the `ComposerDraft` stored in the state store for this room.
	LoadComposerDraft() (*ComposerDraft, error)
	// Mark a room as read, by attaching a read receipt on the latest event.
	//
	// Note: this does NOT unset the unread flag; it's the caller's
	// responsibility to do so, if need be.
	MarkAsRead(receiptType ReceiptType) error
	MatrixToEventPermalink(eventId string) (string, error)
	MatrixToPermalink() (string, error)
	Member(userId string) (RoomMember, error)
	MemberAvatarUrl(userId string) (*string, error)
	MemberDisplayName(userId string) (*string, error)
	// Get the membership details for the current user.
	//
	// Returns:
	// - If the user was present in the room, a
	// [`matrix_sdk::room::RoomMemberWithSenderInfo`] containing both the
	// user info and the member info of the sender of the `m.room.member`
	// event.
	// - If the current user is not present, an error.
	MemberWithSenderInfo(userId string) (RoomMemberWithSenderInfo, error)
	Members() (*RoomMembersIterator, error)
	MembersNoSync() (*RoomMembersIterator, error)
	// The room's current membership state.
	Membership() Membership
	OwnUserId() string
	// Builds a `RoomPreview` from a room list item. This is intended for
	// invited, knocked or banned rooms.
	PreviewRoom(via []string) (*RoomPreview, error)
	// Publish a new room alias for this room in the room directory.
	//
	// Returns:
	// - `true` if the room alias didn't exist and it's now published.
	// - `false` if the room alias was already present so it couldn't be
	// published.
	PublishRoomAliasInRoomDirectory(alias string) (bool, error)
	// The raw name as present in the room state event.
	RawName() *string
	// Redacts an event from the room.
	//
	// # Arguments
	//
	// * `event_id` - The ID of the event to redact
	//
	// * `reason` - The reason for the event being redacted (optional). its
	// transaction ID (optional). If not given one is created.
	Redact(eventId string, reason *string) error
	// Removes the current room avatar
	RemoveAvatar() error
	// Remove an existing room alias for this room in the room directory.
	//
	// Returns:
	// - `true` if the room alias was present and it's now removed from the
	// room directory.
	// - `false` if the room alias didn't exist so it couldn't be removed.
	RemoveRoomAliasFromRoomDirectory(alias string) (bool, error)
	// Reports an event from the room.
	//
	// # Arguments
	//
	// * `event_id` - The ID of the event to report
	//
	// * `reason` - The reason for the event being reported (optional).
	//
	// * `score` - The score to rate this content as where -100 is most
	// offensive and 0 is inoffensive (optional).
	ReportContent(eventId string, score *int32, reason *string) error
	// Reports a room as inappropriate to the server.
	// The caller is not required to be joined to the room to report it.
	//
	// # Arguments
	//
	// * `reason` - The reason the room is being reported.
	//
	// # Errors
	//
	// Returns an error if the room is not found or on rate limit
	ReportRoom(reason *string) error
	ResetPowerLevels() (RoomPowerLevels, error)
	// Return a debug representation for the internal room events data
	// structure, one line per entry in the resulting vector.
	RoomEventsDebugString() ([]string, error)
	RoomInfo() (RoomInfo, error)
	// Store the given `ComposerDraft` in the state store using the current
	// room id, as identifier.
	SaveComposerDraft(draft ComposerDraft) error
	// Send a call notification event in the current room.
	//
	// This is only supposed to be used in **custom** situations where the user
	// explicitly chooses to send a `m.call.notify` event to invite/notify
	// someone explicitly in unusual conditions. The default should be to
	// use `send_call_notification_if_necessary` just before a new room call is
	// created/joined.
	//
	// One example could be that the UI allows to start a call with a subset of
	// users of the room members first. And then later on the user can
	// invite more users to the call.
	SendCallNotification(callId string, application RtcApplicationType, notifyType NotifyType, mentions Mentions) error
	// This will only send a call notification event if appropriate.
	//
	// This function is supposed to be called whenever the user creates a room
	// call. It will send a `m.call.notify` event if:
	// - there is not yet a running call.
	//
	// It will configure the notify type: ring or notify based on:
	// - is this a DM room -> ring
	// - is this a group with more than one other member -> notify
	SendCallNotificationIfNeeded() error
	// Send the current users live location beacon in the room.
	SendLiveLocation(geoUri string) error
	// Send a raw event to the room.
	//
	// # Arguments
	//
	// * `event_type` - The type of the event to send.
	//
	// * `content` - The content of the event to send encoded as JSON string.
	SendRaw(eventType string, content string) error
	SetIsFavourite(isFavourite bool, tagOrder *float64) error
	SetIsLowPriority(isLowPriority bool, tagOrder *float64) error
	// Sets a new name to the room.
	SetName(name string) error
	// Sets a new topic in the room.
	SetTopic(topic string) error
	// Set (or unset) a flag on the room to indicate that the user has
	// explicitly marked it as unread.
	SetUnreadFlag(newValue bool) error
	// Start the current users live location share in the room.
	StartLiveLocationShare(durationMillis uint64) error
	// Stop the current users live location share in the room.
	StopLiveLocationShare() error
	SubscribeToIdentityStatusChanges(listener IdentityStatusChangeListener) (*TaskHandle, error)
	// Subscribes to requests to join this room (knock member events), using a
	// `listener` to be notified of the changes.
	//
	// The current requests to join the room will be emitted immediately
	// when subscribing, along with a [`TaskHandle`] to cancel the
	// subscription.
	SubscribeToKnockRequests(listener KnockRequestsListener) (*TaskHandle, error)
	// Subscribes to live location shares in this room, using a `listener` to
	// be notified of the changes.
	//
	// The current live location shares will be emitted immediately when
	// subscribing, along with a [`TaskHandle`] to cancel the subscription.
	SubscribeToLiveLocationShares(listener LiveLocationShareListener) *TaskHandle
	SubscribeToRoomInfoUpdates(listener RoomInfoListener) *TaskHandle
	SubscribeToTypingNotifications(listener TypingNotificationsListener) *TaskHandle
	SuggestedRoleForUser(userId string) (matrix_sdk.RoomMemberRole, error)
	// Create a timeline with a default configuration, i.e. a live timeline
	// with read receipts and read marker tracking.
	Timeline() (*Timeline, error)
	// Build a new timeline instance with the given configuration.
	TimelineWithConfiguration(configuration TimelineConfiguration) (*Timeline, error)
	Topic() *string
	TypingNotice(isTyping bool) error
	UnbanUser(userId string, reason *string) error
	// Update the canonical alias of the room.
	//
	// Note that publishing the alias in the room directory is done separately.
	UpdateCanonicalAlias(alias *string, altAliases []string) error
	// Update room history visibility for this room.
	UpdateHistoryVisibility(visibility RoomHistoryVisibility) error
	// Update the join rule for this room.
	UpdateJoinRules(newRule JoinRule) error
	UpdatePowerLevelsForUsers(updates []UserPowerLevelUpdate) error
	// Update the room's visibility in the room directory.
	UpdateRoomVisibility(visibility RoomVisibility) error
	// Upload and set the room's avatar.
	//
	// This will upload the data produced by the reader to the homeserver's
	// content repository, and set the room's avatar to the MXC URI for the
	// uploaded file.
	//
	// # Arguments
	//
	// * `mime_type` - The mime description of the avatar, for example
	// image/jpeg
	// * `data` - The raw data that will be uploaded to the homeserver's
	// content repository
	// * `media_info` - The media info used as avatar image info.
	UploadAvatar(mimeType string, data []byte, mediaInfo *ImageInfo) error
	// Remove verification requirements for the given users and
	// resend messages that failed to send because their identities were no
	// longer verified (in response to
	// `SessionRecipientCollectionError::VerifiedUserChangedIdentity`)
	//
	// # Arguments
	//
	// * `user_ids` - The list of users identifiers received in the error
	// * `transaction_id` - The send queue transaction identifier of the local
	// echo the send error applies to
	WithdrawVerificationAndResend(userIds []string, sendHandle *SendHandle) error
}
type Room struct {
	ffiObject FfiObject
}

func (_self *Room) ActiveMembersCount() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_room_active_members_count(
			_pointer, _uniffiStatus)
	}))
}

// Returns a Vec of userId's that participate in the room call.
//
// MatrixRTC memberships with application "m.call" and scope "m.room" are
// considered. A user can occur twice if they join with two devices.
// convert to a set depending if the different users are required or the
// amount of sessions.
//
// The vector is ordered by oldest membership user to newest.
func (_self *Room) ActiveRoomCallParticipants() []string {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_room_active_room_call_participants(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *Room) AlternativeAliases() []string {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_room_alternative_aliases(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *Room) ApplyPowerLevelChanges(changes matrix_sdk.RoomPowerLevelChanges) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_apply_power_level_changes(
			_pointer, RustBufferFromExternal(matrix_sdk.FfiConverterRoomPowerLevelChangesINSTANCE.Lower(changes))),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Room) AvatarUrl() *string {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_room_avatar_url(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *Room) BanUser(userId string, reason *string) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_ban_user(
			_pointer, FfiConverterStringINSTANCE.Lower(userId), FfiConverterOptionalStringINSTANCE.Lower(reason)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Room) CanUserBan(userId string) (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_can_user_ban(
			_pointer, FfiConverterStringINSTANCE.Lower(userId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

func (_self *Room) CanUserInvite(userId string) (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_can_user_invite(
			_pointer, FfiConverterStringINSTANCE.Lower(userId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

func (_self *Room) CanUserKick(userId string) (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_can_user_kick(
			_pointer, FfiConverterStringINSTANCE.Lower(userId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

func (_self *Room) CanUserPinUnpin(userId string) (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_can_user_pin_unpin(
			_pointer, FfiConverterStringINSTANCE.Lower(userId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

func (_self *Room) CanUserRedactOther(userId string) (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_can_user_redact_other(
			_pointer, FfiConverterStringINSTANCE.Lower(userId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

func (_self *Room) CanUserRedactOwn(userId string) (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_can_user_redact_own(
			_pointer, FfiConverterStringINSTANCE.Lower(userId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

func (_self *Room) CanUserSendMessage(userId string, message MessageLikeEventType) (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_can_user_send_message(
			_pointer, FfiConverterStringINSTANCE.Lower(userId), FfiConverterMessageLikeEventTypeINSTANCE.Lower(message)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

func (_self *Room) CanUserSendState(userId string, stateEvent StateEventType) (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_can_user_send_state(
			_pointer, FfiConverterStringINSTANCE.Lower(userId), FfiConverterStateEventTypeINSTANCE.Lower(stateEvent)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

func (_self *Room) CanUserTriggerRoomNotification(userId string) (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_can_user_trigger_room_notification(
			_pointer, FfiConverterStringINSTANCE.Lower(userId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

func (_self *Room) CanonicalAlias() *string {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_room_canonical_alias(
				_pointer, _uniffiStatus),
		}
	}))
}

// Remove the `ComposerDraft` stored in the state store for this room.
func (_self *Room) ClearComposerDraft() error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_clear_composer_draft(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Clear the event cache storage for the current room.
//
// This will remove all the information related to the event cache, in
// memory and in the persisted storage, if enabled.
func (_self *Room) ClearEventCacheStorage() error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_clear_event_cache_storage(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Forces the currently active room key, which is used to encrypt messages,
// to be rotated.
//
// A new room key will be crated and shared with all the room members the
// next time a message will be sent. You don't have to call this method,
// room keys will be rotated automatically when necessary. This method is
// still useful for debugging purposes.
func (_self *Room) DiscardRoomKey() error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_discard_room_key(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Returns the room's name from the state event if available, otherwise
// compute a room name based on the room's nature (DM or not) and number of
// members.
func (_self *Room) DisplayName() *string {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_room_display_name(
				_pointer, _uniffiStatus),
		}
	}))
}

// Edit an event given its event id.
//
// Useful outside the context of a timeline, or when a timeline doesn't
// have the full content of an event.
func (_self *Room) Edit(eventId string, newContent *RoomMessageEventContentWithoutRelation) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_edit(
			_pointer, FfiConverterStringINSTANCE.Lower(eventId), FfiConverterRoomMessageEventContentWithoutRelationINSTANCE.Lower(newContent)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Enable End-to-end encryption in this room.
func (_self *Room) EnableEncryption() error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_enable_encryption(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Enable or disable the send queue for that particular room.
func (_self *Room) EnableSendQueue(enable bool) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_matrix_sdk_ffi_fn_method_room_enable_send_queue(
			_pointer, FfiConverterBoolINSTANCE.Lower(enable), _uniffiStatus)
		return false
	})
}

func (_self *Room) EncryptionState() matrix_sdk_base.EncryptionState {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	return matrix_sdk_base.FfiConverterEncryptionStateINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_room_encryption_state(
				_pointer, _uniffiStatus),
		}
	}))
}

// Forget this room.
//
// This communicates to the homeserver that it should forget the room.
//
// Only left or banned-from rooms can be forgotten.
func (_self *Room) Forget() error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_forget(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Room) GetPowerLevels() (RoomPowerLevels, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) RoomPowerLevels {
			return FfiConverterRoomPowerLevelsINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_get_power_levels(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// Returns the visibility for this room in the room directory.
//
// [Public](`RoomVisibility::Public`) rooms are listed in the room
// directory and can be found using it.
func (_self *Room) GetRoomVisibility() (RoomVisibility, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) RoomVisibility {
			return FfiConverterRoomVisibilityINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_get_room_visibility(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// Is there a non expired membership with application "m.call" and scope
// "m.room" in this room.
func (_self *Room) HasActiveRoomCall() bool {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_room_has_active_room_call(
			_pointer, _uniffiStatus)
	}))
}

// Returns the room heroes for this room.
func (_self *Room) Heroes() []RoomHero {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSequenceRoomHeroINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_room_heroes(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *Room) Id() string {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_room_id(
				_pointer, _uniffiStatus),
		}
	}))
}

// Set the local trust for the given devices to `LocalTrust::Ignored`
// and resend messages that failed to send because said devices are
// unverified (in response to
// `SessionRecipientCollectionError::VerifiedUserHasUnsignedDevice`).
// # Arguments
//
// * `devices` - The map of users identifiers to device identifiers
// received in the error
// * `transaction_id` - The send queue transaction identifier of the local
// echo the send error applies to
func (_self *Room) IgnoreDeviceTrustAndResend(devices map[string][]string, sendHandle *SendHandle) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_ignore_device_trust_and_resend(
			_pointer, FfiConverterMapStringSequenceStringINSTANCE.Lower(devices), FfiConverterSendHandleINSTANCE.Lower(sendHandle)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Ignores a user.
//
// # Arguments
//
// * `user_id` - The ID of the user to ignore.
func (_self *Room) IgnoreUser(userId string) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_ignore_user(
			_pointer, FfiConverterStringINSTANCE.Lower(userId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Room) InviteUserById(userId string) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_invite_user_by_id(
			_pointer, FfiConverterStringINSTANCE.Lower(userId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Room) InvitedMembersCount() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_room_invited_members_count(
			_pointer, _uniffiStatus)
	}))
}

func (_self *Room) IsDirect() bool {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, _ := uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_is_direct(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res
}

// Checks whether the room is encrypted or not.
//
// **Note**: this info may not be reliable if you don't set up
// `m.room.encryption` as required state.
func (_self *Room) IsEncrypted() bool {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, _ := uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_is_encrypted(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res
}

func (_self *Room) IsPublic() bool {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_room_is_public(
			_pointer, _uniffiStatus)
	}))
}

// Returns whether the send queue for that particular room is enabled or
// not.
func (_self *Room) IsSendQueueEnabled() bool {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_room_is_send_queue_enabled(
			_pointer, _uniffiStatus)
	}))
}

func (_self *Room) IsSpace() bool {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_room_is_space(
			_pointer, _uniffiStatus)
	}))
}

func (_self *Room) IsTombstoned() bool {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_room_is_tombstoned(
			_pointer, _uniffiStatus)
	}))
}

// Join this room.
//
// Only invited and left rooms can be joined via this method.
func (_self *Room) Join() error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_join(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Room) JoinedMembersCount() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_room_joined_members_count(
			_pointer, _uniffiStatus)
	}))
}

func (_self *Room) KickUser(userId string, reason *string) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_kick_user(
			_pointer, FfiConverterStringINSTANCE.Lower(userId), FfiConverterOptionalStringINSTANCE.Lower(reason)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Room) LatestEncryptionState() (matrix_sdk_base.EncryptionState, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) matrix_sdk_base.EncryptionState {
			return matrix_sdk_base.FfiConverterEncryptionStateINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_latest_encryption_state(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

func (_self *Room) LatestEvent() *EventTimelineItem {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, _ := uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) *EventTimelineItem {
			return FfiConverterOptionalEventTimelineItemINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_latest_event(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res
}

// Leave this room.
//
// Only invited and joined rooms can be left.
func (_self *Room) Leave() error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_leave(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Retrieve the `ComposerDraft` stored in the state store for this room.
func (_self *Room) LoadComposerDraft() (*ComposerDraft, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) *ComposerDraft {
			return FfiConverterOptionalComposerDraftINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_load_composer_draft(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// Mark a room as read, by attaching a read receipt on the latest event.
//
// Note: this does NOT unset the unread flag; it's the caller's
// responsibility to do so, if need be.
func (_self *Room) MarkAsRead(receiptType ReceiptType) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_mark_as_read(
			_pointer, FfiConverterReceiptTypeINSTANCE.Lower(receiptType)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Room) MatrixToEventPermalink(eventId string) (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) string {
			return FfiConverterStringINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_matrix_to_event_permalink(
			_pointer, FfiConverterStringINSTANCE.Lower(eventId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

func (_self *Room) MatrixToPermalink() (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) string {
			return FfiConverterStringINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_matrix_to_permalink(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

func (_self *Room) Member(userId string) (RoomMember, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) RoomMember {
			return FfiConverterRoomMemberINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_member(
			_pointer, FfiConverterStringINSTANCE.Lower(userId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

func (_self *Room) MemberAvatarUrl(userId string) (*string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) *string {
			return FfiConverterOptionalStringINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_member_avatar_url(
			_pointer, FfiConverterStringINSTANCE.Lower(userId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

func (_self *Room) MemberDisplayName(userId string) (*string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) *string {
			return FfiConverterOptionalStringINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_member_display_name(
			_pointer, FfiConverterStringINSTANCE.Lower(userId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// Get the membership details for the current user.
//
// Returns:
// - If the user was present in the room, a
// [`matrix_sdk::room::RoomMemberWithSenderInfo`] containing both the
// user info and the member info of the sender of the `m.room.member`
// event.
// - If the current user is not present, an error.
func (_self *Room) MemberWithSenderInfo(userId string) (RoomMemberWithSenderInfo, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) RoomMemberWithSenderInfo {
			return FfiConverterRoomMemberWithSenderInfoINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_member_with_sender_info(
			_pointer, FfiConverterStringINSTANCE.Lower(userId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

func (_self *Room) Members() (*RoomMembersIterator, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *RoomMembersIterator {
			return FfiConverterRoomMembersIteratorINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_members(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

func (_self *Room) MembersNoSync() (*RoomMembersIterator, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *RoomMembersIterator {
			return FfiConverterRoomMembersIteratorINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_members_no_sync(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

// The room's current membership state.
func (_self *Room) Membership() Membership {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterMembershipINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_room_membership(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *Room) OwnUserId() string {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_room_own_user_id(
				_pointer, _uniffiStatus),
		}
	}))
}

// Builds a `RoomPreview` from a room list item. This is intended for
// invited, knocked or banned rooms.
func (_self *Room) PreviewRoom(via []string) (*RoomPreview, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *RoomPreview {
			return FfiConverterRoomPreviewINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_preview_room(
			_pointer, FfiConverterSequenceStringINSTANCE.Lower(via)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

// Publish a new room alias for this room in the room directory.
//
// Returns:
// - `true` if the room alias didn't exist and it's now published.
// - `false` if the room alias was already present so it couldn't be
// published.
func (_self *Room) PublishRoomAliasInRoomDirectory(alias string) (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_publish_room_alias_in_room_directory(
			_pointer, FfiConverterStringINSTANCE.Lower(alias)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

// The raw name as present in the room state event.
func (_self *Room) RawName() *string {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_room_raw_name(
				_pointer, _uniffiStatus),
		}
	}))
}

// Redacts an event from the room.
//
// # Arguments
//
// * `event_id` - The ID of the event to redact
//
// * `reason` - The reason for the event being redacted (optional). its
// transaction ID (optional). If not given one is created.
func (_self *Room) Redact(eventId string, reason *string) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_redact(
			_pointer, FfiConverterStringINSTANCE.Lower(eventId), FfiConverterOptionalStringINSTANCE.Lower(reason)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Removes the current room avatar
func (_self *Room) RemoveAvatar() error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_remove_avatar(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Remove an existing room alias for this room in the room directory.
//
// Returns:
// - `true` if the room alias was present and it's now removed from the
// room directory.
// - `false` if the room alias didn't exist so it couldn't be removed.
func (_self *Room) RemoveRoomAliasFromRoomDirectory(alias string) (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_remove_room_alias_from_room_directory(
			_pointer, FfiConverterStringINSTANCE.Lower(alias)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

// Reports an event from the room.
//
// # Arguments
//
// * `event_id` - The ID of the event to report
//
// * `reason` - The reason for the event being reported (optional).
//
// * `score` - The score to rate this content as where -100 is most
// offensive and 0 is inoffensive (optional).
func (_self *Room) ReportContent(eventId string, score *int32, reason *string) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_report_content(
			_pointer, FfiConverterStringINSTANCE.Lower(eventId), FfiConverterOptionalInt32INSTANCE.Lower(score), FfiConverterOptionalStringINSTANCE.Lower(reason)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Reports a room as inappropriate to the server.
// The caller is not required to be joined to the room to report it.
//
// # Arguments
//
// * `reason` - The reason the room is being reported.
//
// # Errors
//
// Returns an error if the room is not found or on rate limit
func (_self *Room) ReportRoom(reason *string) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_report_room(
			_pointer, FfiConverterOptionalStringINSTANCE.Lower(reason)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Room) ResetPowerLevels() (RoomPowerLevels, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) RoomPowerLevels {
			return FfiConverterRoomPowerLevelsINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_reset_power_levels(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// Return a debug representation for the internal room events data
// structure, one line per entry in the resulting vector.
func (_self *Room) RoomEventsDebugString() ([]string, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) []string {
			return FfiConverterSequenceStringINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_room_events_debug_string(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

func (_self *Room) RoomInfo() (RoomInfo, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) RoomInfo {
			return FfiConverterRoomInfoINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_room_info(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// Store the given `ComposerDraft` in the state store using the current
// room id, as identifier.
func (_self *Room) SaveComposerDraft(draft ComposerDraft) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_save_composer_draft(
			_pointer, FfiConverterComposerDraftINSTANCE.Lower(draft)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Send a call notification event in the current room.
//
// This is only supposed to be used in **custom** situations where the user
// explicitly chooses to send a `m.call.notify` event to invite/notify
// someone explicitly in unusual conditions. The default should be to
// use `send_call_notification_if_necessary` just before a new room call is
// created/joined.
//
// One example could be that the UI allows to start a call with a subset of
// users of the room members first. And then later on the user can
// invite more users to the call.
func (_self *Room) SendCallNotification(callId string, application RtcApplicationType, notifyType NotifyType, mentions Mentions) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_send_call_notification(
			_pointer, FfiConverterStringINSTANCE.Lower(callId), FfiConverterRtcApplicationTypeINSTANCE.Lower(application), FfiConverterNotifyTypeINSTANCE.Lower(notifyType), FfiConverterMentionsINSTANCE.Lower(mentions)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// This will only send a call notification event if appropriate.
//
// This function is supposed to be called whenever the user creates a room
// call. It will send a `m.call.notify` event if:
// - there is not yet a running call.
//
// It will configure the notify type: ring or notify based on:
// - is this a DM room -> ring
// - is this a group with more than one other member -> notify
func (_self *Room) SendCallNotificationIfNeeded() error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_send_call_notification_if_needed(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Send the current users live location beacon in the room.
func (_self *Room) SendLiveLocation(geoUri string) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_send_live_location(
			_pointer, FfiConverterStringINSTANCE.Lower(geoUri)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Send a raw event to the room.
//
// # Arguments
//
// * `event_type` - The type of the event to send.
//
// * `content` - The content of the event to send encoded as JSON string.
func (_self *Room) SendRaw(eventType string, content string) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_send_raw(
			_pointer, FfiConverterStringINSTANCE.Lower(eventType), FfiConverterStringINSTANCE.Lower(content)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Room) SetIsFavourite(isFavourite bool, tagOrder *float64) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_set_is_favourite(
			_pointer, FfiConverterBoolINSTANCE.Lower(isFavourite), FfiConverterOptionalFloat64INSTANCE.Lower(tagOrder)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Room) SetIsLowPriority(isLowPriority bool, tagOrder *float64) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_set_is_low_priority(
			_pointer, FfiConverterBoolINSTANCE.Lower(isLowPriority), FfiConverterOptionalFloat64INSTANCE.Lower(tagOrder)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Sets a new name to the room.
func (_self *Room) SetName(name string) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_set_name(
			_pointer, FfiConverterStringINSTANCE.Lower(name)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Sets a new topic in the room.
func (_self *Room) SetTopic(topic string) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_set_topic(
			_pointer, FfiConverterStringINSTANCE.Lower(topic)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Set (or unset) a flag on the room to indicate that the user has
// explicitly marked it as unread.
func (_self *Room) SetUnreadFlag(newValue bool) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_set_unread_flag(
			_pointer, FfiConverterBoolINSTANCE.Lower(newValue)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Start the current users live location share in the room.
func (_self *Room) StartLiveLocationShare(durationMillis uint64) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_start_live_location_share(
			_pointer, FfiConverterUint64INSTANCE.Lower(durationMillis)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Stop the current users live location share in the room.
func (_self *Room) StopLiveLocationShare() error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_stop_live_location_share(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Room) SubscribeToIdentityStatusChanges(listener IdentityStatusChangeListener) (*TaskHandle, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *TaskHandle {
			return FfiConverterTaskHandleINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_identity_status_changes(
			_pointer, FfiConverterCallbackInterfaceIdentityStatusChangeListenerINSTANCE.Lower(listener)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

// Subscribes to requests to join this room (knock member events), using a
// `listener` to be notified of the changes.
//
// The current requests to join the room will be emitted immediately
// when subscribing, along with a [`TaskHandle`] to cancel the
// subscription.
func (_self *Room) SubscribeToKnockRequests(listener KnockRequestsListener) (*TaskHandle, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *TaskHandle {
			return FfiConverterTaskHandleINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_knock_requests(
			_pointer, FfiConverterCallbackInterfaceKnockRequestsListenerINSTANCE.Lower(listener)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

// Subscribes to live location shares in this room, using a `listener` to
// be notified of the changes.
//
// The current live location shares will be emitted immediately when
// subscribing, along with a [`TaskHandle`] to cancel the subscription.
func (_self *Room) SubscribeToLiveLocationShares(listener LiveLocationShareListener) *TaskHandle {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTaskHandleINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_live_location_shares(
			_pointer, FfiConverterCallbackInterfaceLiveLocationShareListenerINSTANCE.Lower(listener), _uniffiStatus)
	}))
}

func (_self *Room) SubscribeToRoomInfoUpdates(listener RoomInfoListener) *TaskHandle {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTaskHandleINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_room_info_updates(
			_pointer, FfiConverterCallbackInterfaceRoomInfoListenerINSTANCE.Lower(listener), _uniffiStatus)
	}))
}

func (_self *Room) SubscribeToTypingNotifications(listener TypingNotificationsListener) *TaskHandle {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTaskHandleINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_typing_notifications(
			_pointer, FfiConverterCallbackInterfaceTypingNotificationsListenerINSTANCE.Lower(listener), _uniffiStatus)
	}))
}

func (_self *Room) SuggestedRoleForUser(userId string) (matrix_sdk.RoomMemberRole, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) matrix_sdk.RoomMemberRole {
			return matrix_sdk.FfiConverterRoomMemberRoleINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_suggested_role_for_user(
			_pointer, FfiConverterStringINSTANCE.Lower(userId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// Create a timeline with a default configuration, i.e. a live timeline
// with read receipts and read marker tracking.
func (_self *Room) Timeline() (*Timeline, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *Timeline {
			return FfiConverterTimelineINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_timeline(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

// Build a new timeline instance with the given configuration.
func (_self *Room) TimelineWithConfiguration(configuration TimelineConfiguration) (*Timeline, error) {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *Timeline {
			return FfiConverterTimelineINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_room_timeline_with_configuration(
			_pointer, FfiConverterTimelineConfigurationINSTANCE.Lower(configuration)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

func (_self *Room) Topic() *string {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_room_topic(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *Room) TypingNotice(isTyping bool) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_typing_notice(
			_pointer, FfiConverterBoolINSTANCE.Lower(isTyping)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Room) UnbanUser(userId string, reason *string) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_unban_user(
			_pointer, FfiConverterStringINSTANCE.Lower(userId), FfiConverterOptionalStringINSTANCE.Lower(reason)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Update the canonical alias of the room.
//
// Note that publishing the alias in the room directory is done separately.
func (_self *Room) UpdateCanonicalAlias(alias *string, altAliases []string) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_update_canonical_alias(
			_pointer, FfiConverterOptionalStringINSTANCE.Lower(alias), FfiConverterSequenceStringINSTANCE.Lower(altAliases)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Update room history visibility for this room.
func (_self *Room) UpdateHistoryVisibility(visibility RoomHistoryVisibility) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_update_history_visibility(
			_pointer, FfiConverterRoomHistoryVisibilityINSTANCE.Lower(visibility)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Update the join rule for this room.
func (_self *Room) UpdateJoinRules(newRule JoinRule) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_update_join_rules(
			_pointer, FfiConverterJoinRuleINSTANCE.Lower(newRule)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Room) UpdatePowerLevelsForUsers(updates []UserPowerLevelUpdate) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_update_power_levels_for_users(
			_pointer, FfiConverterSequenceUserPowerLevelUpdateINSTANCE.Lower(updates)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Update the room's visibility in the room directory.
func (_self *Room) UpdateRoomVisibility(visibility RoomVisibility) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_update_room_visibility(
			_pointer, FfiConverterRoomVisibilityINSTANCE.Lower(visibility)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Upload and set the room's avatar.
//
// This will upload the data produced by the reader to the homeserver's
// content repository, and set the room's avatar to the MXC URI for the
// uploaded file.
//
// # Arguments
//
// * `mime_type` - The mime description of the avatar, for example
// image/jpeg
// * `data` - The raw data that will be uploaded to the homeserver's
// content repository
// * `media_info` - The media info used as avatar image info.
func (_self *Room) UploadAvatar(mimeType string, data []byte, mediaInfo *ImageInfo) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_upload_avatar(
			_pointer, FfiConverterStringINSTANCE.Lower(mimeType), FfiConverterBytesINSTANCE.Lower(data), FfiConverterOptionalImageInfoINSTANCE.Lower(mediaInfo)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Remove verification requirements for the given users and
// resend messages that failed to send because their identities were no
// longer verified (in response to
// `SessionRecipientCollectionError::VerifiedUserChangedIdentity`)
//
// # Arguments
//
// * `user_ids` - The list of users identifiers received in the error
// * `transaction_id` - The send queue transaction identifier of the local
// echo the send error applies to
func (_self *Room) WithdrawVerificationAndResend(userIds []string, sendHandle *SendHandle) error {
	_pointer := _self.ffiObject.incrementPointer("*Room")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_room_withdraw_verification_and_resend(
			_pointer, FfiConverterSequenceStringINSTANCE.Lower(userIds), FfiConverterSendHandleINSTANCE.Lower(sendHandle)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}
func (object *Room) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterRoom struct{}

var FfiConverterRoomINSTANCE = FfiConverterRoom{}

func (c FfiConverterRoom) Lift(pointer unsafe.Pointer) *Room {
	result := &Room{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_room(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_room(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Room).Destroy)
	return result
}

func (c FfiConverterRoom) Read(reader io.Reader) *Room {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterRoom) Lower(value *Room) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Room")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterRoom) Write(writer io.Writer, value *Room) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerRoom struct{}

func (_ FfiDestroyerRoom) Destroy(value *Room) {
	value.Destroy()
}

// A helper for performing room searches in the room directory.
// The way this is intended to be used is:
//
// 1. Register a callback using [`RoomDirectorySearch::results`].
// 2. Start the room search with [`RoomDirectorySearch::search`].
// 3. To get more results, use [`RoomDirectorySearch::next_page`].
type RoomDirectorySearchInterface interface {
	// Get whether the search is at the last page.
	IsAtLastPage() (bool, error)
	// Get the number of pages that have been loaded so far.
	LoadedPages() (uint32, error)
	// Asks the server for the next page of the current search.
	NextPage() error
	// Registers a callback to receive new search results when starting a
	// search or getting new paginated results.
	Results(listener RoomDirectorySearchEntriesListener) *TaskHandle
	// Starts a filtered search for the server.
	//
	// If the `filter` is not provided it will search for all the rooms.
	// You can specify a `batch_size` to control the number of rooms to fetch
	// per request.
	//
	// If the `via_server` is not provided it will search in the current
	// homeserver by default.
	//
	// This method will clear the current search results and start a new one.
	Search(filter *string, batchSize uint32, viaServerName *string) error
}

// A helper for performing room searches in the room directory.
// The way this is intended to be used is:
//
// 1. Register a callback using [`RoomDirectorySearch::results`].
// 2. Start the room search with [`RoomDirectorySearch::search`].
// 3. To get more results, use [`RoomDirectorySearch::next_page`].
type RoomDirectorySearch struct {
	ffiObject FfiObject
}

// Get whether the search is at the last page.
func (_self *RoomDirectorySearch) IsAtLastPage() (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*RoomDirectorySearch")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_is_at_last_page(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

// Get the number of pages that have been loaded so far.
func (_self *RoomDirectorySearch) LoadedPages() (uint32, error) {
	_pointer := _self.ffiObject.incrementPointer("*RoomDirectorySearch")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.uint32_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_u32(handle, status)
			return res
		},
		// liftFn
		func(ffi C.uint32_t) uint32 {
			return FfiConverterUint32INSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_loaded_pages(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_u32(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_u32(handle)
		},
	)

	return res, err
}

// Asks the server for the next page of the current search.
func (_self *RoomDirectorySearch) NextPage() error {
	_pointer := _self.ffiObject.incrementPointer("*RoomDirectorySearch")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_next_page(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Registers a callback to receive new search results when starting a
// search or getting new paginated results.
func (_self *RoomDirectorySearch) Results(listener RoomDirectorySearchEntriesListener) *TaskHandle {
	_pointer := _self.ffiObject.incrementPointer("*RoomDirectorySearch")
	defer _self.ffiObject.decrementPointer()
	res, _ := uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *TaskHandle {
			return FfiConverterTaskHandleINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_results(
			_pointer, FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListenerINSTANCE.Lower(listener)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res
}

// Starts a filtered search for the server.
//
// If the `filter` is not provided it will search for all the rooms.
// You can specify a `batch_size` to control the number of rooms to fetch
// per request.
//
// If the `via_server` is not provided it will search in the current
// homeserver by default.
//
// This method will clear the current search results and start a new one.
func (_self *RoomDirectorySearch) Search(filter *string, batchSize uint32, viaServerName *string) error {
	_pointer := _self.ffiObject.incrementPointer("*RoomDirectorySearch")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_search(
			_pointer, FfiConverterOptionalStringINSTANCE.Lower(filter), FfiConverterUint32INSTANCE.Lower(batchSize), FfiConverterOptionalStringINSTANCE.Lower(viaServerName)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}
func (object *RoomDirectorySearch) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterRoomDirectorySearch struct{}

var FfiConverterRoomDirectorySearchINSTANCE = FfiConverterRoomDirectorySearch{}

func (c FfiConverterRoomDirectorySearch) Lift(pointer unsafe.Pointer) *RoomDirectorySearch {
	result := &RoomDirectorySearch{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_roomdirectorysearch(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_roomdirectorysearch(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*RoomDirectorySearch).Destroy)
	return result
}

func (c FfiConverterRoomDirectorySearch) Read(reader io.Reader) *RoomDirectorySearch {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterRoomDirectorySearch) Lower(value *RoomDirectorySearch) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*RoomDirectorySearch")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterRoomDirectorySearch) Write(writer io.Writer, value *RoomDirectorySearch) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerRoomDirectorySearch struct{}

func (_ FfiDestroyerRoomDirectorySearch) Destroy(value *RoomDirectorySearch) {
	value.Destroy()
}

type RoomListInterface interface {
	EntriesWithDynamicAdapters(pageSize uint32, listener RoomListEntriesListener) *RoomListEntriesWithDynamicAdaptersResult
	LoadingState(listener RoomListLoadingStateListener) (RoomListLoadingStateResult, error)
	Room(roomId string) (*Room, error)
}
type RoomList struct {
	ffiObject FfiObject
}

func (_self *RoomList) EntriesWithDynamicAdapters(pageSize uint32, listener RoomListEntriesListener) *RoomListEntriesWithDynamicAdaptersResult {
	_pointer := _self.ffiObject.incrementPointer("*RoomList")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterRoomListEntriesWithDynamicAdaptersResultINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_roomlist_entries_with_dynamic_adapters(
			_pointer, FfiConverterUint32INSTANCE.Lower(pageSize), FfiConverterCallbackInterfaceRoomListEntriesListenerINSTANCE.Lower(listener), _uniffiStatus)
	}))
}

func (_self *RoomList) LoadingState(listener RoomListLoadingStateListener) (RoomListLoadingStateResult, error) {
	_pointer := _self.ffiObject.incrementPointer("*RoomList")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[RoomListError](FfiConverterRoomListError{}, func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_roomlist_loading_state(
				_pointer, FfiConverterCallbackInterfaceRoomListLoadingStateListenerINSTANCE.Lower(listener), _uniffiStatus),
		}
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue RoomListLoadingStateResult
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterRoomListLoadingStateResultINSTANCE.Lift(_uniffiRV), nil
	}
}

func (_self *RoomList) Room(roomId string) (*Room, error) {
	_pointer := _self.ffiObject.incrementPointer("*RoomList")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[RoomListError](FfiConverterRoomListError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_roomlist_room(
			_pointer, FfiConverterStringINSTANCE.Lower(roomId), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *Room
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterRoomINSTANCE.Lift(_uniffiRV), nil
	}
}
func (object *RoomList) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterRoomList struct{}

var FfiConverterRoomListINSTANCE = FfiConverterRoomList{}

func (c FfiConverterRoomList) Lift(pointer unsafe.Pointer) *RoomList {
	result := &RoomList{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_roomlist(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_roomlist(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*RoomList).Destroy)
	return result
}

func (c FfiConverterRoomList) Read(reader io.Reader) *RoomList {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterRoomList) Lower(value *RoomList) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*RoomList")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterRoomList) Write(writer io.Writer, value *RoomList) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerRoomList struct{}

func (_ FfiDestroyerRoomList) Destroy(value *RoomList) {
	value.Destroy()
}

type RoomListDynamicEntriesControllerInterface interface {
	AddOnePage()
	ResetToOnePage()
	SetFilter(kind RoomListEntriesDynamicFilterKind) bool
}
type RoomListDynamicEntriesController struct {
	ffiObject FfiObject
}

func (_self *RoomListDynamicEntriesController) AddOnePage() {
	_pointer := _self.ffiObject.incrementPointer("*RoomListDynamicEntriesController")
	defer _self.ffiObject.decrementPointer()
	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_add_one_page(
			_pointer, _uniffiStatus)
		return false
	})
}

func (_self *RoomListDynamicEntriesController) ResetToOnePage() {
	_pointer := _self.ffiObject.incrementPointer("*RoomListDynamicEntriesController")
	defer _self.ffiObject.decrementPointer()
	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_reset_to_one_page(
			_pointer, _uniffiStatus)
		return false
	})
}

func (_self *RoomListDynamicEntriesController) SetFilter(kind RoomListEntriesDynamicFilterKind) bool {
	_pointer := _self.ffiObject.incrementPointer("*RoomListDynamicEntriesController")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_set_filter(
			_pointer, FfiConverterRoomListEntriesDynamicFilterKindINSTANCE.Lower(kind), _uniffiStatus)
	}))
}
func (object *RoomListDynamicEntriesController) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterRoomListDynamicEntriesController struct{}

var FfiConverterRoomListDynamicEntriesControllerINSTANCE = FfiConverterRoomListDynamicEntriesController{}

func (c FfiConverterRoomListDynamicEntriesController) Lift(pointer unsafe.Pointer) *RoomListDynamicEntriesController {
	result := &RoomListDynamicEntriesController{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_roomlistdynamicentriescontroller(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_roomlistdynamicentriescontroller(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*RoomListDynamicEntriesController).Destroy)
	return result
}

func (c FfiConverterRoomListDynamicEntriesController) Read(reader io.Reader) *RoomListDynamicEntriesController {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterRoomListDynamicEntriesController) Lower(value *RoomListDynamicEntriesController) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*RoomListDynamicEntriesController")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterRoomListDynamicEntriesController) Write(writer io.Writer, value *RoomListDynamicEntriesController) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerRoomListDynamicEntriesController struct{}

func (_ FfiDestroyerRoomListDynamicEntriesController) Destroy(value *RoomListDynamicEntriesController) {
	value.Destroy()
}

type RoomListEntriesWithDynamicAdaptersResultInterface interface {
	Controller() *RoomListDynamicEntriesController
	EntriesStream() *TaskHandle
}
type RoomListEntriesWithDynamicAdaptersResult struct {
	ffiObject FfiObject
}

func (_self *RoomListEntriesWithDynamicAdaptersResult) Controller() *RoomListDynamicEntriesController {
	_pointer := _self.ffiObject.incrementPointer("*RoomListEntriesWithDynamicAdaptersResult")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterRoomListDynamicEntriesControllerINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_roomlistentrieswithdynamicadaptersresult_controller(
			_pointer, _uniffiStatus)
	}))
}

func (_self *RoomListEntriesWithDynamicAdaptersResult) EntriesStream() *TaskHandle {
	_pointer := _self.ffiObject.incrementPointer("*RoomListEntriesWithDynamicAdaptersResult")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTaskHandleINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_roomlistentrieswithdynamicadaptersresult_entries_stream(
			_pointer, _uniffiStatus)
	}))
}
func (object *RoomListEntriesWithDynamicAdaptersResult) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterRoomListEntriesWithDynamicAdaptersResult struct{}

var FfiConverterRoomListEntriesWithDynamicAdaptersResultINSTANCE = FfiConverterRoomListEntriesWithDynamicAdaptersResult{}

func (c FfiConverterRoomListEntriesWithDynamicAdaptersResult) Lift(pointer unsafe.Pointer) *RoomListEntriesWithDynamicAdaptersResult {
	result := &RoomListEntriesWithDynamicAdaptersResult{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_roomlistentrieswithdynamicadaptersresult(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_roomlistentrieswithdynamicadaptersresult(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*RoomListEntriesWithDynamicAdaptersResult).Destroy)
	return result
}

func (c FfiConverterRoomListEntriesWithDynamicAdaptersResult) Read(reader io.Reader) *RoomListEntriesWithDynamicAdaptersResult {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterRoomListEntriesWithDynamicAdaptersResult) Lower(value *RoomListEntriesWithDynamicAdaptersResult) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*RoomListEntriesWithDynamicAdaptersResult")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterRoomListEntriesWithDynamicAdaptersResult) Write(writer io.Writer, value *RoomListEntriesWithDynamicAdaptersResult) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerRoomListEntriesWithDynamicAdaptersResult struct{}

func (_ FfiDestroyerRoomListEntriesWithDynamicAdaptersResult) Destroy(value *RoomListEntriesWithDynamicAdaptersResult) {
	value.Destroy()
}

type RoomListServiceInterface interface {
	AllRooms() (*RoomList, error)
	Room(roomId string) (*Room, error)
	State(listener RoomListServiceStateListener) *TaskHandle
	SubscribeToRooms(roomIds []string) error
	SyncIndicator(delayBeforeShowingInMs uint32, delayBeforeHidingInMs uint32, listener RoomListServiceSyncIndicatorListener) *TaskHandle
}
type RoomListService struct {
	ffiObject FfiObject
}

func (_self *RoomListService) AllRooms() (*RoomList, error) {
	_pointer := _self.ffiObject.incrementPointer("*RoomListService")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[RoomListError](
		FfiConverterRoomListErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *RoomList {
			return FfiConverterRoomListINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_roomlistservice_all_rooms(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

func (_self *RoomListService) Room(roomId string) (*Room, error) {
	_pointer := _self.ffiObject.incrementPointer("*RoomListService")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[RoomListError](FfiConverterRoomListError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_roomlistservice_room(
			_pointer, FfiConverterStringINSTANCE.Lower(roomId), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *Room
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterRoomINSTANCE.Lift(_uniffiRV), nil
	}
}

func (_self *RoomListService) State(listener RoomListServiceStateListener) *TaskHandle {
	_pointer := _self.ffiObject.incrementPointer("*RoomListService")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTaskHandleINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_roomlistservice_state(
			_pointer, FfiConverterCallbackInterfaceRoomListServiceStateListenerINSTANCE.Lower(listener), _uniffiStatus)
	}))
}

func (_self *RoomListService) SubscribeToRooms(roomIds []string) error {
	_pointer := _self.ffiObject.incrementPointer("*RoomListService")
	defer _self.ffiObject.decrementPointer()
	_, _uniffiErr := rustCallWithError[RoomListError](FfiConverterRoomListError{}, func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_matrix_sdk_ffi_fn_method_roomlistservice_subscribe_to_rooms(
			_pointer, FfiConverterSequenceStringINSTANCE.Lower(roomIds), _uniffiStatus)
		return false
	})
	return _uniffiErr.AsError()
}

func (_self *RoomListService) SyncIndicator(delayBeforeShowingInMs uint32, delayBeforeHidingInMs uint32, listener RoomListServiceSyncIndicatorListener) *TaskHandle {
	_pointer := _self.ffiObject.incrementPointer("*RoomListService")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTaskHandleINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_roomlistservice_sync_indicator(
			_pointer, FfiConverterUint32INSTANCE.Lower(delayBeforeShowingInMs), FfiConverterUint32INSTANCE.Lower(delayBeforeHidingInMs), FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListenerINSTANCE.Lower(listener), _uniffiStatus)
	}))
}
func (object *RoomListService) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterRoomListService struct{}

var FfiConverterRoomListServiceINSTANCE = FfiConverterRoomListService{}

func (c FfiConverterRoomListService) Lift(pointer unsafe.Pointer) *RoomListService {
	result := &RoomListService{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_roomlistservice(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_roomlistservice(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*RoomListService).Destroy)
	return result
}

func (c FfiConverterRoomListService) Read(reader io.Reader) *RoomListService {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterRoomListService) Lower(value *RoomListService) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*RoomListService")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterRoomListService) Write(writer io.Writer, value *RoomListService) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerRoomListService struct{}

func (_ FfiDestroyerRoomListService) Destroy(value *RoomListService) {
	value.Destroy()
}

type RoomMembersIteratorInterface interface {
	Len() uint32
	NextChunk(chunkSize uint32) *[]RoomMember
}
type RoomMembersIterator struct {
	ffiObject FfiObject
}

func (_self *RoomMembersIterator) Len() uint32 {
	_pointer := _self.ffiObject.incrementPointer("*RoomMembersIterator")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint32INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint32_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_roommembersiterator_len(
			_pointer, _uniffiStatus)
	}))
}

func (_self *RoomMembersIterator) NextChunk(chunkSize uint32) *[]RoomMember {
	_pointer := _self.ffiObject.incrementPointer("*RoomMembersIterator")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalSequenceRoomMemberINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_roommembersiterator_next_chunk(
				_pointer, FfiConverterUint32INSTANCE.Lower(chunkSize), _uniffiStatus),
		}
	}))
}
func (object *RoomMembersIterator) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterRoomMembersIterator struct{}

var FfiConverterRoomMembersIteratorINSTANCE = FfiConverterRoomMembersIterator{}

func (c FfiConverterRoomMembersIterator) Lift(pointer unsafe.Pointer) *RoomMembersIterator {
	result := &RoomMembersIterator{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_roommembersiterator(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_roommembersiterator(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*RoomMembersIterator).Destroy)
	return result
}

func (c FfiConverterRoomMembersIterator) Read(reader io.Reader) *RoomMembersIterator {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterRoomMembersIterator) Lower(value *RoomMembersIterator) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*RoomMembersIterator")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterRoomMembersIterator) Write(writer io.Writer, value *RoomMembersIterator) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerRoomMembersIterator struct{}

func (_ FfiDestroyerRoomMembersIterator) Destroy(value *RoomMembersIterator) {
	value.Destroy()
}

type RoomMessageEventContentWithoutRelationInterface interface {
	WithMentions(mentions Mentions) *RoomMessageEventContentWithoutRelation
}
type RoomMessageEventContentWithoutRelation struct {
	ffiObject FfiObject
}

func (_self *RoomMessageEventContentWithoutRelation) WithMentions(mentions Mentions) *RoomMessageEventContentWithoutRelation {
	_pointer := _self.ffiObject.incrementPointer("*RoomMessageEventContentWithoutRelation")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterRoomMessageEventContentWithoutRelationINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_roommessageeventcontentwithoutrelation_with_mentions(
			_pointer, FfiConverterMentionsINSTANCE.Lower(mentions), _uniffiStatus)
	}))
}
func (object *RoomMessageEventContentWithoutRelation) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterRoomMessageEventContentWithoutRelation struct{}

var FfiConverterRoomMessageEventContentWithoutRelationINSTANCE = FfiConverterRoomMessageEventContentWithoutRelation{}

func (c FfiConverterRoomMessageEventContentWithoutRelation) Lift(pointer unsafe.Pointer) *RoomMessageEventContentWithoutRelation {
	result := &RoomMessageEventContentWithoutRelation{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_roommessageeventcontentwithoutrelation(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_roommessageeventcontentwithoutrelation(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*RoomMessageEventContentWithoutRelation).Destroy)
	return result
}

func (c FfiConverterRoomMessageEventContentWithoutRelation) Read(reader io.Reader) *RoomMessageEventContentWithoutRelation {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterRoomMessageEventContentWithoutRelation) Lower(value *RoomMessageEventContentWithoutRelation) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*RoomMessageEventContentWithoutRelation")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterRoomMessageEventContentWithoutRelation) Write(writer io.Writer, value *RoomMessageEventContentWithoutRelation) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerRoomMessageEventContentWithoutRelation struct{}

func (_ FfiDestroyerRoomMessageEventContentWithoutRelation) Destroy(value *RoomMessageEventContentWithoutRelation) {
	value.Destroy()
}

// A room preview for a room. It's intended to be used to represent rooms that
// aren't joined yet.
type RoomPreviewInterface interface {
	// Forget the room if we had access to it, and it was left or banned.
	Forget() error
	// Returns the room info the preview contains.
	Info() (RoomPreviewInfo, error)
	// Get the user who created the invite, if any.
	Inviter() *RoomMember
	// Leave the room if the room preview state is either joined, invited or
	// knocked.
	//
	// If rejecting an invite then also forget it as an extra layer of
	// protection against spam attacks.
	//
	// Will return an error otherwise.
	Leave() error
	// Get the membership details for the current user.
	OwnMembershipDetails() *RoomMemberWithSenderInfo
}

// A room preview for a room. It's intended to be used to represent rooms that
// aren't joined yet.
type RoomPreview struct {
	ffiObject FfiObject
}

// Forget the room if we had access to it, and it was left or banned.
func (_self *RoomPreview) Forget() error {
	_pointer := _self.ffiObject.incrementPointer("*RoomPreview")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_roompreview_forget(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Returns the room info the preview contains.
func (_self *RoomPreview) Info() (RoomPreviewInfo, error) {
	_pointer := _self.ffiObject.incrementPointer("*RoomPreview")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[ClientError](FfiConverterClientError{}, func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_roompreview_info(
				_pointer, _uniffiStatus),
		}
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue RoomPreviewInfo
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterRoomPreviewInfoINSTANCE.Lift(_uniffiRV), nil
	}
}

// Get the user who created the invite, if any.
func (_self *RoomPreview) Inviter() *RoomMember {
	_pointer := _self.ffiObject.incrementPointer("*RoomPreview")
	defer _self.ffiObject.decrementPointer()
	res, _ := uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) *RoomMember {
			return FfiConverterOptionalRoomMemberINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_roompreview_inviter(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res
}

// Leave the room if the room preview state is either joined, invited or
// knocked.
//
// If rejecting an invite then also forget it as an extra layer of
// protection against spam attacks.
//
// Will return an error otherwise.
func (_self *RoomPreview) Leave() error {
	_pointer := _self.ffiObject.incrementPointer("*RoomPreview")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_roompreview_leave(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Get the membership details for the current user.
func (_self *RoomPreview) OwnMembershipDetails() *RoomMemberWithSenderInfo {
	_pointer := _self.ffiObject.incrementPointer("*RoomPreview")
	defer _self.ffiObject.decrementPointer()
	res, _ := uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) *RoomMemberWithSenderInfo {
			return FfiConverterOptionalRoomMemberWithSenderInfoINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_roompreview_own_membership_details(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res
}
func (object *RoomPreview) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterRoomPreview struct{}

var FfiConverterRoomPreviewINSTANCE = FfiConverterRoomPreview{}

func (c FfiConverterRoomPreview) Lift(pointer unsafe.Pointer) *RoomPreview {
	result := &RoomPreview{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_roompreview(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_roompreview(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*RoomPreview).Destroy)
	return result
}

func (c FfiConverterRoomPreview) Read(reader io.Reader) *RoomPreview {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterRoomPreview) Lower(value *RoomPreview) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*RoomPreview")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterRoomPreview) Write(writer io.Writer, value *RoomPreview) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerRoomPreview struct{}

func (_ FfiDestroyerRoomPreview) Destroy(value *RoomPreview) {
	value.Destroy()
}

type SendAttachmentJoinHandleInterface interface {
	// Cancel the current sending task.
	//
	// A subsequent call to [`Self::join`] will return immediately.
	Cancel()
	// Wait until the attachment has been sent.
	//
	// If the sending had been cancelled, will return immediately.
	Join() error
}
type SendAttachmentJoinHandle struct {
	ffiObject FfiObject
}

// Cancel the current sending task.
//
// A subsequent call to [`Self::join`] will return immediately.
func (_self *SendAttachmentJoinHandle) Cancel() {
	_pointer := _self.ffiObject.incrementPointer("*SendAttachmentJoinHandle")
	defer _self.ffiObject.decrementPointer()
	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_cancel(
			_pointer, _uniffiStatus)
		return false
	})
}

// Wait until the attachment has been sent.
//
// If the sending had been cancelled, will return immediately.
func (_self *SendAttachmentJoinHandle) Join() error {
	_pointer := _self.ffiObject.incrementPointer("*SendAttachmentJoinHandle")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[RoomError](
		FfiConverterRoomErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_join(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}
func (object *SendAttachmentJoinHandle) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSendAttachmentJoinHandle struct{}

var FfiConverterSendAttachmentJoinHandleINSTANCE = FfiConverterSendAttachmentJoinHandle{}

func (c FfiConverterSendAttachmentJoinHandle) Lift(pointer unsafe.Pointer) *SendAttachmentJoinHandle {
	result := &SendAttachmentJoinHandle{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_sendattachmentjoinhandle(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_sendattachmentjoinhandle(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*SendAttachmentJoinHandle).Destroy)
	return result
}

func (c FfiConverterSendAttachmentJoinHandle) Read(reader io.Reader) *SendAttachmentJoinHandle {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSendAttachmentJoinHandle) Lower(value *SendAttachmentJoinHandle) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*SendAttachmentJoinHandle")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSendAttachmentJoinHandle) Write(writer io.Writer, value *SendAttachmentJoinHandle) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSendAttachmentJoinHandle struct{}

func (_ FfiDestroyerSendAttachmentJoinHandle) Destroy(value *SendAttachmentJoinHandle) {
	value.Destroy()
}

// A handle to perform actions onto a local echo.
type SendHandleInterface interface {
	// Try to abort the sending of the current event.
	//
	// If this returns `true`, then the sending could be aborted, because the
	// event hasn't been sent yet. Otherwise, if this returns `false`, the
	// event had already been sent and could not be aborted.
	//
	// This has an effect only on the first call; subsequent calls will always
	// return `false`.
	Abort() (bool, error)
	// Attempt to manually resend messages that failed to send due to issues
	// that should now have been fixed.
	//
	// This is useful for example, when there's a
	// `SessionRecipientCollectionError::VerifiedUserChangedIdentity` error;
	// the user may have re-verified on a different device and would now
	// like to send the failed message that's waiting on this device.
	//
	// # Arguments
	//
	// * `transaction_id` - The send queue transaction identifier of the local
	// echo that should be unwedged.
	TryResend() error
}

// A handle to perform actions onto a local echo.
type SendHandle struct {
	ffiObject FfiObject
}

// Try to abort the sending of the current event.
//
// If this returns `true`, then the sending could be aborted, because the
// event hasn't been sent yet. Otherwise, if this returns `false`, the
// event had already been sent and could not be aborted.
//
// This has an effect only on the first call; subsequent calls will always
// return `false`.
func (_self *SendHandle) Abort() (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*SendHandle")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_sendhandle_abort(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

// Attempt to manually resend messages that failed to send due to issues
// that should now have been fixed.
//
// This is useful for example, when there's a
// `SessionRecipientCollectionError::VerifiedUserChangedIdentity` error;
// the user may have re-verified on a different device and would now
// like to send the failed message that's waiting on this device.
//
// # Arguments
//
// * `transaction_id` - The send queue transaction identifier of the local
// echo that should be unwedged.
func (_self *SendHandle) TryResend() error {
	_pointer := _self.ffiObject.incrementPointer("*SendHandle")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_sendhandle_try_resend(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}
func (object *SendHandle) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSendHandle struct{}

var FfiConverterSendHandleINSTANCE = FfiConverterSendHandle{}

func (c FfiConverterSendHandle) Lift(pointer unsafe.Pointer) *SendHandle {
	result := &SendHandle{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_sendhandle(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_sendhandle(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*SendHandle).Destroy)
	return result
}

func (c FfiConverterSendHandle) Read(reader io.Reader) *SendHandle {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSendHandle) Lower(value *SendHandle) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*SendHandle")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSendHandle) Write(writer io.Writer, value *SendHandle) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSendHandle struct{}

func (_ FfiDestroyerSendHandle) Destroy(value *SendHandle) {
	value.Destroy()
}

type SessionVerificationControllerInterface interface {
	// Accept the previously acknowledged verification request
	AcceptVerificationRequest() error
	// Set this particular request as the currently active one and register for
	// events pertaining it.
	// * `sender_id` - The user requesting verification.
	// * `flow_id` - - The ID that uniquely identifies the verification flow.
	AcknowledgeVerificationRequest(senderId string, flowId string) error
	// Confirm that the short auth strings match on both sides.
	ApproveVerification() error
	// Cancel the current verification request
	CancelVerification() error
	// Reject the short auth string
	DeclineVerification() error
	// Request verification for the current device
	RequestDeviceVerification() error
	// Request verification for the given user
	RequestUserVerification(userId string) error
	SetDelegate(delegate *SessionVerificationControllerDelegate)
	// Transition the current verification request into a SAS verification
	// flow.
	StartSasVerification() error
}
type SessionVerificationController struct {
	ffiObject FfiObject
}

// Accept the previously acknowledged verification request
func (_self *SessionVerificationController) AcceptVerificationRequest() error {
	_pointer := _self.ffiObject.incrementPointer("*SessionVerificationController")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_accept_verification_request(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Set this particular request as the currently active one and register for
// events pertaining it.
// * `sender_id` - The user requesting verification.
// * `flow_id` - - The ID that uniquely identifies the verification flow.
func (_self *SessionVerificationController) AcknowledgeVerificationRequest(senderId string, flowId string) error {
	_pointer := _self.ffiObject.incrementPointer("*SessionVerificationController")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_acknowledge_verification_request(
			_pointer, FfiConverterStringINSTANCE.Lower(senderId), FfiConverterStringINSTANCE.Lower(flowId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Confirm that the short auth strings match on both sides.
func (_self *SessionVerificationController) ApproveVerification() error {
	_pointer := _self.ffiObject.incrementPointer("*SessionVerificationController")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_approve_verification(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Cancel the current verification request
func (_self *SessionVerificationController) CancelVerification() error {
	_pointer := _self.ffiObject.incrementPointer("*SessionVerificationController")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_cancel_verification(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Reject the short auth string
func (_self *SessionVerificationController) DeclineVerification() error {
	_pointer := _self.ffiObject.incrementPointer("*SessionVerificationController")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_decline_verification(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Request verification for the current device
func (_self *SessionVerificationController) RequestDeviceVerification() error {
	_pointer := _self.ffiObject.incrementPointer("*SessionVerificationController")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_request_device_verification(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Request verification for the given user
func (_self *SessionVerificationController) RequestUserVerification(userId string) error {
	_pointer := _self.ffiObject.incrementPointer("*SessionVerificationController")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_request_user_verification(
			_pointer, FfiConverterStringINSTANCE.Lower(userId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *SessionVerificationController) SetDelegate(delegate *SessionVerificationControllerDelegate) {
	_pointer := _self.ffiObject.incrementPointer("*SessionVerificationController")
	defer _self.ffiObject.decrementPointer()
	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_set_delegate(
			_pointer, FfiConverterOptionalCallbackInterfaceSessionVerificationControllerDelegateINSTANCE.Lower(delegate), _uniffiStatus)
		return false
	})
}

// Transition the current verification request into a SAS verification
// flow.
func (_self *SessionVerificationController) StartSasVerification() error {
	_pointer := _self.ffiObject.incrementPointer("*SessionVerificationController")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_start_sas_verification(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}
func (object *SessionVerificationController) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSessionVerificationController struct{}

var FfiConverterSessionVerificationControllerINSTANCE = FfiConverterSessionVerificationController{}

func (c FfiConverterSessionVerificationController) Lift(pointer unsafe.Pointer) *SessionVerificationController {
	result := &SessionVerificationController{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_sessionverificationcontroller(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_sessionverificationcontroller(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*SessionVerificationController).Destroy)
	return result
}

func (c FfiConverterSessionVerificationController) Read(reader io.Reader) *SessionVerificationController {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSessionVerificationController) Lower(value *SessionVerificationController) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*SessionVerificationController")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSessionVerificationController) Write(writer io.Writer, value *SessionVerificationController) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSessionVerificationController struct{}

func (_ FfiDestroyerSessionVerificationController) Destroy(value *SessionVerificationController) {
	value.Destroy()
}

type SessionVerificationEmojiInterface interface {
	Description() string
	Symbol() string
}
type SessionVerificationEmoji struct {
	ffiObject FfiObject
}

func (_self *SessionVerificationEmoji) Description() string {
	_pointer := _self.ffiObject.incrementPointer("*SessionVerificationEmoji")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_description(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *SessionVerificationEmoji) Symbol() string {
	_pointer := _self.ffiObject.incrementPointer("*SessionVerificationEmoji")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_symbol(
				_pointer, _uniffiStatus),
		}
	}))
}
func (object *SessionVerificationEmoji) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSessionVerificationEmoji struct{}

var FfiConverterSessionVerificationEmojiINSTANCE = FfiConverterSessionVerificationEmoji{}

func (c FfiConverterSessionVerificationEmoji) Lift(pointer unsafe.Pointer) *SessionVerificationEmoji {
	result := &SessionVerificationEmoji{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_sessionverificationemoji(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_sessionverificationemoji(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*SessionVerificationEmoji).Destroy)
	return result
}

func (c FfiConverterSessionVerificationEmoji) Read(reader io.Reader) *SessionVerificationEmoji {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSessionVerificationEmoji) Lower(value *SessionVerificationEmoji) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*SessionVerificationEmoji")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSessionVerificationEmoji) Write(writer io.Writer, value *SessionVerificationEmoji) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSessionVerificationEmoji struct{}

func (_ FfiDestroyerSessionVerificationEmoji) Destroy(value *SessionVerificationEmoji) {
	value.Destroy()
}

type SpanInterface interface {
	Enter()
	Exit()
	IsNone() bool
}
type Span struct {
	ffiObject FfiObject
}

// Create a span originating at the given callsite (file, line and column).
//
// The target should be something like a module path, and can be referenced
// in the filter string given to `setup_tracing`. `level` and `target`
// for a callsite are fixed at the first creation of a span for that
// callsite and can not be changed afterwards, i.e. the level and
// target passed for second and following creation of a span with the same
// callsite will be ignored.
//
// This function leaks a little bit of memory for each unique (file +
// line + level + target + name) it is called with. Please make sure that
// the number of different combinations of those parameters this can be
// called with is constant in the final executable.
//
// For a span to have an effect, you must `.enter()` it at the start of a
// logical unit of work and `.exit()` it at the end of the same (including
// on failure). Entering registers the span in thread-local storage, so
// future calls to `log_event` on the same thread are able to attach the
// events they create to the span, exiting unregisters it. For this to
// work, exiting a span must be done on the same thread where it was
// entered. It is possible to enter a span on multiple threads, in which
// case it should also be exited on all of them individually; that is,
// unless you *want* the span to be attached to all further events created
// on that thread.
func NewSpan(file string, line *uint32, level LogLevel, target string, name string) *Span {
	return FfiConverterSpanINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_constructor_span_new(FfiConverterStringINSTANCE.Lower(file), FfiConverterOptionalUint32INSTANCE.Lower(line), FfiConverterLogLevelINSTANCE.Lower(level), FfiConverterStringINSTANCE.Lower(target), FfiConverterStringINSTANCE.Lower(name), _uniffiStatus)
	}))
}

func SpanCurrent() *Span {
	return FfiConverterSpanINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_constructor_span_current(_uniffiStatus)
	}))
}

func (_self *Span) Enter() {
	_pointer := _self.ffiObject.incrementPointer("*Span")
	defer _self.ffiObject.decrementPointer()
	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_matrix_sdk_ffi_fn_method_span_enter(
			_pointer, _uniffiStatus)
		return false
	})
}

func (_self *Span) Exit() {
	_pointer := _self.ffiObject.incrementPointer("*Span")
	defer _self.ffiObject.decrementPointer()
	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_matrix_sdk_ffi_fn_method_span_exit(
			_pointer, _uniffiStatus)
		return false
	})
}

func (_self *Span) IsNone() bool {
	_pointer := _self.ffiObject.incrementPointer("*Span")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_span_is_none(
			_pointer, _uniffiStatus)
	}))
}
func (object *Span) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSpan struct{}

var FfiConverterSpanINSTANCE = FfiConverterSpan{}

func (c FfiConverterSpan) Lift(pointer unsafe.Pointer) *Span {
	result := &Span{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_span(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_span(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Span).Destroy)
	return result
}

func (c FfiConverterSpan) Read(reader io.Reader) *Span {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSpan) Lower(value *Span) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Span")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSpan) Write(writer io.Writer, value *Span) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSpan struct{}

func (_ FfiDestroyerSpan) Destroy(value *Span) {
	value.Destroy()
}

// An object encapsulating the SSO login flow
type SsoHandlerInterface interface {
	// Completes the SSO login process.
	Finish(callbackUrl string) error
	// Returns the URL for starting SSO authentication. The URL should be
	// opened in a web view. Once the web view succeeds, call `finish` with
	// the callback URL.
	Url() string
}

// An object encapsulating the SSO login flow
type SsoHandler struct {
	ffiObject FfiObject
}

// Completes the SSO login process.
func (_self *SsoHandler) Finish(callbackUrl string) error {
	_pointer := _self.ffiObject.incrementPointer("*SsoHandler")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[SsoError](
		FfiConverterSsoErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_ssohandler_finish(
			_pointer, FfiConverterStringINSTANCE.Lower(callbackUrl)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Returns the URL for starting SSO authentication. The URL should be
// opened in a web view. Once the web view succeeds, call `finish` with
// the callback URL.
func (_self *SsoHandler) Url() string {
	_pointer := _self.ffiObject.incrementPointer("*SsoHandler")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_ssohandler_url(
				_pointer, _uniffiStatus),
		}
	}))
}
func (object *SsoHandler) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSsoHandler struct{}

var FfiConverterSsoHandlerINSTANCE = FfiConverterSsoHandler{}

func (c FfiConverterSsoHandler) Lift(pointer unsafe.Pointer) *SsoHandler {
	result := &SsoHandler{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_ssohandler(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_ssohandler(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*SsoHandler).Destroy)
	return result
}

func (c FfiConverterSsoHandler) Read(reader io.Reader) *SsoHandler {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSsoHandler) Lower(value *SsoHandler) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*SsoHandler")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSsoHandler) Write(writer io.Writer, value *SsoHandler) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSsoHandler struct{}

func (_ FfiDestroyerSsoHandler) Destroy(value *SsoHandler) {
	value.Destroy()
}

type SyncServiceInterface interface {
	RoomListService() *RoomListService
	Start()
	State(listener SyncServiceStateObserver) *TaskHandle
	Stop()
}
type SyncService struct {
	ffiObject FfiObject
}

func (_self *SyncService) RoomListService() *RoomListService {
	_pointer := _self.ffiObject.incrementPointer("*SyncService")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterRoomListServiceINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_syncservice_room_list_service(
			_pointer, _uniffiStatus)
	}))
}

func (_self *SyncService) Start() {
	_pointer := _self.ffiObject.incrementPointer("*SyncService")
	defer _self.ffiObject.decrementPointer()
	uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_syncservice_start(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

}

func (_self *SyncService) State(listener SyncServiceStateObserver) *TaskHandle {
	_pointer := _self.ffiObject.incrementPointer("*SyncService")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTaskHandleINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_syncservice_state(
			_pointer, FfiConverterCallbackInterfaceSyncServiceStateObserverINSTANCE.Lower(listener), _uniffiStatus)
	}))
}

func (_self *SyncService) Stop() {
	_pointer := _self.ffiObject.incrementPointer("*SyncService")
	defer _self.ffiObject.decrementPointer()
	uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_syncservice_stop(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

}
func (object *SyncService) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSyncService struct{}

var FfiConverterSyncServiceINSTANCE = FfiConverterSyncService{}

func (c FfiConverterSyncService) Lift(pointer unsafe.Pointer) *SyncService {
	result := &SyncService{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_syncservice(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_syncservice(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*SyncService).Destroy)
	return result
}

func (c FfiConverterSyncService) Read(reader io.Reader) *SyncService {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSyncService) Lower(value *SyncService) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*SyncService")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSyncService) Write(writer io.Writer, value *SyncService) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSyncService struct{}

func (_ FfiDestroyerSyncService) Destroy(value *SyncService) {
	value.Destroy()
}

type SyncServiceBuilderInterface interface {
	Finish() (*SyncService, error)
	WithCrossProcessLock() *SyncServiceBuilder
	// Enable the "offline" mode for the [`SyncService`].
	WithOfflineMode() *SyncServiceBuilder
}
type SyncServiceBuilder struct {
	ffiObject FfiObject
}

func (_self *SyncServiceBuilder) Finish() (*SyncService, error) {
	_pointer := _self.ffiObject.incrementPointer("*SyncServiceBuilder")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *SyncService {
			return FfiConverterSyncServiceINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_finish(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

func (_self *SyncServiceBuilder) WithCrossProcessLock() *SyncServiceBuilder {
	_pointer := _self.ffiObject.incrementPointer("*SyncServiceBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSyncServiceBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_cross_process_lock(
			_pointer, _uniffiStatus)
	}))
}

// Enable the "offline" mode for the [`SyncService`].
func (_self *SyncServiceBuilder) WithOfflineMode() *SyncServiceBuilder {
	_pointer := _self.ffiObject.incrementPointer("*SyncServiceBuilder")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterSyncServiceBuilderINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_offline_mode(
			_pointer, _uniffiStatus)
	}))
}
func (object *SyncServiceBuilder) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterSyncServiceBuilder struct{}

var FfiConverterSyncServiceBuilderINSTANCE = FfiConverterSyncServiceBuilder{}

func (c FfiConverterSyncServiceBuilder) Lift(pointer unsafe.Pointer) *SyncServiceBuilder {
	result := &SyncServiceBuilder{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_syncservicebuilder(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_syncservicebuilder(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*SyncServiceBuilder).Destroy)
	return result
}

func (c FfiConverterSyncServiceBuilder) Read(reader io.Reader) *SyncServiceBuilder {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterSyncServiceBuilder) Lower(value *SyncServiceBuilder) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*SyncServiceBuilder")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterSyncServiceBuilder) Write(writer io.Writer, value *SyncServiceBuilder) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerSyncServiceBuilder struct{}

func (_ FfiDestroyerSyncServiceBuilder) Destroy(value *SyncServiceBuilder) {
	value.Destroy()
}

// A task handle is a way to keep the handle a task running by itself in
// detached mode.
//
// It's a thin wrapper around [`JoinHandle`].
type TaskHandleInterface interface {
	Cancel()
	// Check whether the handle is finished.
	IsFinished() bool
}

// A task handle is a way to keep the handle a task running by itself in
// detached mode.
//
// It's a thin wrapper around [`JoinHandle`].
type TaskHandle struct {
	ffiObject FfiObject
}

func (_self *TaskHandle) Cancel() {
	_pointer := _self.ffiObject.incrementPointer("*TaskHandle")
	defer _self.ffiObject.decrementPointer()
	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_matrix_sdk_ffi_fn_method_taskhandle_cancel(
			_pointer, _uniffiStatus)
		return false
	})
}

// Check whether the handle is finished.
func (_self *TaskHandle) IsFinished() bool {
	_pointer := _self.ffiObject.incrementPointer("*TaskHandle")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_taskhandle_is_finished(
			_pointer, _uniffiStatus)
	}))
}
func (object *TaskHandle) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterTaskHandle struct{}

var FfiConverterTaskHandleINSTANCE = FfiConverterTaskHandle{}

func (c FfiConverterTaskHandle) Lift(pointer unsafe.Pointer) *TaskHandle {
	result := &TaskHandle{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_taskhandle(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_taskhandle(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*TaskHandle).Destroy)
	return result
}

func (c FfiConverterTaskHandle) Read(reader io.Reader) *TaskHandle {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterTaskHandle) Lower(value *TaskHandle) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*TaskHandle")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterTaskHandle) Write(writer io.Writer, value *TaskHandle) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerTaskHandle struct{}

func (_ FfiDestroyerTaskHandle) Destroy(value *TaskHandle) {
	value.Destroy()
}

type ThreadSummaryInterface interface {
	LatestEvent() ThreadSummaryLatestEventDetails
}
type ThreadSummary struct {
	ffiObject FfiObject
}

func (_self *ThreadSummary) LatestEvent() ThreadSummaryLatestEventDetails {
	_pointer := _self.ffiObject.incrementPointer("*ThreadSummary")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterThreadSummaryLatestEventDetailsINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_threadsummary_latest_event(
				_pointer, _uniffiStatus),
		}
	}))
}
func (object *ThreadSummary) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterThreadSummary struct{}

var FfiConverterThreadSummaryINSTANCE = FfiConverterThreadSummary{}

func (c FfiConverterThreadSummary) Lift(pointer unsafe.Pointer) *ThreadSummary {
	result := &ThreadSummary{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_threadsummary(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_threadsummary(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*ThreadSummary).Destroy)
	return result
}

func (c FfiConverterThreadSummary) Read(reader io.Reader) *ThreadSummary {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterThreadSummary) Lower(value *ThreadSummary) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ThreadSummary")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterThreadSummary) Write(writer io.Writer, value *ThreadSummary) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerThreadSummary struct{}

func (_ FfiDestroyerThreadSummary) Destroy(value *ThreadSummary) {
	value.Destroy()
}

type TimelineInterface interface {
	AddListener(listener TimelineListener) *TaskHandle
	CreateMessageContent(msgType MessageType) **RoomMessageEventContentWithoutRelation
	CreatePoll(question string, answers []string, maxSelections uint8, pollKind PollKind) error
	// Edits an event from the timeline.
	//
	// If it was a local event, this will *try* to edit it, if it was not
	// being sent already. If the event was a remote event, then it will be
	// redacted by sending an edit request to the server.
	//
	// Returns whether the edit did happen. It can only return false for
	// local events that are being processed.
	Edit(eventOrTransactionId EventOrTransactionId, newContent EditedContent) error
	EndPoll(pollStartEventId string, text string) error
	FetchDetailsForEvent(eventId string) error
	FetchMembers()
	// Get the current timeline item for the given event ID, if any.
	//
	// Will return a remote event, *or* a local echo that has been sent but not
	// yet replaced by a remote echo.
	//
	// It's preferable to store the timeline items in the model for your UI, if
	// possible, instead of just storing IDs and coming back to the timeline
	// object to look up items.
	GetEventTimelineItemByEventId(eventId string) (EventTimelineItem, error)
	// Load the reply details for the given event id.
	//
	// This will return an `InReplyToDetails` object that contains the details
	// which will either be ready or an error.
	LoadReplyDetails(eventIdStr string) (*InReplyToDetails, error)
	// Mark the room as read by trying to attach an *unthreaded* read receipt
	// to the latest room event.
	//
	// This works even if the latest event belongs to a thread, as a threaded
	// reply also belongs to the unthreaded timeline. No threaded receipt
	// will be sent here (see also #3123).
	MarkAsRead(receiptType ReceiptType) error
	// Paginate backwards, whether we are in focused mode or in live mode.
	//
	// Returns whether we hit the start of the timeline or not.
	PaginateBackwards(numEvents uint16) (bool, error)
	// Paginate forwards, whether we are in focused mode or in live mode.
	//
	// Returns whether we hit the end of the timeline or not.
	PaginateForwards(numEvents uint16) (bool, error)
	// Adds a new pinned event by sending an updated `m.room.pinned_events`
	// event containing the new event id.
	//
	// Returns `true` if we sent the request, `false` if the event was already
	// pinned.
	PinEvent(eventId string) (bool, error)
	// Redacts an event from the timeline.
	//
	// Only works for events that exist as timeline items.
	//
	// If it was a local event, this will *try* to cancel it, if it was not
	// being sent already. If the event was a remote event, then it will be
	// redacted by sending a redaction request to the server.
	//
	// Will return an error if the event couldn't be redacted.
	RedactEvent(eventOrTransactionId EventOrTransactionId, reason *string) error
	RetryDecryption(sessionIds []string)
	// Queues an event in the room's send queue so it's processed for
	// sending later.
	//
	// Returns an abort handle that allows to abort sending, if it hasn't
	// happened yet.
	Send(msg *RoomMessageEventContentWithoutRelation) (*SendHandle, error)
	SendAudio(params UploadParameters, audioInfo AudioInfo, progressWatcher *ProgressWatcher) (*SendAttachmentJoinHandle, error)
	SendFile(params UploadParameters, fileInfo FileInfo, progressWatcher *ProgressWatcher) (*SendAttachmentJoinHandle, error)
	SendImage(params UploadParameters, thumbnailPath *string, imageInfo ImageInfo, progressWatcher *ProgressWatcher) (*SendAttachmentJoinHandle, error)
	SendLocation(body string, geoUri string, description *string, zoomLevel *uint8, assetType *AssetType)
	SendPollResponse(pollStartEventId string, answers []string) error
	SendReadReceipt(receiptType ReceiptType, eventId string) error
	// Send a reply.
	//
	// If the replied to event has a thread relation, it is forwarded on the
	// reply so that clients that support threads can render the reply
	// inside the thread.
	SendReply(msg *RoomMessageEventContentWithoutRelation, replyParams ReplyParameters) error
	SendVideo(params UploadParameters, thumbnailPath *string, videoInfo VideoInfo, progressWatcher *ProgressWatcher) (*SendAttachmentJoinHandle, error)
	SendVoiceMessage(params UploadParameters, audioInfo AudioInfo, waveform []uint16, progressWatcher *ProgressWatcher) (*SendAttachmentJoinHandle, error)
	SubscribeToBackPaginationStatus(listener PaginationStatusListener) (*TaskHandle, error)
	// Toggle a reaction on an event.
	//
	// Adds or redacts a reaction based on the state of the reaction at the
	// time it is called.
	//
	// This method works both on local echoes and remote items.
	//
	// When redacting a previous reaction, the redaction reason is not set.
	//
	// Ensures that only one reaction is sent at a time to avoid race
	// conditions and spamming the homeserver with requests.
	ToggleReaction(itemId EventOrTransactionId, key string) error
	// Adds a new pinned event by sending an updated `m.room.pinned_events`
	// event without the event id we want to remove.
	//
	// Returns `true` if we sent the request, `false` if the event wasn't
	// pinned
	UnpinEvent(eventId string) (bool, error)
}
type Timeline struct {
	ffiObject FfiObject
}

func (_self *Timeline) AddListener(listener TimelineListener) *TaskHandle {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	res, _ := uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *TaskHandle {
			return FfiConverterTaskHandleINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_timeline_add_listener(
			_pointer, FfiConverterCallbackInterfaceTimelineListenerINSTANCE.Lower(listener)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res
}

func (_self *Timeline) CreateMessageContent(msgType MessageType) **RoomMessageEventContentWithoutRelation {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalRoomMessageEventContentWithoutRelationINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_timeline_create_message_content(
				_pointer, FfiConverterMessageTypeINSTANCE.Lower(msgType), _uniffiStatus),
		}
	}))
}

func (_self *Timeline) CreatePoll(question string, answers []string, maxSelections uint8, pollKind PollKind) error {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_timeline_create_poll(
			_pointer, FfiConverterStringINSTANCE.Lower(question), FfiConverterSequenceStringINSTANCE.Lower(answers), FfiConverterUint8INSTANCE.Lower(maxSelections), FfiConverterPollKindINSTANCE.Lower(pollKind)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Edits an event from the timeline.
//
// If it was a local event, this will *try* to edit it, if it was not
// being sent already. If the event was a remote event, then it will be
// redacted by sending an edit request to the server.
//
// Returns whether the edit did happen. It can only return false for
// local events that are being processed.
func (_self *Timeline) Edit(eventOrTransactionId EventOrTransactionId, newContent EditedContent) error {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_timeline_edit(
			_pointer, FfiConverterEventOrTransactionIdINSTANCE.Lower(eventOrTransactionId), FfiConverterEditedContentINSTANCE.Lower(newContent)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Timeline) EndPoll(pollStartEventId string, text string) error {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_timeline_end_poll(
			_pointer, FfiConverterStringINSTANCE.Lower(pollStartEventId), FfiConverterStringINSTANCE.Lower(text)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Timeline) FetchDetailsForEvent(eventId string) error {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_timeline_fetch_details_for_event(
			_pointer, FfiConverterStringINSTANCE.Lower(eventId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Timeline) FetchMembers() {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_timeline_fetch_members(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

}

// Get the current timeline item for the given event ID, if any.
//
// Will return a remote event, *or* a local echo that has been sent but not
// yet replaced by a remote echo.
//
// It's preferable to store the timeline items in the model for your UI, if
// possible, instead of just storing IDs and coming back to the timeline
// object to look up items.
func (_self *Timeline) GetEventTimelineItemByEventId(eventId string) (EventTimelineItem, error) {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) EventTimelineItem {
			return FfiConverterEventTimelineItemINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_timeline_get_event_timeline_item_by_event_id(
			_pointer, FfiConverterStringINSTANCE.Lower(eventId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// Load the reply details for the given event id.
//
// This will return an `InReplyToDetails` object that contains the details
// which will either be ready or an error.
func (_self *Timeline) LoadReplyDetails(eventIdStr string) (*InReplyToDetails, error) {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *InReplyToDetails {
			return FfiConverterInReplyToDetailsINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_timeline_load_reply_details(
			_pointer, FfiConverterStringINSTANCE.Lower(eventIdStr)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

// Mark the room as read by trying to attach an *unthreaded* read receipt
// to the latest room event.
//
// This works even if the latest event belongs to a thread, as a threaded
// reply also belongs to the unthreaded timeline. No threaded receipt
// will be sent here (see also #3123).
func (_self *Timeline) MarkAsRead(receiptType ReceiptType) error {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_timeline_mark_as_read(
			_pointer, FfiConverterReceiptTypeINSTANCE.Lower(receiptType)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Paginate backwards, whether we are in focused mode or in live mode.
//
// Returns whether we hit the start of the timeline or not.
func (_self *Timeline) PaginateBackwards(numEvents uint16) (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_timeline_paginate_backwards(
			_pointer, FfiConverterUint16INSTANCE.Lower(numEvents)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

// Paginate forwards, whether we are in focused mode or in live mode.
//
// Returns whether we hit the end of the timeline or not.
func (_self *Timeline) PaginateForwards(numEvents uint16) (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_timeline_paginate_forwards(
			_pointer, FfiConverterUint16INSTANCE.Lower(numEvents)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

// Adds a new pinned event by sending an updated `m.room.pinned_events`
// event containing the new event id.
//
// Returns `true` if we sent the request, `false` if the event was already
// pinned.
func (_self *Timeline) PinEvent(eventId string) (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_timeline_pin_event(
			_pointer, FfiConverterStringINSTANCE.Lower(eventId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}

// Redacts an event from the timeline.
//
// Only works for events that exist as timeline items.
//
// If it was a local event, this will *try* to cancel it, if it was not
// being sent already. If the event was a remote event, then it will be
// redacted by sending a redaction request to the server.
//
// Will return an error if the event couldn't be redacted.
func (_self *Timeline) RedactEvent(eventOrTransactionId EventOrTransactionId, reason *string) error {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_timeline_redact_event(
			_pointer, FfiConverterEventOrTransactionIdINSTANCE.Lower(eventOrTransactionId), FfiConverterOptionalStringINSTANCE.Lower(reason)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Timeline) RetryDecryption(sessionIds []string) {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_matrix_sdk_ffi_fn_method_timeline_retry_decryption(
			_pointer, FfiConverterSequenceStringINSTANCE.Lower(sessionIds), _uniffiStatus)
		return false
	})
}

// Queues an event in the room's send queue so it's processed for
// sending later.
//
// Returns an abort handle that allows to abort sending, if it hasn't
// happened yet.
func (_self *Timeline) Send(msg *RoomMessageEventContentWithoutRelation) (*SendHandle, error) {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *SendHandle {
			return FfiConverterSendHandleINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_timeline_send(
			_pointer, FfiConverterRoomMessageEventContentWithoutRelationINSTANCE.Lower(msg)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

func (_self *Timeline) SendAudio(params UploadParameters, audioInfo AudioInfo, progressWatcher *ProgressWatcher) (*SendAttachmentJoinHandle, error) {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[RoomError](FfiConverterRoomError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_timeline_send_audio(
			_pointer, FfiConverterUploadParametersINSTANCE.Lower(params), FfiConverterAudioInfoINSTANCE.Lower(audioInfo), FfiConverterOptionalCallbackInterfaceProgressWatcherINSTANCE.Lower(progressWatcher), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *SendAttachmentJoinHandle
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterSendAttachmentJoinHandleINSTANCE.Lift(_uniffiRV), nil
	}
}

func (_self *Timeline) SendFile(params UploadParameters, fileInfo FileInfo, progressWatcher *ProgressWatcher) (*SendAttachmentJoinHandle, error) {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[RoomError](FfiConverterRoomError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_timeline_send_file(
			_pointer, FfiConverterUploadParametersINSTANCE.Lower(params), FfiConverterFileInfoINSTANCE.Lower(fileInfo), FfiConverterOptionalCallbackInterfaceProgressWatcherINSTANCE.Lower(progressWatcher), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *SendAttachmentJoinHandle
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterSendAttachmentJoinHandleINSTANCE.Lift(_uniffiRV), nil
	}
}

func (_self *Timeline) SendImage(params UploadParameters, thumbnailPath *string, imageInfo ImageInfo, progressWatcher *ProgressWatcher) (*SendAttachmentJoinHandle, error) {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[RoomError](FfiConverterRoomError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_timeline_send_image(
			_pointer, FfiConverterUploadParametersINSTANCE.Lower(params), FfiConverterOptionalStringINSTANCE.Lower(thumbnailPath), FfiConverterImageInfoINSTANCE.Lower(imageInfo), FfiConverterOptionalCallbackInterfaceProgressWatcherINSTANCE.Lower(progressWatcher), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *SendAttachmentJoinHandle
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterSendAttachmentJoinHandleINSTANCE.Lift(_uniffiRV), nil
	}
}

func (_self *Timeline) SendLocation(body string, geoUri string, description *string, zoomLevel *uint8, assetType *AssetType) {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_timeline_send_location(
			_pointer, FfiConverterStringINSTANCE.Lower(body), FfiConverterStringINSTANCE.Lower(geoUri), FfiConverterOptionalStringINSTANCE.Lower(description), FfiConverterOptionalUint8INSTANCE.Lower(zoomLevel), FfiConverterOptionalAssetTypeINSTANCE.Lower(assetType)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

}

func (_self *Timeline) SendPollResponse(pollStartEventId string, answers []string) error {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_timeline_send_poll_response(
			_pointer, FfiConverterStringINSTANCE.Lower(pollStartEventId), FfiConverterSequenceStringINSTANCE.Lower(answers)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Timeline) SendReadReceipt(receiptType ReceiptType, eventId string) error {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_timeline_send_read_receipt(
			_pointer, FfiConverterReceiptTypeINSTANCE.Lower(receiptType), FfiConverterStringINSTANCE.Lower(eventId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Send a reply.
//
// If the replied to event has a thread relation, it is forwarded on the
// reply so that clients that support threads can render the reply
// inside the thread.
func (_self *Timeline) SendReply(msg *RoomMessageEventContentWithoutRelation, replyParams ReplyParameters) error {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_timeline_send_reply(
			_pointer, FfiConverterRoomMessageEventContentWithoutRelationINSTANCE.Lower(msg), FfiConverterReplyParametersINSTANCE.Lower(replyParams)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

func (_self *Timeline) SendVideo(params UploadParameters, thumbnailPath *string, videoInfo VideoInfo, progressWatcher *ProgressWatcher) (*SendAttachmentJoinHandle, error) {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[RoomError](FfiConverterRoomError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_timeline_send_video(
			_pointer, FfiConverterUploadParametersINSTANCE.Lower(params), FfiConverterOptionalStringINSTANCE.Lower(thumbnailPath), FfiConverterVideoInfoINSTANCE.Lower(videoInfo), FfiConverterOptionalCallbackInterfaceProgressWatcherINSTANCE.Lower(progressWatcher), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *SendAttachmentJoinHandle
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterSendAttachmentJoinHandleINSTANCE.Lift(_uniffiRV), nil
	}
}

func (_self *Timeline) SendVoiceMessage(params UploadParameters, audioInfo AudioInfo, waveform []uint16, progressWatcher *ProgressWatcher) (*SendAttachmentJoinHandle, error) {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[RoomError](FfiConverterRoomError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_method_timeline_send_voice_message(
			_pointer, FfiConverterUploadParametersINSTANCE.Lower(params), FfiConverterAudioInfoINSTANCE.Lower(audioInfo), FfiConverterSequenceUint16INSTANCE.Lower(waveform), FfiConverterOptionalCallbackInterfaceProgressWatcherINSTANCE.Lower(progressWatcher), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *SendAttachmentJoinHandle
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterSendAttachmentJoinHandleINSTANCE.Lift(_uniffiRV), nil
	}
}

func (_self *Timeline) SubscribeToBackPaginationStatus(listener PaginationStatusListener) (*TaskHandle, error) {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) unsafe.Pointer {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_pointer(handle, status)
			return res
		},
		// liftFn
		func(ffi unsafe.Pointer) *TaskHandle {
			return FfiConverterTaskHandleINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_timeline_subscribe_to_back_pagination_status(
			_pointer, FfiConverterCallbackInterfacePaginationStatusListenerINSTANCE.Lower(listener)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_pointer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_pointer(handle)
		},
	)

	return res, err
}

// Toggle a reaction on an event.
//
// Adds or redacts a reaction based on the state of the reaction at the
// time it is called.
//
// This method works both on local echoes and remote items.
//
// When redacting a previous reaction, the redaction reason is not set.
//
// Ensures that only one reaction is sent at a time to avoid race
// conditions and spamming the homeserver with requests.
func (_self *Timeline) ToggleReaction(itemId EventOrTransactionId, key string) error {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_timeline_toggle_reaction(
			_pointer, FfiConverterEventOrTransactionIdINSTANCE.Lower(itemId), FfiConverterStringINSTANCE.Lower(key)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// Adds a new pinned event by sending an updated `m.room.pinned_events`
// event without the event id we want to remove.
//
// Returns `true` if we sent the request, `false` if the event wasn't
// pinned
func (_self *Timeline) UnpinEvent(eventId string) (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*Timeline")
	defer _self.ffiObject.decrementPointer()
	res, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_timeline_unpin_event(
			_pointer, FfiConverterStringINSTANCE.Lower(eventId)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res, err
}
func (object *Timeline) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterTimeline struct{}

var FfiConverterTimelineINSTANCE = FfiConverterTimeline{}

func (c FfiConverterTimeline) Lift(pointer unsafe.Pointer) *Timeline {
	result := &Timeline{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_timeline(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_timeline(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*Timeline).Destroy)
	return result
}

func (c FfiConverterTimeline) Read(reader io.Reader) *Timeline {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterTimeline) Lower(value *Timeline) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Timeline")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterTimeline) Write(writer io.Writer, value *Timeline) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerTimeline struct{}

func (_ FfiDestroyerTimeline) Destroy(value *Timeline) {
	value.Destroy()
}

type TimelineDiffInterface interface {
	Append() *[]*TimelineItem
	Change() TimelineChange
	Insert() *InsertData
	PushBack() **TimelineItem
	PushFront() **TimelineItem
	Remove() *uint32
	Reset() *[]*TimelineItem
	Set() *SetData
	Truncate() *uint32
}
type TimelineDiff struct {
	ffiObject FfiObject
}

func (_self *TimelineDiff) Append() *[]*TimelineItem {
	_pointer := _self.ffiObject.incrementPointer("*TimelineDiff")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalSequenceTimelineItemINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_timelinediff_append(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *TimelineDiff) Change() TimelineChange {
	_pointer := _self.ffiObject.incrementPointer("*TimelineDiff")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTimelineChangeINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_timelinediff_change(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *TimelineDiff) Insert() *InsertData {
	_pointer := _self.ffiObject.incrementPointer("*TimelineDiff")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalInsertDataINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_timelinediff_insert(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *TimelineDiff) PushBack() **TimelineItem {
	_pointer := _self.ffiObject.incrementPointer("*TimelineDiff")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalTimelineItemINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_timelinediff_push_back(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *TimelineDiff) PushFront() **TimelineItem {
	_pointer := _self.ffiObject.incrementPointer("*TimelineDiff")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalTimelineItemINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_timelinediff_push_front(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *TimelineDiff) Remove() *uint32 {
	_pointer := _self.ffiObject.incrementPointer("*TimelineDiff")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalUint32INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_timelinediff_remove(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *TimelineDiff) Reset() *[]*TimelineItem {
	_pointer := _self.ffiObject.incrementPointer("*TimelineDiff")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalSequenceTimelineItemINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_timelinediff_reset(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *TimelineDiff) Set() *SetData {
	_pointer := _self.ffiObject.incrementPointer("*TimelineDiff")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalSetDataINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_timelinediff_set(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *TimelineDiff) Truncate() *uint32 {
	_pointer := _self.ffiObject.incrementPointer("*TimelineDiff")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalUint32INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_timelinediff_truncate(
				_pointer, _uniffiStatus),
		}
	}))
}
func (object *TimelineDiff) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterTimelineDiff struct{}

var FfiConverterTimelineDiffINSTANCE = FfiConverterTimelineDiff{}

func (c FfiConverterTimelineDiff) Lift(pointer unsafe.Pointer) *TimelineDiff {
	result := &TimelineDiff{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_timelinediff(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_timelinediff(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*TimelineDiff).Destroy)
	return result
}

func (c FfiConverterTimelineDiff) Read(reader io.Reader) *TimelineDiff {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterTimelineDiff) Lower(value *TimelineDiff) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*TimelineDiff")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterTimelineDiff) Write(writer io.Writer, value *TimelineDiff) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerTimelineDiff struct{}

func (_ FfiDestroyerTimelineDiff) Destroy(value *TimelineDiff) {
	value.Destroy()
}

type TimelineEventInterface interface {
	EventId() string
	EventType() (TimelineEventType, error)
	SenderId() string
	Timestamp() Timestamp
}
type TimelineEvent struct {
	ffiObject FfiObject
}

func (_self *TimelineEvent) EventId() string {
	_pointer := _self.ffiObject.incrementPointer("*TimelineEvent")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_id(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *TimelineEvent) EventType() (TimelineEventType, error) {
	_pointer := _self.ffiObject.incrementPointer("*TimelineEvent")
	defer _self.ffiObject.decrementPointer()
	_uniffiRV, _uniffiErr := rustCallWithError[ClientError](FfiConverterClientError{}, func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_type(
				_pointer, _uniffiStatus),
		}
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue TimelineEventType
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterTimelineEventTypeINSTANCE.Lift(_uniffiRV), nil
	}
}

func (_self *TimelineEvent) SenderId() string {
	_pointer := _self.ffiObject.incrementPointer("*TimelineEvent")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_timelineevent_sender_id(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *TimelineEvent) Timestamp() Timestamp {
	_pointer := _self.ffiObject.incrementPointer("*TimelineEvent")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTypeTimestampINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_timelineevent_timestamp(
			_pointer, _uniffiStatus)
	}))
}
func (object *TimelineEvent) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterTimelineEvent struct{}

var FfiConverterTimelineEventINSTANCE = FfiConverterTimelineEvent{}

func (c FfiConverterTimelineEvent) Lift(pointer unsafe.Pointer) *TimelineEvent {
	result := &TimelineEvent{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_timelineevent(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_timelineevent(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*TimelineEvent).Destroy)
	return result
}

func (c FfiConverterTimelineEvent) Read(reader io.Reader) *TimelineEvent {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterTimelineEvent) Lower(value *TimelineEvent) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*TimelineEvent")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterTimelineEvent) Write(writer io.Writer, value *TimelineEvent) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerTimelineEvent struct{}

func (_ FfiDestroyerTimelineEvent) Destroy(value *TimelineEvent) {
	value.Destroy()
}

type TimelineEventTypeFilterInterface interface {
}
type TimelineEventTypeFilter struct {
	ffiObject FfiObject
}

func TimelineEventTypeFilterExclude(eventTypes []FilterTimelineEventType) *TimelineEventTypeFilter {
	return FfiConverterTimelineEventTypeFilterINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_constructor_timelineeventtypefilter_exclude(FfiConverterSequenceFilterTimelineEventTypeINSTANCE.Lower(eventTypes), _uniffiStatus)
	}))
}

func TimelineEventTypeFilterInclude(eventTypes []FilterTimelineEventType) *TimelineEventTypeFilter {
	return FfiConverterTimelineEventTypeFilterINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_constructor_timelineeventtypefilter_include(FfiConverterSequenceFilterTimelineEventTypeINSTANCE.Lower(eventTypes), _uniffiStatus)
	}))
}

func (object *TimelineEventTypeFilter) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterTimelineEventTypeFilter struct{}

var FfiConverterTimelineEventTypeFilterINSTANCE = FfiConverterTimelineEventTypeFilter{}

func (c FfiConverterTimelineEventTypeFilter) Lift(pointer unsafe.Pointer) *TimelineEventTypeFilter {
	result := &TimelineEventTypeFilter{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_timelineeventtypefilter(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_timelineeventtypefilter(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*TimelineEventTypeFilter).Destroy)
	return result
}

func (c FfiConverterTimelineEventTypeFilter) Read(reader io.Reader) *TimelineEventTypeFilter {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterTimelineEventTypeFilter) Lower(value *TimelineEventTypeFilter) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*TimelineEventTypeFilter")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterTimelineEventTypeFilter) Write(writer io.Writer, value *TimelineEventTypeFilter) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerTimelineEventTypeFilter struct{}

func (_ FfiDestroyerTimelineEventTypeFilter) Destroy(value *TimelineEventTypeFilter) {
	value.Destroy()
}

type TimelineItemInterface interface {
	AsEvent() *EventTimelineItem
	AsVirtual() *VirtualTimelineItem
	FmtDebug() string
	// An opaque unique identifier for this timeline item.
	UniqueId() TimelineUniqueId
}
type TimelineItem struct {
	ffiObject FfiObject
}

func (_self *TimelineItem) AsEvent() *EventTimelineItem {
	_pointer := _self.ffiObject.incrementPointer("*TimelineItem")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalEventTimelineItemINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_event(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *TimelineItem) AsVirtual() *VirtualTimelineItem {
	_pointer := _self.ffiObject.incrementPointer("*TimelineItem")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalVirtualTimelineItemINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_virtual(
				_pointer, _uniffiStatus),
		}
	}))
}

func (_self *TimelineItem) FmtDebug() string {
	_pointer := _self.ffiObject.incrementPointer("*TimelineItem")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_timelineitem_fmt_debug(
				_pointer, _uniffiStatus),
		}
	}))
}

// An opaque unique identifier for this timeline item.
func (_self *TimelineItem) UniqueId() TimelineUniqueId {
	_pointer := _self.ffiObject.incrementPointer("*TimelineItem")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterTimelineUniqueIdINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_timelineitem_unique_id(
				_pointer, _uniffiStatus),
		}
	}))
}
func (object *TimelineItem) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterTimelineItem struct{}

var FfiConverterTimelineItemINSTANCE = FfiConverterTimelineItem{}

func (c FfiConverterTimelineItem) Lift(pointer unsafe.Pointer) *TimelineItem {
	result := &TimelineItem{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_timelineitem(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_timelineitem(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*TimelineItem).Destroy)
	return result
}

func (c FfiConverterTimelineItem) Read(reader io.Reader) *TimelineItem {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterTimelineItem) Lower(value *TimelineItem) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*TimelineItem")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterTimelineItem) Write(writer io.Writer, value *TimelineItem) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerTimelineItem struct{}

func (_ FfiDestroyerTimelineItem) Destroy(value *TimelineItem) {
	value.Destroy()
}

type UnreadNotificationsCountInterface interface {
	HasNotifications() bool
	HighlightCount() uint32
	NotificationCount() uint32
}
type UnreadNotificationsCount struct {
	ffiObject FfiObject
}

func (_self *UnreadNotificationsCount) HasNotifications() bool {
	_pointer := _self.ffiObject.incrementPointer("*UnreadNotificationsCount")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_has_notifications(
			_pointer, _uniffiStatus)
	}))
}

func (_self *UnreadNotificationsCount) HighlightCount() uint32 {
	_pointer := _self.ffiObject.incrementPointer("*UnreadNotificationsCount")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint32INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint32_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_highlight_count(
			_pointer, _uniffiStatus)
	}))
}

func (_self *UnreadNotificationsCount) NotificationCount() uint32 {
	_pointer := _self.ffiObject.incrementPointer("*UnreadNotificationsCount")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterUint32INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint32_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_notification_count(
			_pointer, _uniffiStatus)
	}))
}
func (object *UnreadNotificationsCount) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterUnreadNotificationsCount struct{}

var FfiConverterUnreadNotificationsCountINSTANCE = FfiConverterUnreadNotificationsCount{}

func (c FfiConverterUnreadNotificationsCount) Lift(pointer unsafe.Pointer) *UnreadNotificationsCount {
	result := &UnreadNotificationsCount{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_unreadnotificationscount(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_unreadnotificationscount(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*UnreadNotificationsCount).Destroy)
	return result
}

func (c FfiConverterUnreadNotificationsCount) Read(reader io.Reader) *UnreadNotificationsCount {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterUnreadNotificationsCount) Lower(value *UnreadNotificationsCount) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*UnreadNotificationsCount")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterUnreadNotificationsCount) Write(writer io.Writer, value *UnreadNotificationsCount) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerUnreadNotificationsCount struct{}

func (_ FfiDestroyerUnreadNotificationsCount) Destroy(value *UnreadNotificationsCount) {
	value.Destroy()
}

// The E2EE identity of a user.
type UserIdentityInterface interface {
	// Was this identity previously verified, and is no longer?
	HasVerificationViolation() bool
	// Is the user identity considered to be verified.
	//
	// If the identity belongs to another user, our own user identity needs to
	// be verified as well for the identity to be considered to be verified.
	IsVerified() bool
	// Get the public part of the Master key of this user identity.
	//
	// The public part of the Master key is usually used to uniquely identify
	// the identity.
	//
	// Returns None if the master key does not actually contain any keys.
	MasterKey() *string
	// Remember this identity, ensuring it does not result in a pin violation.
	//
	// When we first see a user, we assume their cryptographic identity has not
	// been tampered with by the homeserver or another entity with
	// man-in-the-middle capabilities. We remember this identity and call this
	// action "pinning".
	//
	// If the identity presented for the user changes later on, the newly
	// presented identity is considered to be in "pin violation". This
	// method explicitly accepts the new identity, allowing it to replace
	// the previously pinned one and bringing it out of pin violation.
	//
	// UIs should display a warning to the user when encountering an identity
	// which is not verified and is in pin violation.
	Pin() error
	// True if we verified this identity at some point in the past.
	//
	// To reset this latch back to `false`, one must call
	// [`UserIdentity::withdraw_verification()`].
	WasPreviouslyVerified() bool
	// Remove the requirement for this identity to be verified.
	//
	// If an identity was previously verified and is not anymore it will be
	// reported to the user. In order to remove this notice users have to
	// verify again or to withdraw the verification requirement.
	WithdrawVerification() error
}

// The E2EE identity of a user.
type UserIdentity struct {
	ffiObject FfiObject
}

// Was this identity previously verified, and is no longer?
func (_self *UserIdentity) HasVerificationViolation() bool {
	_pointer := _self.ffiObject.incrementPointer("*UserIdentity")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_useridentity_has_verification_violation(
			_pointer, _uniffiStatus)
	}))
}

// Is the user identity considered to be verified.
//
// If the identity belongs to another user, our own user identity needs to
// be verified as well for the identity to be considered to be verified.
func (_self *UserIdentity) IsVerified() bool {
	_pointer := _self.ffiObject.incrementPointer("*UserIdentity")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_useridentity_is_verified(
			_pointer, _uniffiStatus)
	}))
}

// Get the public part of the Master key of this user identity.
//
// The public part of the Master key is usually used to uniquely identify
// the identity.
//
// Returns None if the master key does not actually contain any keys.
func (_self *UserIdentity) MasterKey() *string {
	_pointer := _self.ffiObject.incrementPointer("*UserIdentity")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterOptionalStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_method_useridentity_master_key(
				_pointer, _uniffiStatus),
		}
	}))
}

// Remember this identity, ensuring it does not result in a pin violation.
//
// When we first see a user, we assume their cryptographic identity has not
// been tampered with by the homeserver or another entity with
// man-in-the-middle capabilities. We remember this identity and call this
// action "pinning".
//
// If the identity presented for the user changes later on, the newly
// presented identity is considered to be in "pin violation". This
// method explicitly accepts the new identity, allowing it to replace
// the previously pinned one and bringing it out of pin violation.
//
// UIs should display a warning to the user when encountering an identity
// which is not verified and is in pin violation.
func (_self *UserIdentity) Pin() error {
	_pointer := _self.ffiObject.incrementPointer("*UserIdentity")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_useridentity_pin(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}

// True if we verified this identity at some point in the past.
//
// To reset this latch back to `false`, one must call
// [`UserIdentity::withdraw_verification()`].
func (_self *UserIdentity) WasPreviouslyVerified() bool {
	_pointer := _self.ffiObject.incrementPointer("*UserIdentity")
	defer _self.ffiObject.decrementPointer()
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_matrix_sdk_ffi_fn_method_useridentity_was_previously_verified(
			_pointer, _uniffiStatus)
	}))
}

// Remove the requirement for this identity to be verified.
//
// If an identity was previously verified and is not anymore it will be
// reported to the user. In order to remove this notice users have to
// verify again or to withdraw the verification requirement.
func (_self *UserIdentity) WithdrawVerification() error {
	_pointer := _self.ffiObject.incrementPointer("*UserIdentity")
	defer _self.ffiObject.decrementPointer()
	_, err := uniffiRustCallAsync[ClientError](
		FfiConverterClientErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_useridentity_withdraw_verification(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

	return err
}
func (object *UserIdentity) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterUserIdentity struct{}

var FfiConverterUserIdentityINSTANCE = FfiConverterUserIdentity{}

func (c FfiConverterUserIdentity) Lift(pointer unsafe.Pointer) *UserIdentity {
	result := &UserIdentity{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_useridentity(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_useridentity(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*UserIdentity).Destroy)
	return result
}

func (c FfiConverterUserIdentity) Read(reader io.Reader) *UserIdentity {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterUserIdentity) Lower(value *UserIdentity) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*UserIdentity")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterUserIdentity) Write(writer io.Writer, value *UserIdentity) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerUserIdentity struct{}

func (_ FfiDestroyerUserIdentity) Destroy(value *UserIdentity) {
	value.Destroy()
}

// An object that handles all interactions of a widget living inside a webview
// or IFrame with the Matrix world.
type WidgetDriverInterface interface {
	Run(room *Room, capabilitiesProvider WidgetCapabilitiesProvider)
}

// An object that handles all interactions of a widget living inside a webview
// or IFrame with the Matrix world.
type WidgetDriver struct {
	ffiObject FfiObject
}

func (_self *WidgetDriver) Run(room *Room, capabilitiesProvider WidgetCapabilitiesProvider) {
	_pointer := _self.ffiObject.incrementPointer("*WidgetDriver")
	defer _self.ffiObject.decrementPointer()
	uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) struct{} {
			C.ffi_matrix_sdk_ffi_rust_future_complete_void(handle, status)
			return struct{}{}
		},
		// liftFn
		func(_ struct{}) struct{} { return struct{}{} },
		C.uniffi_matrix_sdk_ffi_fn_method_widgetdriver_run(
			_pointer, FfiConverterRoomINSTANCE.Lower(room), FfiConverterCallbackInterfaceWidgetCapabilitiesProviderINSTANCE.Lower(capabilitiesProvider)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_void(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_void(handle)
		},
	)

}
func (object *WidgetDriver) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterWidgetDriver struct{}

var FfiConverterWidgetDriverINSTANCE = FfiConverterWidgetDriver{}

func (c FfiConverterWidgetDriver) Lift(pointer unsafe.Pointer) *WidgetDriver {
	result := &WidgetDriver{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_widgetdriver(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_widgetdriver(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*WidgetDriver).Destroy)
	return result
}

func (c FfiConverterWidgetDriver) Read(reader io.Reader) *WidgetDriver {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterWidgetDriver) Lower(value *WidgetDriver) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*WidgetDriver")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterWidgetDriver) Write(writer io.Writer, value *WidgetDriver) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerWidgetDriver struct{}

func (_ FfiDestroyerWidgetDriver) Destroy(value *WidgetDriver) {
	value.Destroy()
}

// A handle that encapsulates the communication between a widget driver and the
// corresponding widget (inside a webview or IFrame).
type WidgetDriverHandleInterface interface {
	// Receive a message from the widget driver.
	//
	// The message must be passed on to the widget.
	//
	// Returns `None` if the widget driver is no longer running.
	Recv() *string
	//
	// Returns `false` if the widget driver is no longer running.
	Send(msg string) bool
}

// A handle that encapsulates the communication between a widget driver and the
// corresponding widget (inside a webview or IFrame).
type WidgetDriverHandle struct {
	ffiObject FfiObject
}

// Receive a message from the widget driver.
//
// The message must be passed on to the widget.
//
// Returns `None` if the widget driver is no longer running.
func (_self *WidgetDriverHandle) Recv() *string {
	_pointer := _self.ffiObject.incrementPointer("*WidgetDriverHandle")
	defer _self.ffiObject.decrementPointer()
	res, _ := uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) *string {
			return FfiConverterOptionalStringINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_widgetdriverhandle_recv(
			_pointer),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res
}

// Returns `false` if the widget driver is no longer running.
func (_self *WidgetDriverHandle) Send(msg string) bool {
	_pointer := _self.ffiObject.incrementPointer("*WidgetDriverHandle")
	defer _self.ffiObject.decrementPointer()
	res, _ := uniffiRustCallAsync[error](
		nil,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) C.int8_t {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_i8(handle, status)
			return res
		},
		// liftFn
		func(ffi C.int8_t) bool {
			return FfiConverterBoolINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_method_widgetdriverhandle_send(
			_pointer, FfiConverterStringINSTANCE.Lower(msg)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_i8(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_i8(handle)
		},
	)

	return res
}
func (object *WidgetDriverHandle) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterWidgetDriverHandle struct{}

var FfiConverterWidgetDriverHandleINSTANCE = FfiConverterWidgetDriverHandle{}

func (c FfiConverterWidgetDriverHandle) Lift(pointer unsafe.Pointer) *WidgetDriverHandle {
	result := &WidgetDriverHandle{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) unsafe.Pointer {
				return C.uniffi_matrix_sdk_ffi_fn_clone_widgetdriverhandle(pointer, status)
			},
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.uniffi_matrix_sdk_ffi_fn_free_widgetdriverhandle(pointer, status)
			},
		),
	}
	runtime.SetFinalizer(result, (*WidgetDriverHandle).Destroy)
	return result
}

func (c FfiConverterWidgetDriverHandle) Read(reader io.Reader) *WidgetDriverHandle {
	return c.Lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterWidgetDriverHandle) Lower(value *WidgetDriverHandle) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*WidgetDriverHandle")
	defer value.ffiObject.decrementPointer()
	return pointer

}

func (c FfiConverterWidgetDriverHandle) Write(writer io.Writer, value *WidgetDriverHandle) {
	writeUint64(writer, uint64(uintptr(c.Lower(value))))
}

type FfiDestroyerWidgetDriverHandle struct{}

func (_ FfiDestroyerWidgetDriverHandle) Destroy(value *WidgetDriverHandle) {
	value.Destroy()
}

type AudioInfo struct {
	Duration *time.Duration
	Size     *uint64
	Mimetype *string
}

func (r *AudioInfo) Destroy() {
	FfiDestroyerOptionalDuration{}.Destroy(r.Duration)
	FfiDestroyerOptionalUint64{}.Destroy(r.Size)
	FfiDestroyerOptionalString{}.Destroy(r.Mimetype)
}

type FfiConverterAudioInfo struct{}

var FfiConverterAudioInfoINSTANCE = FfiConverterAudioInfo{}

func (c FfiConverterAudioInfo) Lift(rb RustBufferI) AudioInfo {
	return LiftFromRustBuffer[AudioInfo](c, rb)
}

func (c FfiConverterAudioInfo) Read(reader io.Reader) AudioInfo {
	return AudioInfo{
		FfiConverterOptionalDurationINSTANCE.Read(reader),
		FfiConverterOptionalUint64INSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterAudioInfo) Lower(value AudioInfo) C.RustBuffer {
	return LowerIntoRustBuffer[AudioInfo](c, value)
}

func (c FfiConverterAudioInfo) Write(writer io.Writer, value AudioInfo) {
	FfiConverterOptionalDurationINSTANCE.Write(writer, value.Duration)
	FfiConverterOptionalUint64INSTANCE.Write(writer, value.Size)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Mimetype)
}

type FfiDestroyerAudioInfo struct{}

func (_ FfiDestroyerAudioInfo) Destroy(value AudioInfo) {
	value.Destroy()
}

type AudioMessageContent struct {
	// The computed filename, for use in a client.
	Filename         string
	Caption          *string
	FormattedCaption *FormattedBody
	Source           *MediaSource
	Info             *AudioInfo
	Audio            *UnstableAudioDetailsContent
	Voice            *UnstableVoiceContent
}

func (r *AudioMessageContent) Destroy() {
	FfiDestroyerString{}.Destroy(r.Filename)
	FfiDestroyerOptionalString{}.Destroy(r.Caption)
	FfiDestroyerOptionalFormattedBody{}.Destroy(r.FormattedCaption)
	FfiDestroyerMediaSource{}.Destroy(r.Source)
	FfiDestroyerOptionalAudioInfo{}.Destroy(r.Info)
	FfiDestroyerOptionalUnstableAudioDetailsContent{}.Destroy(r.Audio)
	FfiDestroyerOptionalUnstableVoiceContent{}.Destroy(r.Voice)
}

type FfiConverterAudioMessageContent struct{}

var FfiConverterAudioMessageContentINSTANCE = FfiConverterAudioMessageContent{}

func (c FfiConverterAudioMessageContent) Lift(rb RustBufferI) AudioMessageContent {
	return LiftFromRustBuffer[AudioMessageContent](c, rb)
}

func (c FfiConverterAudioMessageContent) Read(reader io.Reader) AudioMessageContent {
	return AudioMessageContent{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalFormattedBodyINSTANCE.Read(reader),
		FfiConverterMediaSourceINSTANCE.Read(reader),
		FfiConverterOptionalAudioInfoINSTANCE.Read(reader),
		FfiConverterOptionalUnstableAudioDetailsContentINSTANCE.Read(reader),
		FfiConverterOptionalUnstableVoiceContentINSTANCE.Read(reader),
	}
}

func (c FfiConverterAudioMessageContent) Lower(value AudioMessageContent) C.RustBuffer {
	return LowerIntoRustBuffer[AudioMessageContent](c, value)
}

func (c FfiConverterAudioMessageContent) Write(writer io.Writer, value AudioMessageContent) {
	FfiConverterStringINSTANCE.Write(writer, value.Filename)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Caption)
	FfiConverterOptionalFormattedBodyINSTANCE.Write(writer, value.FormattedCaption)
	FfiConverterMediaSourceINSTANCE.Write(writer, value.Source)
	FfiConverterOptionalAudioInfoINSTANCE.Write(writer, value.Info)
	FfiConverterOptionalUnstableAudioDetailsContentINSTANCE.Write(writer, value.Audio)
	FfiConverterOptionalUnstableVoiceContentINSTANCE.Write(writer, value.Voice)
}

type FfiDestroyerAudioMessageContent struct{}

func (_ FfiDestroyerAudioMessageContent) Destroy(value AudioMessageContent) {
	value.Destroy()
}

type AuthDataPasswordDetails struct {
	// One of the user's identifiers.
	Identifier string
	// The plaintext password.
	Password string
}

func (r *AuthDataPasswordDetails) Destroy() {
	FfiDestroyerString{}.Destroy(r.Identifier)
	FfiDestroyerString{}.Destroy(r.Password)
}

type FfiConverterAuthDataPasswordDetails struct{}

var FfiConverterAuthDataPasswordDetailsINSTANCE = FfiConverterAuthDataPasswordDetails{}

func (c FfiConverterAuthDataPasswordDetails) Lift(rb RustBufferI) AuthDataPasswordDetails {
	return LiftFromRustBuffer[AuthDataPasswordDetails](c, rb)
}

func (c FfiConverterAuthDataPasswordDetails) Read(reader io.Reader) AuthDataPasswordDetails {
	return AuthDataPasswordDetails{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterAuthDataPasswordDetails) Lower(value AuthDataPasswordDetails) C.RustBuffer {
	return LowerIntoRustBuffer[AuthDataPasswordDetails](c, value)
}

func (c FfiConverterAuthDataPasswordDetails) Write(writer io.Writer, value AuthDataPasswordDetails) {
	FfiConverterStringINSTANCE.Write(writer, value.Identifier)
	FfiConverterStringINSTANCE.Write(writer, value.Password)
}

type FfiDestroyerAuthDataPasswordDetails struct{}

func (_ FfiDestroyerAuthDataPasswordDetails) Destroy(value AuthDataPasswordDetails) {
	value.Destroy()
}

type ClientProperties struct {
	// The client_id provides the widget with the option to behave differently
	// for different clients. e.g org.example.ios.
	ClientId string
	// The language tag the client is set to e.g. en-us. (Undefined and invalid
	// becomes: `en-US`)
	LanguageTag *string
	// A string describing the theme (dark, light) or org.example.dark.
	// (default: `light`)
	Theme *string
}

func (r *ClientProperties) Destroy() {
	FfiDestroyerString{}.Destroy(r.ClientId)
	FfiDestroyerOptionalString{}.Destroy(r.LanguageTag)
	FfiDestroyerOptionalString{}.Destroy(r.Theme)
}

type FfiConverterClientProperties struct{}

var FfiConverterClientPropertiesINSTANCE = FfiConverterClientProperties{}

func (c FfiConverterClientProperties) Lift(rb RustBufferI) ClientProperties {
	return LiftFromRustBuffer[ClientProperties](c, rb)
}

func (c FfiConverterClientProperties) Read(reader io.Reader) ClientProperties {
	return ClientProperties{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterClientProperties) Lower(value ClientProperties) C.RustBuffer {
	return LowerIntoRustBuffer[ClientProperties](c, value)
}

func (c FfiConverterClientProperties) Write(writer io.Writer, value ClientProperties) {
	FfiConverterStringINSTANCE.Write(writer, value.ClientId)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.LanguageTag)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Theme)
}

type FfiDestroyerClientProperties struct{}

func (_ FfiDestroyerClientProperties) Destroy(value ClientProperties) {
	value.Destroy()
}

// Current draft of the composer for the room.
type ComposerDraft struct {
	// The draft content in plain text.
	PlainText string
	// If the message is formatted in HTML, the HTML representation of the
	// message.
	HtmlText *string
	// The type of draft.
	DraftType ComposerDraftType
}

func (r *ComposerDraft) Destroy() {
	FfiDestroyerString{}.Destroy(r.PlainText)
	FfiDestroyerOptionalString{}.Destroy(r.HtmlText)
	FfiDestroyerComposerDraftType{}.Destroy(r.DraftType)
}

type FfiConverterComposerDraft struct{}

var FfiConverterComposerDraftINSTANCE = FfiConverterComposerDraft{}

func (c FfiConverterComposerDraft) Lift(rb RustBufferI) ComposerDraft {
	return LiftFromRustBuffer[ComposerDraft](c, rb)
}

func (c FfiConverterComposerDraft) Read(reader io.Reader) ComposerDraft {
	return ComposerDraft{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterComposerDraftTypeINSTANCE.Read(reader),
	}
}

func (c FfiConverterComposerDraft) Lower(value ComposerDraft) C.RustBuffer {
	return LowerIntoRustBuffer[ComposerDraft](c, value)
}

func (c FfiConverterComposerDraft) Write(writer io.Writer, value ComposerDraft) {
	FfiConverterStringINSTANCE.Write(writer, value.PlainText)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.HtmlText)
	FfiConverterComposerDraftTypeINSTANCE.Write(writer, value.DraftType)
}

type FfiDestroyerComposerDraft struct{}

func (_ FfiDestroyerComposerDraft) Destroy(value ComposerDraft) {
	value.Destroy()
}

// Like [`SimplePushRule`], but with an additional `conditions` field.
type ConditionalPushRule struct {
	// Actions to determine if and how a notification is delivered for events
	// matching this rule.
	Actions []Action
	// Whether this is a default rule, or has been set explicitly.
	Default bool
	// Whether the push rule is enabled or not.
	Enabled bool
	// The ID of this rule.
	RuleId string
	// The conditions that must hold true for an event in order for a rule to
	// be applied to an event.
	//
	// A rule with no conditions always matches.
	Conditions []PushCondition
}

func (r *ConditionalPushRule) Destroy() {
	FfiDestroyerSequenceAction{}.Destroy(r.Actions)
	FfiDestroyerBool{}.Destroy(r.Default)
	FfiDestroyerBool{}.Destroy(r.Enabled)
	FfiDestroyerString{}.Destroy(r.RuleId)
	FfiDestroyerSequencePushCondition{}.Destroy(r.Conditions)
}

type FfiConverterConditionalPushRule struct{}

var FfiConverterConditionalPushRuleINSTANCE = FfiConverterConditionalPushRule{}

func (c FfiConverterConditionalPushRule) Lift(rb RustBufferI) ConditionalPushRule {
	return LiftFromRustBuffer[ConditionalPushRule](c, rb)
}

func (c FfiConverterConditionalPushRule) Read(reader io.Reader) ConditionalPushRule {
	return ConditionalPushRule{
		FfiConverterSequenceActionINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterSequencePushConditionINSTANCE.Read(reader),
	}
}

func (c FfiConverterConditionalPushRule) Lower(value ConditionalPushRule) C.RustBuffer {
	return LowerIntoRustBuffer[ConditionalPushRule](c, value)
}

func (c FfiConverterConditionalPushRule) Write(writer io.Writer, value ConditionalPushRule) {
	FfiConverterSequenceActionINSTANCE.Write(writer, value.Actions)
	FfiConverterBoolINSTANCE.Write(writer, value.Default)
	FfiConverterBoolINSTANCE.Write(writer, value.Enabled)
	FfiConverterStringINSTANCE.Write(writer, value.RuleId)
	FfiConverterSequencePushConditionINSTANCE.Write(writer, value.Conditions)
}

type FfiDestroyerConditionalPushRule struct{}

func (_ FfiDestroyerConditionalPushRule) Destroy(value ConditionalPushRule) {
	value.Destroy()
}

type CreateRoomParameters struct {
	Name                      *string
	Topic                     *string
	IsEncrypted               bool
	IsDirect                  bool
	Visibility                RoomVisibility
	Preset                    RoomPreset
	Invite                    *[]string
	Avatar                    *string
	PowerLevelContentOverride *PowerLevels
	JoinRuleOverride          *JoinRule
	HistoryVisibilityOverride *RoomHistoryVisibility
	CanonicalAlias            *string
}

func (r *CreateRoomParameters) Destroy() {
	FfiDestroyerOptionalString{}.Destroy(r.Name)
	FfiDestroyerOptionalString{}.Destroy(r.Topic)
	FfiDestroyerBool{}.Destroy(r.IsEncrypted)
	FfiDestroyerBool{}.Destroy(r.IsDirect)
	FfiDestroyerRoomVisibility{}.Destroy(r.Visibility)
	FfiDestroyerRoomPreset{}.Destroy(r.Preset)
	FfiDestroyerOptionalSequenceString{}.Destroy(r.Invite)
	FfiDestroyerOptionalString{}.Destroy(r.Avatar)
	FfiDestroyerOptionalPowerLevels{}.Destroy(r.PowerLevelContentOverride)
	FfiDestroyerOptionalJoinRule{}.Destroy(r.JoinRuleOverride)
	FfiDestroyerOptionalRoomHistoryVisibility{}.Destroy(r.HistoryVisibilityOverride)
	FfiDestroyerOptionalString{}.Destroy(r.CanonicalAlias)
}

type FfiConverterCreateRoomParameters struct{}

var FfiConverterCreateRoomParametersINSTANCE = FfiConverterCreateRoomParameters{}

func (c FfiConverterCreateRoomParameters) Lift(rb RustBufferI) CreateRoomParameters {
	return LiftFromRustBuffer[CreateRoomParameters](c, rb)
}

func (c FfiConverterCreateRoomParameters) Read(reader io.Reader) CreateRoomParameters {
	return CreateRoomParameters{
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterRoomVisibilityINSTANCE.Read(reader),
		FfiConverterRoomPresetINSTANCE.Read(reader),
		FfiConverterOptionalSequenceStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalPowerLevelsINSTANCE.Read(reader),
		FfiConverterOptionalJoinRuleINSTANCE.Read(reader),
		FfiConverterOptionalRoomHistoryVisibilityINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterCreateRoomParameters) Lower(value CreateRoomParameters) C.RustBuffer {
	return LowerIntoRustBuffer[CreateRoomParameters](c, value)
}

func (c FfiConverterCreateRoomParameters) Write(writer io.Writer, value CreateRoomParameters) {
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Name)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Topic)
	FfiConverterBoolINSTANCE.Write(writer, value.IsEncrypted)
	FfiConverterBoolINSTANCE.Write(writer, value.IsDirect)
	FfiConverterRoomVisibilityINSTANCE.Write(writer, value.Visibility)
	FfiConverterRoomPresetINSTANCE.Write(writer, value.Preset)
	FfiConverterOptionalSequenceStringINSTANCE.Write(writer, value.Invite)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Avatar)
	FfiConverterOptionalPowerLevelsINSTANCE.Write(writer, value.PowerLevelContentOverride)
	FfiConverterOptionalJoinRuleINSTANCE.Write(writer, value.JoinRuleOverride)
	FfiConverterOptionalRoomHistoryVisibilityINSTANCE.Write(writer, value.HistoryVisibilityOverride)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.CanonicalAlias)
}

type FfiDestroyerCreateRoomParameters struct{}

func (_ FfiDestroyerCreateRoomParameters) Destroy(value CreateRoomParameters) {
	value.Destroy()
}

// Well-known settings specific to ElementCall
type ElementCallWellKnown struct {
	WidgetUrl string
}

func (r *ElementCallWellKnown) Destroy() {
	FfiDestroyerString{}.Destroy(r.WidgetUrl)
}

type FfiConverterElementCallWellKnown struct{}

var FfiConverterElementCallWellKnownINSTANCE = FfiConverterElementCallWellKnown{}

func (c FfiConverterElementCallWellKnown) Lift(rb RustBufferI) ElementCallWellKnown {
	return LiftFromRustBuffer[ElementCallWellKnown](c, rb)
}

func (c FfiConverterElementCallWellKnown) Read(reader io.Reader) ElementCallWellKnown {
	return ElementCallWellKnown{
		FfiConverterStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterElementCallWellKnown) Lower(value ElementCallWellKnown) C.RustBuffer {
	return LowerIntoRustBuffer[ElementCallWellKnown](c, value)
}

func (c FfiConverterElementCallWellKnown) Write(writer io.Writer, value ElementCallWellKnown) {
	FfiConverterStringINSTANCE.Write(writer, value.WidgetUrl)
}

type FfiDestroyerElementCallWellKnown struct{}

func (_ FfiDestroyerElementCallWellKnown) Destroy(value ElementCallWellKnown) {
	value.Destroy()
}

// Element specific well-known settings
type ElementWellKnown struct {
	Call                  *ElementCallWellKnown
	RegistrationHelperUrl *string
}

func (r *ElementWellKnown) Destroy() {
	FfiDestroyerOptionalElementCallWellKnown{}.Destroy(r.Call)
	FfiDestroyerOptionalString{}.Destroy(r.RegistrationHelperUrl)
}

type FfiConverterElementWellKnown struct{}

var FfiConverterElementWellKnownINSTANCE = FfiConverterElementWellKnown{}

func (c FfiConverterElementWellKnown) Lift(rb RustBufferI) ElementWellKnown {
	return LiftFromRustBuffer[ElementWellKnown](c, rb)
}

func (c FfiConverterElementWellKnown) Read(reader io.Reader) ElementWellKnown {
	return ElementWellKnown{
		FfiConverterOptionalElementCallWellKnownINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterElementWellKnown) Lower(value ElementWellKnown) C.RustBuffer {
	return LowerIntoRustBuffer[ElementWellKnown](c, value)
}

func (c FfiConverterElementWellKnown) Write(writer io.Writer, value ElementWellKnown) {
	FfiConverterOptionalElementCallWellKnownINSTANCE.Write(writer, value.Call)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.RegistrationHelperUrl)
}

type FfiDestroyerElementWellKnown struct{}

func (_ FfiDestroyerElementWellKnown) Destroy(value ElementWellKnown) {
	value.Destroy()
}

type EmoteMessageContent struct {
	Body      string
	Formatted *FormattedBody
}

func (r *EmoteMessageContent) Destroy() {
	FfiDestroyerString{}.Destroy(r.Body)
	FfiDestroyerOptionalFormattedBody{}.Destroy(r.Formatted)
}

type FfiConverterEmoteMessageContent struct{}

var FfiConverterEmoteMessageContentINSTANCE = FfiConverterEmoteMessageContent{}

func (c FfiConverterEmoteMessageContent) Lift(rb RustBufferI) EmoteMessageContent {
	return LiftFromRustBuffer[EmoteMessageContent](c, rb)
}

func (c FfiConverterEmoteMessageContent) Read(reader io.Reader) EmoteMessageContent {
	return EmoteMessageContent{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalFormattedBodyINSTANCE.Read(reader),
	}
}

func (c FfiConverterEmoteMessageContent) Lower(value EmoteMessageContent) C.RustBuffer {
	return LowerIntoRustBuffer[EmoteMessageContent](c, value)
}

func (c FfiConverterEmoteMessageContent) Write(writer io.Writer, value EmoteMessageContent) {
	FfiConverterStringINSTANCE.Write(writer, value.Body)
	FfiConverterOptionalFormattedBodyINSTANCE.Write(writer, value.Formatted)
}

type FfiDestroyerEmoteMessageContent struct{}

func (_ FfiDestroyerEmoteMessageContent) Destroy(value EmoteMessageContent) {
	value.Destroy()
}

type EventTimelineItem struct {
	// Indicates that an event is remote.
	IsRemote             bool
	EventOrTransactionId EventOrTransactionId
	Sender               string
	SenderProfile        ProfileDetails
	IsOwn                bool
	IsEditable           bool
	Content              TimelineItemContent
	Timestamp            Timestamp
	LocalSendState       *EventSendState
	LocalCreatedAt       *uint64
	ReadReceipts         map[string]Receipt
	Origin               *matrix_sdk_ui.EventItemOrigin
	CanBeRepliedTo       bool
	LazyProvider         *LazyTimelineItemProvider
}

func (r *EventTimelineItem) Destroy() {
	FfiDestroyerBool{}.Destroy(r.IsRemote)
	FfiDestroyerEventOrTransactionId{}.Destroy(r.EventOrTransactionId)
	FfiDestroyerString{}.Destroy(r.Sender)
	FfiDestroyerProfileDetails{}.Destroy(r.SenderProfile)
	FfiDestroyerBool{}.Destroy(r.IsOwn)
	FfiDestroyerBool{}.Destroy(r.IsEditable)
	FfiDestroyerTimelineItemContent{}.Destroy(r.Content)
	FfiDestroyerTypeTimestamp{}.Destroy(r.Timestamp)
	FfiDestroyerOptionalEventSendState{}.Destroy(r.LocalSendState)
	FfiDestroyerOptionalUint64{}.Destroy(r.LocalCreatedAt)
	FfiDestroyerMapStringReceipt{}.Destroy(r.ReadReceipts)
	FfiDestroyerOptionalEventItemOrigin{}.Destroy(r.Origin)
	FfiDestroyerBool{}.Destroy(r.CanBeRepliedTo)
	FfiDestroyerLazyTimelineItemProvider{}.Destroy(r.LazyProvider)
}

type FfiConverterEventTimelineItem struct{}

var FfiConverterEventTimelineItemINSTANCE = FfiConverterEventTimelineItem{}

func (c FfiConverterEventTimelineItem) Lift(rb RustBufferI) EventTimelineItem {
	return LiftFromRustBuffer[EventTimelineItem](c, rb)
}

func (c FfiConverterEventTimelineItem) Read(reader io.Reader) EventTimelineItem {
	return EventTimelineItem{
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterEventOrTransactionIdINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterProfileDetailsINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterTimelineItemContentINSTANCE.Read(reader),
		FfiConverterTypeTimestampINSTANCE.Read(reader),
		FfiConverterOptionalEventSendStateINSTANCE.Read(reader),
		FfiConverterOptionalUint64INSTANCE.Read(reader),
		FfiConverterMapStringReceiptINSTANCE.Read(reader),
		FfiConverterOptionalEventItemOriginINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterLazyTimelineItemProviderINSTANCE.Read(reader),
	}
}

func (c FfiConverterEventTimelineItem) Lower(value EventTimelineItem) C.RustBuffer {
	return LowerIntoRustBuffer[EventTimelineItem](c, value)
}

func (c FfiConverterEventTimelineItem) Write(writer io.Writer, value EventTimelineItem) {
	FfiConverterBoolINSTANCE.Write(writer, value.IsRemote)
	FfiConverterEventOrTransactionIdINSTANCE.Write(writer, value.EventOrTransactionId)
	FfiConverterStringINSTANCE.Write(writer, value.Sender)
	FfiConverterProfileDetailsINSTANCE.Write(writer, value.SenderProfile)
	FfiConverterBoolINSTANCE.Write(writer, value.IsOwn)
	FfiConverterBoolINSTANCE.Write(writer, value.IsEditable)
	FfiConverterTimelineItemContentINSTANCE.Write(writer, value.Content)
	FfiConverterTypeTimestampINSTANCE.Write(writer, value.Timestamp)
	FfiConverterOptionalEventSendStateINSTANCE.Write(writer, value.LocalSendState)
	FfiConverterOptionalUint64INSTANCE.Write(writer, value.LocalCreatedAt)
	FfiConverterMapStringReceiptINSTANCE.Write(writer, value.ReadReceipts)
	FfiConverterOptionalEventItemOriginINSTANCE.Write(writer, value.Origin)
	FfiConverterBoolINSTANCE.Write(writer, value.CanBeRepliedTo)
	FfiConverterLazyTimelineItemProviderINSTANCE.Write(writer, value.LazyProvider)
}

type FfiDestroyerEventTimelineItem struct{}

func (_ FfiDestroyerEventTimelineItem) Destroy(value EventTimelineItem) {
	value.Destroy()
}

type EventTimelineItemDebugInfo struct {
	Model          string
	OriginalJson   *string
	LatestEditJson *string
}

func (r *EventTimelineItemDebugInfo) Destroy() {
	FfiDestroyerString{}.Destroy(r.Model)
	FfiDestroyerOptionalString{}.Destroy(r.OriginalJson)
	FfiDestroyerOptionalString{}.Destroy(r.LatestEditJson)
}

type FfiConverterEventTimelineItemDebugInfo struct{}

var FfiConverterEventTimelineItemDebugInfoINSTANCE = FfiConverterEventTimelineItemDebugInfo{}

func (c FfiConverterEventTimelineItemDebugInfo) Lift(rb RustBufferI) EventTimelineItemDebugInfo {
	return LiftFromRustBuffer[EventTimelineItemDebugInfo](c, rb)
}

func (c FfiConverterEventTimelineItemDebugInfo) Read(reader io.Reader) EventTimelineItemDebugInfo {
	return EventTimelineItemDebugInfo{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterEventTimelineItemDebugInfo) Lower(value EventTimelineItemDebugInfo) C.RustBuffer {
	return LowerIntoRustBuffer[EventTimelineItemDebugInfo](c, value)
}

func (c FfiConverterEventTimelineItemDebugInfo) Write(writer io.Writer, value EventTimelineItemDebugInfo) {
	FfiConverterStringINSTANCE.Write(writer, value.Model)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.OriginalJson)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.LatestEditJson)
}

type FfiDestroyerEventTimelineItemDebugInfo struct{}

func (_ FfiDestroyerEventTimelineItemDebugInfo) Destroy(value EventTimelineItemDebugInfo) {
	value.Destroy()
}

type FileInfo struct {
	Mimetype        *string
	Size            *uint64
	ThumbnailInfo   *ThumbnailInfo
	ThumbnailSource **MediaSource
}

func (r *FileInfo) Destroy() {
	FfiDestroyerOptionalString{}.Destroy(r.Mimetype)
	FfiDestroyerOptionalUint64{}.Destroy(r.Size)
	FfiDestroyerOptionalThumbnailInfo{}.Destroy(r.ThumbnailInfo)
	FfiDestroyerOptionalMediaSource{}.Destroy(r.ThumbnailSource)
}

type FfiConverterFileInfo struct{}

var FfiConverterFileInfoINSTANCE = FfiConverterFileInfo{}

func (c FfiConverterFileInfo) Lift(rb RustBufferI) FileInfo {
	return LiftFromRustBuffer[FileInfo](c, rb)
}

func (c FfiConverterFileInfo) Read(reader io.Reader) FileInfo {
	return FileInfo{
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalUint64INSTANCE.Read(reader),
		FfiConverterOptionalThumbnailInfoINSTANCE.Read(reader),
		FfiConverterOptionalMediaSourceINSTANCE.Read(reader),
	}
}

func (c FfiConverterFileInfo) Lower(value FileInfo) C.RustBuffer {
	return LowerIntoRustBuffer[FileInfo](c, value)
}

func (c FfiConverterFileInfo) Write(writer io.Writer, value FileInfo) {
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Mimetype)
	FfiConverterOptionalUint64INSTANCE.Write(writer, value.Size)
	FfiConverterOptionalThumbnailInfoINSTANCE.Write(writer, value.ThumbnailInfo)
	FfiConverterOptionalMediaSourceINSTANCE.Write(writer, value.ThumbnailSource)
}

type FfiDestroyerFileInfo struct{}

func (_ FfiDestroyerFileInfo) Destroy(value FileInfo) {
	value.Destroy()
}

type FileMessageContent struct {
	// The computed filename, for use in a client.
	Filename         string
	Caption          *string
	FormattedCaption *FormattedBody
	Source           *MediaSource
	Info             *FileInfo
}

func (r *FileMessageContent) Destroy() {
	FfiDestroyerString{}.Destroy(r.Filename)
	FfiDestroyerOptionalString{}.Destroy(r.Caption)
	FfiDestroyerOptionalFormattedBody{}.Destroy(r.FormattedCaption)
	FfiDestroyerMediaSource{}.Destroy(r.Source)
	FfiDestroyerOptionalFileInfo{}.Destroy(r.Info)
}

type FfiConverterFileMessageContent struct{}

var FfiConverterFileMessageContentINSTANCE = FfiConverterFileMessageContent{}

func (c FfiConverterFileMessageContent) Lift(rb RustBufferI) FileMessageContent {
	return LiftFromRustBuffer[FileMessageContent](c, rb)
}

func (c FfiConverterFileMessageContent) Read(reader io.Reader) FileMessageContent {
	return FileMessageContent{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalFormattedBodyINSTANCE.Read(reader),
		FfiConverterMediaSourceINSTANCE.Read(reader),
		FfiConverterOptionalFileInfoINSTANCE.Read(reader),
	}
}

func (c FfiConverterFileMessageContent) Lower(value FileMessageContent) C.RustBuffer {
	return LowerIntoRustBuffer[FileMessageContent](c, value)
}

func (c FfiConverterFileMessageContent) Write(writer io.Writer, value FileMessageContent) {
	FfiConverterStringINSTANCE.Write(writer, value.Filename)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Caption)
	FfiConverterOptionalFormattedBodyINSTANCE.Write(writer, value.FormattedCaption)
	FfiConverterMediaSourceINSTANCE.Write(writer, value.Source)
	FfiConverterOptionalFileInfoINSTANCE.Write(writer, value.Info)
}

type FfiDestroyerFileMessageContent struct{}

func (_ FfiDestroyerFileMessageContent) Destroy(value FileMessageContent) {
	value.Destroy()
}

type FormattedBody struct {
	Format MessageFormat
	Body   string
}

func (r *FormattedBody) Destroy() {
	FfiDestroyerMessageFormat{}.Destroy(r.Format)
	FfiDestroyerString{}.Destroy(r.Body)
}

type FfiConverterFormattedBody struct{}

var FfiConverterFormattedBodyINSTANCE = FfiConverterFormattedBody{}

func (c FfiConverterFormattedBody) Lift(rb RustBufferI) FormattedBody {
	return LiftFromRustBuffer[FormattedBody](c, rb)
}

func (c FfiConverterFormattedBody) Read(reader io.Reader) FormattedBody {
	return FormattedBody{
		FfiConverterMessageFormatINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterFormattedBody) Lower(value FormattedBody) C.RustBuffer {
	return LowerIntoRustBuffer[FormattedBody](c, value)
}

func (c FfiConverterFormattedBody) Write(writer io.Writer, value FormattedBody) {
	FfiConverterMessageFormatINSTANCE.Write(writer, value.Format)
	FfiConverterStringINSTANCE.Write(writer, value.Body)
}

type FfiDestroyerFormattedBody struct{}

func (_ FfiDestroyerFormattedBody) Destroy(value FormattedBody) {
	value.Destroy()
}

type HttpPusherData struct {
	Url            string
	Format         *PushFormat
	DefaultPayload *string
}

func (r *HttpPusherData) Destroy() {
	FfiDestroyerString{}.Destroy(r.Url)
	FfiDestroyerOptionalPushFormat{}.Destroy(r.Format)
	FfiDestroyerOptionalString{}.Destroy(r.DefaultPayload)
}

type FfiConverterHttpPusherData struct{}

var FfiConverterHttpPusherDataINSTANCE = FfiConverterHttpPusherData{}

func (c FfiConverterHttpPusherData) Lift(rb RustBufferI) HttpPusherData {
	return LiftFromRustBuffer[HttpPusherData](c, rb)
}

func (c FfiConverterHttpPusherData) Read(reader io.Reader) HttpPusherData {
	return HttpPusherData{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalPushFormatINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterHttpPusherData) Lower(value HttpPusherData) C.RustBuffer {
	return LowerIntoRustBuffer[HttpPusherData](c, value)
}

func (c FfiConverterHttpPusherData) Write(writer io.Writer, value HttpPusherData) {
	FfiConverterStringINSTANCE.Write(writer, value.Url)
	FfiConverterOptionalPushFormatINSTANCE.Write(writer, value.Format)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.DefaultPayload)
}

type FfiDestroyerHttpPusherData struct{}

func (_ FfiDestroyerHttpPusherData) Destroy(value HttpPusherData) {
	value.Destroy()
}

type IdentityStatusChange struct {
	// The user ID of the user whose identity status changed
	UserId string
	// The new state of the identity of the user.
	ChangedTo matrix_sdk_crypto.IdentityState
}

func (r *IdentityStatusChange) Destroy() {
	FfiDestroyerString{}.Destroy(r.UserId)
	matrix_sdk_crypto.FfiDestroyerIdentityState{}.Destroy(r.ChangedTo)
}

type FfiConverterIdentityStatusChange struct{}

var FfiConverterIdentityStatusChangeINSTANCE = FfiConverterIdentityStatusChange{}

func (c FfiConverterIdentityStatusChange) Lift(rb RustBufferI) IdentityStatusChange {
	return LiftFromRustBuffer[IdentityStatusChange](c, rb)
}

func (c FfiConverterIdentityStatusChange) Read(reader io.Reader) IdentityStatusChange {
	return IdentityStatusChange{
		FfiConverterStringINSTANCE.Read(reader),
		matrix_sdk_crypto.FfiConverterIdentityStateINSTANCE.Read(reader),
	}
}

func (c FfiConverterIdentityStatusChange) Lower(value IdentityStatusChange) C.RustBuffer {
	return LowerIntoRustBuffer[IdentityStatusChange](c, value)
}

func (c FfiConverterIdentityStatusChange) Write(writer io.Writer, value IdentityStatusChange) {
	FfiConverterStringINSTANCE.Write(writer, value.UserId)
	matrix_sdk_crypto.FfiConverterIdentityStateINSTANCE.Write(writer, value.ChangedTo)
}

type FfiDestroyerIdentityStatusChange struct{}

func (_ FfiDestroyerIdentityStatusChange) Destroy(value IdentityStatusChange) {
	value.Destroy()
}

// Details about an ignored user.
//
// This is currently empty.
type IgnoredUser struct {
}

func (r *IgnoredUser) Destroy() {
}

type FfiConverterIgnoredUser struct{}

var FfiConverterIgnoredUserINSTANCE = FfiConverterIgnoredUser{}

func (c FfiConverterIgnoredUser) Lift(rb RustBufferI) IgnoredUser {
	return LiftFromRustBuffer[IgnoredUser](c, rb)
}

func (c FfiConverterIgnoredUser) Read(reader io.Reader) IgnoredUser {
	return IgnoredUser{}
}

func (c FfiConverterIgnoredUser) Lower(value IgnoredUser) C.RustBuffer {
	return LowerIntoRustBuffer[IgnoredUser](c, value)
}

func (c FfiConverterIgnoredUser) Write(writer io.Writer, value IgnoredUser) {
}

type FfiDestroyerIgnoredUser struct{}

func (_ FfiDestroyerIgnoredUser) Destroy(value IgnoredUser) {
	value.Destroy()
}

type ImageInfo struct {
	Height          *uint64
	Width           *uint64
	Mimetype        *string
	Size            *uint64
	ThumbnailInfo   *ThumbnailInfo
	ThumbnailSource **MediaSource
	Blurhash        *string
	IsAnimated      *bool
}

func (r *ImageInfo) Destroy() {
	FfiDestroyerOptionalUint64{}.Destroy(r.Height)
	FfiDestroyerOptionalUint64{}.Destroy(r.Width)
	FfiDestroyerOptionalString{}.Destroy(r.Mimetype)
	FfiDestroyerOptionalUint64{}.Destroy(r.Size)
	FfiDestroyerOptionalThumbnailInfo{}.Destroy(r.ThumbnailInfo)
	FfiDestroyerOptionalMediaSource{}.Destroy(r.ThumbnailSource)
	FfiDestroyerOptionalString{}.Destroy(r.Blurhash)
	FfiDestroyerOptionalBool{}.Destroy(r.IsAnimated)
}

type FfiConverterImageInfo struct{}

var FfiConverterImageInfoINSTANCE = FfiConverterImageInfo{}

func (c FfiConverterImageInfo) Lift(rb RustBufferI) ImageInfo {
	return LiftFromRustBuffer[ImageInfo](c, rb)
}

func (c FfiConverterImageInfo) Read(reader io.Reader) ImageInfo {
	return ImageInfo{
		FfiConverterOptionalUint64INSTANCE.Read(reader),
		FfiConverterOptionalUint64INSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalUint64INSTANCE.Read(reader),
		FfiConverterOptionalThumbnailInfoINSTANCE.Read(reader),
		FfiConverterOptionalMediaSourceINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalBoolINSTANCE.Read(reader),
	}
}

func (c FfiConverterImageInfo) Lower(value ImageInfo) C.RustBuffer {
	return LowerIntoRustBuffer[ImageInfo](c, value)
}

func (c FfiConverterImageInfo) Write(writer io.Writer, value ImageInfo) {
	FfiConverterOptionalUint64INSTANCE.Write(writer, value.Height)
	FfiConverterOptionalUint64INSTANCE.Write(writer, value.Width)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Mimetype)
	FfiConverterOptionalUint64INSTANCE.Write(writer, value.Size)
	FfiConverterOptionalThumbnailInfoINSTANCE.Write(writer, value.ThumbnailInfo)
	FfiConverterOptionalMediaSourceINSTANCE.Write(writer, value.ThumbnailSource)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Blurhash)
	FfiConverterOptionalBoolINSTANCE.Write(writer, value.IsAnimated)
}

type FfiDestroyerImageInfo struct{}

func (_ FfiDestroyerImageInfo) Destroy(value ImageInfo) {
	value.Destroy()
}

type ImageMessageContent struct {
	// The computed filename, for use in a client.
	Filename         string
	Caption          *string
	FormattedCaption *FormattedBody
	Source           *MediaSource
	Info             *ImageInfo
}

func (r *ImageMessageContent) Destroy() {
	FfiDestroyerString{}.Destroy(r.Filename)
	FfiDestroyerOptionalString{}.Destroy(r.Caption)
	FfiDestroyerOptionalFormattedBody{}.Destroy(r.FormattedCaption)
	FfiDestroyerMediaSource{}.Destroy(r.Source)
	FfiDestroyerOptionalImageInfo{}.Destroy(r.Info)
}

type FfiConverterImageMessageContent struct{}

var FfiConverterImageMessageContentINSTANCE = FfiConverterImageMessageContent{}

func (c FfiConverterImageMessageContent) Lift(rb RustBufferI) ImageMessageContent {
	return LiftFromRustBuffer[ImageMessageContent](c, rb)
}

func (c FfiConverterImageMessageContent) Read(reader io.Reader) ImageMessageContent {
	return ImageMessageContent{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalFormattedBodyINSTANCE.Read(reader),
		FfiConverterMediaSourceINSTANCE.Read(reader),
		FfiConverterOptionalImageInfoINSTANCE.Read(reader),
	}
}

func (c FfiConverterImageMessageContent) Lower(value ImageMessageContent) C.RustBuffer {
	return LowerIntoRustBuffer[ImageMessageContent](c, value)
}

func (c FfiConverterImageMessageContent) Write(writer io.Writer, value ImageMessageContent) {
	FfiConverterStringINSTANCE.Write(writer, value.Filename)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Caption)
	FfiConverterOptionalFormattedBodyINSTANCE.Write(writer, value.FormattedCaption)
	FfiConverterMediaSourceINSTANCE.Write(writer, value.Source)
	FfiConverterOptionalImageInfoINSTANCE.Write(writer, value.Info)
}

type FfiDestroyerImageMessageContent struct{}

func (_ FfiDestroyerImageMessageContent) Destroy(value ImageMessageContent) {
	value.Destroy()
}

type InsertData struct {
	Index uint32
	Item  *TimelineItem
}

func (r *InsertData) Destroy() {
	FfiDestroyerUint32{}.Destroy(r.Index)
	FfiDestroyerTimelineItem{}.Destroy(r.Item)
}

type FfiConverterInsertData struct{}

var FfiConverterInsertDataINSTANCE = FfiConverterInsertData{}

func (c FfiConverterInsertData) Lift(rb RustBufferI) InsertData {
	return LiftFromRustBuffer[InsertData](c, rb)
}

func (c FfiConverterInsertData) Read(reader io.Reader) InsertData {
	return InsertData{
		FfiConverterUint32INSTANCE.Read(reader),
		FfiConverterTimelineItemINSTANCE.Read(reader),
	}
}

func (c FfiConverterInsertData) Lower(value InsertData) C.RustBuffer {
	return LowerIntoRustBuffer[InsertData](c, value)
}

func (c FfiConverterInsertData) Write(writer io.Writer, value InsertData) {
	FfiConverterUint32INSTANCE.Write(writer, value.Index)
	FfiConverterTimelineItemINSTANCE.Write(writer, value.Item)
}

type FfiDestroyerInsertData struct{}

func (_ FfiDestroyerInsertData) Destroy(value InsertData) {
	value.Destroy()
}

// An FFI representation of a request to join a room.
type KnockRequest struct {
	// The event id of the event that contains the `knock` membership change.
	EventId string
	// The user id of the user who's requesting to join the room.
	UserId string
	// The room id of the room whose access was requested.
	RoomId string
	// The optional display name of the user who's requesting to join the room.
	DisplayName *string
	// The optional avatar url of the user who's requesting to join the room.
	AvatarUrl *string
	// An optional reason why the user wants join the room.
	Reason *string
	// The timestamp when this request was created.
	Timestamp *uint64
	// Whether the knock request has been marked as `seen` so it can be
	// filtered by the client.
	IsSeen bool
	// A set of actions to perform for this knock request.
	Actions *KnockRequestActions
}

func (r *KnockRequest) Destroy() {
	FfiDestroyerString{}.Destroy(r.EventId)
	FfiDestroyerString{}.Destroy(r.UserId)
	FfiDestroyerString{}.Destroy(r.RoomId)
	FfiDestroyerOptionalString{}.Destroy(r.DisplayName)
	FfiDestroyerOptionalString{}.Destroy(r.AvatarUrl)
	FfiDestroyerOptionalString{}.Destroy(r.Reason)
	FfiDestroyerOptionalUint64{}.Destroy(r.Timestamp)
	FfiDestroyerBool{}.Destroy(r.IsSeen)
	FfiDestroyerKnockRequestActions{}.Destroy(r.Actions)
}

type FfiConverterKnockRequest struct{}

var FfiConverterKnockRequestINSTANCE = FfiConverterKnockRequest{}

func (c FfiConverterKnockRequest) Lift(rb RustBufferI) KnockRequest {
	return LiftFromRustBuffer[KnockRequest](c, rb)
}

func (c FfiConverterKnockRequest) Read(reader io.Reader) KnockRequest {
	return KnockRequest{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalUint64INSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterKnockRequestActionsINSTANCE.Read(reader),
	}
}

func (c FfiConverterKnockRequest) Lower(value KnockRequest) C.RustBuffer {
	return LowerIntoRustBuffer[KnockRequest](c, value)
}

func (c FfiConverterKnockRequest) Write(writer io.Writer, value KnockRequest) {
	FfiConverterStringINSTANCE.Write(writer, value.EventId)
	FfiConverterStringINSTANCE.Write(writer, value.UserId)
	FfiConverterStringINSTANCE.Write(writer, value.RoomId)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.DisplayName)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.AvatarUrl)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Reason)
	FfiConverterOptionalUint64INSTANCE.Write(writer, value.Timestamp)
	FfiConverterBoolINSTANCE.Write(writer, value.IsSeen)
	FfiConverterKnockRequestActionsINSTANCE.Write(writer, value.Actions)
}

type FfiDestroyerKnockRequest struct{}

func (_ FfiDestroyerKnockRequest) Destroy(value KnockRequest) {
	value.Destroy()
}

type LastLocation struct {
	// The most recent location content of the user.
	Location LocationContent
	// A timestamp in milliseconds since Unix Epoch on that day in local
	// time.
	Ts uint64
}

func (r *LastLocation) Destroy() {
	FfiDestroyerLocationContent{}.Destroy(r.Location)
	FfiDestroyerUint64{}.Destroy(r.Ts)
}

type FfiConverterLastLocation struct{}

var FfiConverterLastLocationINSTANCE = FfiConverterLastLocation{}

func (c FfiConverterLastLocation) Lift(rb RustBufferI) LastLocation {
	return LiftFromRustBuffer[LastLocation](c, rb)
}

func (c FfiConverterLastLocation) Read(reader io.Reader) LastLocation {
	return LastLocation{
		FfiConverterLocationContentINSTANCE.Read(reader),
		FfiConverterUint64INSTANCE.Read(reader),
	}
}

func (c FfiConverterLastLocation) Lower(value LastLocation) C.RustBuffer {
	return LowerIntoRustBuffer[LastLocation](c, value)
}

func (c FfiConverterLastLocation) Write(writer io.Writer, value LastLocation) {
	FfiConverterLocationContentINSTANCE.Write(writer, value.Location)
	FfiConverterUint64INSTANCE.Write(writer, value.Ts)
}

type FfiDestroyerLastLocation struct{}

func (_ FfiDestroyerLastLocation) Destroy(value LastLocation) {
	value.Destroy()
}

// Details of a users live location share.
type LiveLocationShare struct {
	// The user's last known location.
	LastLocation LastLocation
	// The live status of the live location share.
	IsLive bool
	// The user ID of the person sharing their live location.
	UserId string
}

func (r *LiveLocationShare) Destroy() {
	FfiDestroyerLastLocation{}.Destroy(r.LastLocation)
	FfiDestroyerBool{}.Destroy(r.IsLive)
	FfiDestroyerString{}.Destroy(r.UserId)
}

type FfiConverterLiveLocationShare struct{}

var FfiConverterLiveLocationShareINSTANCE = FfiConverterLiveLocationShare{}

func (c FfiConverterLiveLocationShare) Lift(rb RustBufferI) LiveLocationShare {
	return LiftFromRustBuffer[LiveLocationShare](c, rb)
}

func (c FfiConverterLiveLocationShare) Read(reader io.Reader) LiveLocationShare {
	return LiveLocationShare{
		FfiConverterLastLocationINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterLiveLocationShare) Lower(value LiveLocationShare) C.RustBuffer {
	return LowerIntoRustBuffer[LiveLocationShare](c, value)
}

func (c FfiConverterLiveLocationShare) Write(writer io.Writer, value LiveLocationShare) {
	FfiConverterLastLocationINSTANCE.Write(writer, value.LastLocation)
	FfiConverterBoolINSTANCE.Write(writer, value.IsLive)
	FfiConverterStringINSTANCE.Write(writer, value.UserId)
}

type FfiDestroyerLiveLocationShare struct{}

func (_ FfiDestroyerLiveLocationShare) Destroy(value LiveLocationShare) {
	value.Destroy()
}

type LocationContent struct {
	Body        string
	GeoUri      string
	Description *string
	ZoomLevel   *uint8
	Asset       *AssetType
}

func (r *LocationContent) Destroy() {
	FfiDestroyerString{}.Destroy(r.Body)
	FfiDestroyerString{}.Destroy(r.GeoUri)
	FfiDestroyerOptionalString{}.Destroy(r.Description)
	FfiDestroyerOptionalUint8{}.Destroy(r.ZoomLevel)
	FfiDestroyerOptionalAssetType{}.Destroy(r.Asset)
}

type FfiConverterLocationContent struct{}

var FfiConverterLocationContentINSTANCE = FfiConverterLocationContent{}

func (c FfiConverterLocationContent) Lift(rb RustBufferI) LocationContent {
	return LiftFromRustBuffer[LocationContent](c, rb)
}

func (c FfiConverterLocationContent) Read(reader io.Reader) LocationContent {
	return LocationContent{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalUint8INSTANCE.Read(reader),
		FfiConverterOptionalAssetTypeINSTANCE.Read(reader),
	}
}

func (c FfiConverterLocationContent) Lower(value LocationContent) C.RustBuffer {
	return LowerIntoRustBuffer[LocationContent](c, value)
}

func (c FfiConverterLocationContent) Write(writer io.Writer, value LocationContent) {
	FfiConverterStringINSTANCE.Write(writer, value.Body)
	FfiConverterStringINSTANCE.Write(writer, value.GeoUri)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Description)
	FfiConverterOptionalUint8INSTANCE.Write(writer, value.ZoomLevel)
	FfiConverterOptionalAssetTypeINSTANCE.Write(writer, value.Asset)
}

type FfiDestroyerLocationContent struct{}

func (_ FfiDestroyerLocationContent) Destroy(value LocationContent) {
	value.Destroy()
}

// A Matrix entity that can be a room, room alias, user, or event, and a list
// of via servers.
type MatrixEntity struct {
	Id  MatrixId
	Via []string
}

func (r *MatrixEntity) Destroy() {
	FfiDestroyerMatrixId{}.Destroy(r.Id)
	FfiDestroyerSequenceString{}.Destroy(r.Via)
}

type FfiConverterMatrixEntity struct{}

var FfiConverterMatrixEntityINSTANCE = FfiConverterMatrixEntity{}

func (c FfiConverterMatrixEntity) Lift(rb RustBufferI) MatrixEntity {
	return LiftFromRustBuffer[MatrixEntity](c, rb)
}

func (c FfiConverterMatrixEntity) Read(reader io.Reader) MatrixEntity {
	return MatrixEntity{
		FfiConverterMatrixIdINSTANCE.Read(reader),
		FfiConverterSequenceStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterMatrixEntity) Lower(value MatrixEntity) C.RustBuffer {
	return LowerIntoRustBuffer[MatrixEntity](c, value)
}

func (c FfiConverterMatrixEntity) Write(writer io.Writer, value MatrixEntity) {
	FfiConverterMatrixIdINSTANCE.Write(writer, value.Id)
	FfiConverterSequenceStringINSTANCE.Write(writer, value.Via)
}

type FfiDestroyerMatrixEntity struct{}

func (_ FfiDestroyerMatrixEntity) Destroy(value MatrixEntity) {
	value.Destroy()
}

// The content of an `m.media_preview_config` event.
//
// Is also the content of the unstable
// `io.element.msc4278.media_preview_config`.
type MediaPreviewConfig struct {
	// The media previews setting for the user.
	MediaPreviews MediaPreviews
	// The invite avatars setting for the user.
	InviteAvatars InviteAvatars
}

func (r *MediaPreviewConfig) Destroy() {
	FfiDestroyerMediaPreviews{}.Destroy(r.MediaPreviews)
	FfiDestroyerInviteAvatars{}.Destroy(r.InviteAvatars)
}

type FfiConverterMediaPreviewConfig struct{}

var FfiConverterMediaPreviewConfigINSTANCE = FfiConverterMediaPreviewConfig{}

func (c FfiConverterMediaPreviewConfig) Lift(rb RustBufferI) MediaPreviewConfig {
	return LiftFromRustBuffer[MediaPreviewConfig](c, rb)
}

func (c FfiConverterMediaPreviewConfig) Read(reader io.Reader) MediaPreviewConfig {
	return MediaPreviewConfig{
		FfiConverterMediaPreviewsINSTANCE.Read(reader),
		FfiConverterInviteAvatarsINSTANCE.Read(reader),
	}
}

func (c FfiConverterMediaPreviewConfig) Lower(value MediaPreviewConfig) C.RustBuffer {
	return LowerIntoRustBuffer[MediaPreviewConfig](c, value)
}

func (c FfiConverterMediaPreviewConfig) Write(writer io.Writer, value MediaPreviewConfig) {
	FfiConverterMediaPreviewsINSTANCE.Write(writer, value.MediaPreviews)
	FfiConverterInviteAvatarsINSTANCE.Write(writer, value.InviteAvatars)
}

type FfiDestroyerMediaPreviewConfig struct{}

func (_ FfiDestroyerMediaPreviewConfig) Destroy(value MediaPreviewConfig) {
	value.Destroy()
}

type Mentions struct {
	UserIds []string
	Room    bool
}

func (r *Mentions) Destroy() {
	FfiDestroyerSequenceString{}.Destroy(r.UserIds)
	FfiDestroyerBool{}.Destroy(r.Room)
}

type FfiConverterMentions struct{}

var FfiConverterMentionsINSTANCE = FfiConverterMentions{}

func (c FfiConverterMentions) Lift(rb RustBufferI) Mentions {
	return LiftFromRustBuffer[Mentions](c, rb)
}

func (c FfiConverterMentions) Read(reader io.Reader) Mentions {
	return Mentions{
		FfiConverterSequenceStringINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
	}
}

func (c FfiConverterMentions) Lower(value Mentions) C.RustBuffer {
	return LowerIntoRustBuffer[Mentions](c, value)
}

func (c FfiConverterMentions) Write(writer io.Writer, value Mentions) {
	FfiConverterSequenceStringINSTANCE.Write(writer, value.UserIds)
	FfiConverterBoolINSTANCE.Write(writer, value.Room)
}

type FfiDestroyerMentions struct{}

func (_ FfiDestroyerMentions) Destroy(value Mentions) {
	value.Destroy()
}

type MessageContent struct {
	MsgType  MessageType
	Body     string
	IsEdited bool
	Mentions *Mentions
}

func (r *MessageContent) Destroy() {
	FfiDestroyerMessageType{}.Destroy(r.MsgType)
	FfiDestroyerString{}.Destroy(r.Body)
	FfiDestroyerBool{}.Destroy(r.IsEdited)
	FfiDestroyerOptionalMentions{}.Destroy(r.Mentions)
}

type FfiConverterMessageContent struct{}

var FfiConverterMessageContentINSTANCE = FfiConverterMessageContent{}

func (c FfiConverterMessageContent) Lift(rb RustBufferI) MessageContent {
	return LiftFromRustBuffer[MessageContent](c, rb)
}

func (c FfiConverterMessageContent) Read(reader io.Reader) MessageContent {
	return MessageContent{
		FfiConverterMessageTypeINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterOptionalMentionsINSTANCE.Read(reader),
	}
}

func (c FfiConverterMessageContent) Lower(value MessageContent) C.RustBuffer {
	return LowerIntoRustBuffer[MessageContent](c, value)
}

func (c FfiConverterMessageContent) Write(writer io.Writer, value MessageContent) {
	FfiConverterMessageTypeINSTANCE.Write(writer, value.MsgType)
	FfiConverterStringINSTANCE.Write(writer, value.Body)
	FfiConverterBoolINSTANCE.Write(writer, value.IsEdited)
	FfiConverterOptionalMentionsINSTANCE.Write(writer, value.Mentions)
}

type FfiDestroyerMessageContent struct{}

func (_ FfiDestroyerMessageContent) Destroy(value MessageContent) {
	value.Destroy()
}

// A special kind of [`super::TimelineItemContent`] that groups together
// different room message types with their respective reactions and thread
// information.
type MsgLikeContent struct {
	Kind      MsgLikeKind
	Reactions []Reaction
	// The event this message is replying to, if any.
	InReplyTo **InReplyToDetails
	// Event ID of the thread root, if this is a message in a thread.
	ThreadRoot *string
	// Details about the thread this message is the root of.
	ThreadSummary **ThreadSummary
}

func (r *MsgLikeContent) Destroy() {
	FfiDestroyerMsgLikeKind{}.Destroy(r.Kind)
	FfiDestroyerSequenceReaction{}.Destroy(r.Reactions)
	FfiDestroyerOptionalInReplyToDetails{}.Destroy(r.InReplyTo)
	FfiDestroyerOptionalString{}.Destroy(r.ThreadRoot)
	FfiDestroyerOptionalThreadSummary{}.Destroy(r.ThreadSummary)
}

type FfiConverterMsgLikeContent struct{}

var FfiConverterMsgLikeContentINSTANCE = FfiConverterMsgLikeContent{}

func (c FfiConverterMsgLikeContent) Lift(rb RustBufferI) MsgLikeContent {
	return LiftFromRustBuffer[MsgLikeContent](c, rb)
}

func (c FfiConverterMsgLikeContent) Read(reader io.Reader) MsgLikeContent {
	return MsgLikeContent{
		FfiConverterMsgLikeKindINSTANCE.Read(reader),
		FfiConverterSequenceReactionINSTANCE.Read(reader),
		FfiConverterOptionalInReplyToDetailsINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalThreadSummaryINSTANCE.Read(reader),
	}
}

func (c FfiConverterMsgLikeContent) Lower(value MsgLikeContent) C.RustBuffer {
	return LowerIntoRustBuffer[MsgLikeContent](c, value)
}

func (c FfiConverterMsgLikeContent) Write(writer io.Writer, value MsgLikeContent) {
	FfiConverterMsgLikeKindINSTANCE.Write(writer, value.Kind)
	FfiConverterSequenceReactionINSTANCE.Write(writer, value.Reactions)
	FfiConverterOptionalInReplyToDetailsINSTANCE.Write(writer, value.InReplyTo)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.ThreadRoot)
	FfiConverterOptionalThreadSummaryINSTANCE.Write(writer, value.ThreadSummary)
}

type FfiDestroyerMsgLikeContent struct{}

func (_ FfiDestroyerMsgLikeContent) Destroy(value MsgLikeContent) {
	value.Destroy()
}

type NoticeMessageContent struct {
	Body      string
	Formatted *FormattedBody
}

func (r *NoticeMessageContent) Destroy() {
	FfiDestroyerString{}.Destroy(r.Body)
	FfiDestroyerOptionalFormattedBody{}.Destroy(r.Formatted)
}

type FfiConverterNoticeMessageContent struct{}

var FfiConverterNoticeMessageContentINSTANCE = FfiConverterNoticeMessageContent{}

func (c FfiConverterNoticeMessageContent) Lift(rb RustBufferI) NoticeMessageContent {
	return LiftFromRustBuffer[NoticeMessageContent](c, rb)
}

func (c FfiConverterNoticeMessageContent) Read(reader io.Reader) NoticeMessageContent {
	return NoticeMessageContent{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalFormattedBodyINSTANCE.Read(reader),
	}
}

func (c FfiConverterNoticeMessageContent) Lower(value NoticeMessageContent) C.RustBuffer {
	return LowerIntoRustBuffer[NoticeMessageContent](c, value)
}

func (c FfiConverterNoticeMessageContent) Write(writer io.Writer, value NoticeMessageContent) {
	FfiConverterStringINSTANCE.Write(writer, value.Body)
	FfiConverterOptionalFormattedBodyINSTANCE.Write(writer, value.Formatted)
}

type FfiDestroyerNoticeMessageContent struct{}

func (_ FfiDestroyerNoticeMessageContent) Destroy(value NoticeMessageContent) {
	value.Destroy()
}

type NotificationItem struct {
	Event      NotificationEvent
	SenderInfo NotificationSenderInfo
	RoomInfo   NotificationRoomInfo
	// Is the notification supposed to be at the "noisy" level?
	// Can be `None` if we couldn't determine this, because we lacked
	// information to create a push context.
	IsNoisy    *bool
	HasMention *bool
	ThreadId   *string
}

func (r *NotificationItem) Destroy() {
	FfiDestroyerNotificationEvent{}.Destroy(r.Event)
	FfiDestroyerNotificationSenderInfo{}.Destroy(r.SenderInfo)
	FfiDestroyerNotificationRoomInfo{}.Destroy(r.RoomInfo)
	FfiDestroyerOptionalBool{}.Destroy(r.IsNoisy)
	FfiDestroyerOptionalBool{}.Destroy(r.HasMention)
	FfiDestroyerOptionalString{}.Destroy(r.ThreadId)
}

type FfiConverterNotificationItem struct{}

var FfiConverterNotificationItemINSTANCE = FfiConverterNotificationItem{}

func (c FfiConverterNotificationItem) Lift(rb RustBufferI) NotificationItem {
	return LiftFromRustBuffer[NotificationItem](c, rb)
}

func (c FfiConverterNotificationItem) Read(reader io.Reader) NotificationItem {
	return NotificationItem{
		FfiConverterNotificationEventINSTANCE.Read(reader),
		FfiConverterNotificationSenderInfoINSTANCE.Read(reader),
		FfiConverterNotificationRoomInfoINSTANCE.Read(reader),
		FfiConverterOptionalBoolINSTANCE.Read(reader),
		FfiConverterOptionalBoolINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterNotificationItem) Lower(value NotificationItem) C.RustBuffer {
	return LowerIntoRustBuffer[NotificationItem](c, value)
}

func (c FfiConverterNotificationItem) Write(writer io.Writer, value NotificationItem) {
	FfiConverterNotificationEventINSTANCE.Write(writer, value.Event)
	FfiConverterNotificationSenderInfoINSTANCE.Write(writer, value.SenderInfo)
	FfiConverterNotificationRoomInfoINSTANCE.Write(writer, value.RoomInfo)
	FfiConverterOptionalBoolINSTANCE.Write(writer, value.IsNoisy)
	FfiConverterOptionalBoolINSTANCE.Write(writer, value.HasMention)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.ThreadId)
}

type FfiDestroyerNotificationItem struct{}

func (_ FfiDestroyerNotificationItem) Destroy(value NotificationItem) {
	value.Destroy()
}

// A request for notification items grouped by their room.
type NotificationItemsRequest struct {
	RoomId   string
	EventIds []string
}

func (r *NotificationItemsRequest) Destroy() {
	FfiDestroyerString{}.Destroy(r.RoomId)
	FfiDestroyerSequenceString{}.Destroy(r.EventIds)
}

type FfiConverterNotificationItemsRequest struct{}

var FfiConverterNotificationItemsRequestINSTANCE = FfiConverterNotificationItemsRequest{}

func (c FfiConverterNotificationItemsRequest) Lift(rb RustBufferI) NotificationItemsRequest {
	return LiftFromRustBuffer[NotificationItemsRequest](c, rb)
}

func (c FfiConverterNotificationItemsRequest) Read(reader io.Reader) NotificationItemsRequest {
	return NotificationItemsRequest{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterSequenceStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterNotificationItemsRequest) Lower(value NotificationItemsRequest) C.RustBuffer {
	return LowerIntoRustBuffer[NotificationItemsRequest](c, value)
}

func (c FfiConverterNotificationItemsRequest) Write(writer io.Writer, value NotificationItemsRequest) {
	FfiConverterStringINSTANCE.Write(writer, value.RoomId)
	FfiConverterSequenceStringINSTANCE.Write(writer, value.EventIds)
}

type FfiDestroyerNotificationItemsRequest struct{}

func (_ FfiDestroyerNotificationItemsRequest) Destroy(value NotificationItemsRequest) {
	value.Destroy()
}

type NotificationPowerLevels struct {
	Room int32
}

func (r *NotificationPowerLevels) Destroy() {
	FfiDestroyerInt32{}.Destroy(r.Room)
}

type FfiConverterNotificationPowerLevels struct{}

var FfiConverterNotificationPowerLevelsINSTANCE = FfiConverterNotificationPowerLevels{}

func (c FfiConverterNotificationPowerLevels) Lift(rb RustBufferI) NotificationPowerLevels {
	return LiftFromRustBuffer[NotificationPowerLevels](c, rb)
}

func (c FfiConverterNotificationPowerLevels) Read(reader io.Reader) NotificationPowerLevels {
	return NotificationPowerLevels{
		FfiConverterInt32INSTANCE.Read(reader),
	}
}

func (c FfiConverterNotificationPowerLevels) Lower(value NotificationPowerLevels) C.RustBuffer {
	return LowerIntoRustBuffer[NotificationPowerLevels](c, value)
}

func (c FfiConverterNotificationPowerLevels) Write(writer io.Writer, value NotificationPowerLevels) {
	FfiConverterInt32INSTANCE.Write(writer, value.Room)
}

type FfiDestroyerNotificationPowerLevels struct{}

func (_ FfiDestroyerNotificationPowerLevels) Destroy(value NotificationPowerLevels) {
	value.Destroy()
}

type NotificationRoomInfo struct {
	DisplayName        string
	AvatarUrl          *string
	CanonicalAlias     *string
	JoinRule           *JoinRule
	JoinedMembersCount uint64
	IsEncrypted        *bool
	IsDirect           bool
	IsPublic           bool
}

func (r *NotificationRoomInfo) Destroy() {
	FfiDestroyerString{}.Destroy(r.DisplayName)
	FfiDestroyerOptionalString{}.Destroy(r.AvatarUrl)
	FfiDestroyerOptionalString{}.Destroy(r.CanonicalAlias)
	FfiDestroyerOptionalJoinRule{}.Destroy(r.JoinRule)
	FfiDestroyerUint64{}.Destroy(r.JoinedMembersCount)
	FfiDestroyerOptionalBool{}.Destroy(r.IsEncrypted)
	FfiDestroyerBool{}.Destroy(r.IsDirect)
	FfiDestroyerBool{}.Destroy(r.IsPublic)
}

type FfiConverterNotificationRoomInfo struct{}

var FfiConverterNotificationRoomInfoINSTANCE = FfiConverterNotificationRoomInfo{}

func (c FfiConverterNotificationRoomInfo) Lift(rb RustBufferI) NotificationRoomInfo {
	return LiftFromRustBuffer[NotificationRoomInfo](c, rb)
}

func (c FfiConverterNotificationRoomInfo) Read(reader io.Reader) NotificationRoomInfo {
	return NotificationRoomInfo{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalJoinRuleINSTANCE.Read(reader),
		FfiConverterUint64INSTANCE.Read(reader),
		FfiConverterOptionalBoolINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
	}
}

func (c FfiConverterNotificationRoomInfo) Lower(value NotificationRoomInfo) C.RustBuffer {
	return LowerIntoRustBuffer[NotificationRoomInfo](c, value)
}

func (c FfiConverterNotificationRoomInfo) Write(writer io.Writer, value NotificationRoomInfo) {
	FfiConverterStringINSTANCE.Write(writer, value.DisplayName)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.AvatarUrl)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.CanonicalAlias)
	FfiConverterOptionalJoinRuleINSTANCE.Write(writer, value.JoinRule)
	FfiConverterUint64INSTANCE.Write(writer, value.JoinedMembersCount)
	FfiConverterOptionalBoolINSTANCE.Write(writer, value.IsEncrypted)
	FfiConverterBoolINSTANCE.Write(writer, value.IsDirect)
	FfiConverterBoolINSTANCE.Write(writer, value.IsPublic)
}

type FfiDestroyerNotificationRoomInfo struct{}

func (_ FfiDestroyerNotificationRoomInfo) Destroy(value NotificationRoomInfo) {
	value.Destroy()
}

type NotificationSenderInfo struct {
	DisplayName     *string
	AvatarUrl       *string
	IsNameAmbiguous bool
}

func (r *NotificationSenderInfo) Destroy() {
	FfiDestroyerOptionalString{}.Destroy(r.DisplayName)
	FfiDestroyerOptionalString{}.Destroy(r.AvatarUrl)
	FfiDestroyerBool{}.Destroy(r.IsNameAmbiguous)
}

type FfiConverterNotificationSenderInfo struct{}

var FfiConverterNotificationSenderInfoINSTANCE = FfiConverterNotificationSenderInfo{}

func (c FfiConverterNotificationSenderInfo) Lift(rb RustBufferI) NotificationSenderInfo {
	return LiftFromRustBuffer[NotificationSenderInfo](c, rb)
}

func (c FfiConverterNotificationSenderInfo) Read(reader io.Reader) NotificationSenderInfo {
	return NotificationSenderInfo{
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
	}
}

func (c FfiConverterNotificationSenderInfo) Lower(value NotificationSenderInfo) C.RustBuffer {
	return LowerIntoRustBuffer[NotificationSenderInfo](c, value)
}

func (c FfiConverterNotificationSenderInfo) Write(writer io.Writer, value NotificationSenderInfo) {
	FfiConverterOptionalStringINSTANCE.Write(writer, value.DisplayName)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.AvatarUrl)
	FfiConverterBoolINSTANCE.Write(writer, value.IsNameAmbiguous)
}

type FfiDestroyerNotificationSenderInfo struct{}

func (_ FfiDestroyerNotificationSenderInfo) Destroy(value NotificationSenderInfo) {
	value.Destroy()
}

// The configuration to use when authenticating with OIDC.
type OidcConfiguration struct {
	// The name of the client that will be shown during OIDC authentication.
	ClientName *string
	// The redirect URI that will be used when OIDC authentication is
	// successful.
	RedirectUri string
	// A URI that contains information about the client.
	ClientUri string
	// A URI that contains the client's logo.
	LogoUri *string
	// A URI that contains the client's terms of service.
	TosUri *string
	// A URI that contains the client's privacy policy.
	PolicyUri *string
	// Pre-configured registrations for use with homeservers that don't support
	// dynamic client registration.
	//
	// The keys of the map should be the URLs of the homeservers, but keys
	// using `issuer` URLs are also supported.
	StaticRegistrations map[string]string
}

func (r *OidcConfiguration) Destroy() {
	FfiDestroyerOptionalString{}.Destroy(r.ClientName)
	FfiDestroyerString{}.Destroy(r.RedirectUri)
	FfiDestroyerString{}.Destroy(r.ClientUri)
	FfiDestroyerOptionalString{}.Destroy(r.LogoUri)
	FfiDestroyerOptionalString{}.Destroy(r.TosUri)
	FfiDestroyerOptionalString{}.Destroy(r.PolicyUri)
	FfiDestroyerMapStringString{}.Destroy(r.StaticRegistrations)
}

type FfiConverterOidcConfiguration struct{}

var FfiConverterOidcConfigurationINSTANCE = FfiConverterOidcConfiguration{}

func (c FfiConverterOidcConfiguration) Lift(rb RustBufferI) OidcConfiguration {
	return LiftFromRustBuffer[OidcConfiguration](c, rb)
}

func (c FfiConverterOidcConfiguration) Read(reader io.Reader) OidcConfiguration {
	return OidcConfiguration{
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterMapStringStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterOidcConfiguration) Lower(value OidcConfiguration) C.RustBuffer {
	return LowerIntoRustBuffer[OidcConfiguration](c, value)
}

func (c FfiConverterOidcConfiguration) Write(writer io.Writer, value OidcConfiguration) {
	FfiConverterOptionalStringINSTANCE.Write(writer, value.ClientName)
	FfiConverterStringINSTANCE.Write(writer, value.RedirectUri)
	FfiConverterStringINSTANCE.Write(writer, value.ClientUri)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.LogoUri)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.TosUri)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.PolicyUri)
	FfiConverterMapStringStringINSTANCE.Write(writer, value.StaticRegistrations)
}

type FfiDestroyerOidcConfiguration struct{}

func (_ FfiDestroyerOidcConfiguration) Destroy(value OidcConfiguration) {
	value.Destroy()
}

type OidcCrossSigningResetInfo struct {
	// The URL where the user can approve the reset of the cross-signing keys.
	ApprovalUrl string
}

func (r *OidcCrossSigningResetInfo) Destroy() {
	FfiDestroyerString{}.Destroy(r.ApprovalUrl)
}

type FfiConverterOidcCrossSigningResetInfo struct{}

var FfiConverterOidcCrossSigningResetInfoINSTANCE = FfiConverterOidcCrossSigningResetInfo{}

func (c FfiConverterOidcCrossSigningResetInfo) Lift(rb RustBufferI) OidcCrossSigningResetInfo {
	return LiftFromRustBuffer[OidcCrossSigningResetInfo](c, rb)
}

func (c FfiConverterOidcCrossSigningResetInfo) Read(reader io.Reader) OidcCrossSigningResetInfo {
	return OidcCrossSigningResetInfo{
		FfiConverterStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterOidcCrossSigningResetInfo) Lower(value OidcCrossSigningResetInfo) C.RustBuffer {
	return LowerIntoRustBuffer[OidcCrossSigningResetInfo](c, value)
}

func (c FfiConverterOidcCrossSigningResetInfo) Write(writer io.Writer, value OidcCrossSigningResetInfo) {
	FfiConverterStringINSTANCE.Write(writer, value.ApprovalUrl)
}

type FfiDestroyerOidcCrossSigningResetInfo struct{}

func (_ FfiDestroyerOidcCrossSigningResetInfo) Destroy(value OidcCrossSigningResetInfo) {
	value.Destroy()
}

// A passphrase from which a key is to be derived.
type PassPhrase struct {
	// The algorithm to use to generate the key from the passphrase.
	//
	// Must be `m.pbkdf2`.
	Algorithm KeyDerivationAlgorithm
	// The salt used in PBKDF2.
	Salt string
	// The number of iterations to use in PBKDF2.
	Iterations uint64
	// The number of bits to generate for the key.
	//
	// Defaults to 256
	Bits uint64
}

func (r *PassPhrase) Destroy() {
	FfiDestroyerKeyDerivationAlgorithm{}.Destroy(r.Algorithm)
	FfiDestroyerString{}.Destroy(r.Salt)
	FfiDestroyerUint64{}.Destroy(r.Iterations)
	FfiDestroyerUint64{}.Destroy(r.Bits)
}

type FfiConverterPassPhrase struct{}

var FfiConverterPassPhraseINSTANCE = FfiConverterPassPhrase{}

func (c FfiConverterPassPhrase) Lift(rb RustBufferI) PassPhrase {
	return LiftFromRustBuffer[PassPhrase](c, rb)
}

func (c FfiConverterPassPhrase) Read(reader io.Reader) PassPhrase {
	return PassPhrase{
		FfiConverterKeyDerivationAlgorithmINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterUint64INSTANCE.Read(reader),
		FfiConverterUint64INSTANCE.Read(reader),
	}
}

func (c FfiConverterPassPhrase) Lower(value PassPhrase) C.RustBuffer {
	return LowerIntoRustBuffer[PassPhrase](c, value)
}

func (c FfiConverterPassPhrase) Write(writer io.Writer, value PassPhrase) {
	FfiConverterKeyDerivationAlgorithmINSTANCE.Write(writer, value.Algorithm)
	FfiConverterStringINSTANCE.Write(writer, value.Salt)
	FfiConverterUint64INSTANCE.Write(writer, value.Iterations)
	FfiConverterUint64INSTANCE.Write(writer, value.Bits)
}

type FfiDestroyerPassPhrase struct{}

func (_ FfiDestroyerPassPhrase) Destroy(value PassPhrase) {
	value.Destroy()
}

// Like [`SimplePushRule`], but with an additional `pattern“ field.
type PatternedPushRule struct {
	// Actions to determine if and how a notification is delivered for events
	// matching this rule.
	Actions []Action
	// Whether this is a default rule, or has been set explicitly.
	Default bool
	// Whether the push rule is enabled or not.
	Enabled bool
	// The ID of this rule.
	RuleId string
	// The glob-style pattern to match against.
	Pattern string
}

func (r *PatternedPushRule) Destroy() {
	FfiDestroyerSequenceAction{}.Destroy(r.Actions)
	FfiDestroyerBool{}.Destroy(r.Default)
	FfiDestroyerBool{}.Destroy(r.Enabled)
	FfiDestroyerString{}.Destroy(r.RuleId)
	FfiDestroyerString{}.Destroy(r.Pattern)
}

type FfiConverterPatternedPushRule struct{}

var FfiConverterPatternedPushRuleINSTANCE = FfiConverterPatternedPushRule{}

func (c FfiConverterPatternedPushRule) Lift(rb RustBufferI) PatternedPushRule {
	return LiftFromRustBuffer[PatternedPushRule](c, rb)
}

func (c FfiConverterPatternedPushRule) Read(reader io.Reader) PatternedPushRule {
	return PatternedPushRule{
		FfiConverterSequenceActionINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterPatternedPushRule) Lower(value PatternedPushRule) C.RustBuffer {
	return LowerIntoRustBuffer[PatternedPushRule](c, value)
}

func (c FfiConverterPatternedPushRule) Write(writer io.Writer, value PatternedPushRule) {
	FfiConverterSequenceActionINSTANCE.Write(writer, value.Actions)
	FfiConverterBoolINSTANCE.Write(writer, value.Default)
	FfiConverterBoolINSTANCE.Write(writer, value.Enabled)
	FfiConverterStringINSTANCE.Write(writer, value.RuleId)
	FfiConverterStringINSTANCE.Write(writer, value.Pattern)
}

type FfiDestroyerPatternedPushRule struct{}

func (_ FfiDestroyerPatternedPushRule) Destroy(value PatternedPushRule) {
	value.Destroy()
}

type PollAnswer struct {
	Id   string
	Text string
}

func (r *PollAnswer) Destroy() {
	FfiDestroyerString{}.Destroy(r.Id)
	FfiDestroyerString{}.Destroy(r.Text)
}

type FfiConverterPollAnswer struct{}

var FfiConverterPollAnswerINSTANCE = FfiConverterPollAnswer{}

func (c FfiConverterPollAnswer) Lift(rb RustBufferI) PollAnswer {
	return LiftFromRustBuffer[PollAnswer](c, rb)
}

func (c FfiConverterPollAnswer) Read(reader io.Reader) PollAnswer {
	return PollAnswer{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterPollAnswer) Lower(value PollAnswer) C.RustBuffer {
	return LowerIntoRustBuffer[PollAnswer](c, value)
}

func (c FfiConverterPollAnswer) Write(writer io.Writer, value PollAnswer) {
	FfiConverterStringINSTANCE.Write(writer, value.Id)
	FfiConverterStringINSTANCE.Write(writer, value.Text)
}

type FfiDestroyerPollAnswer struct{}

func (_ FfiDestroyerPollAnswer) Destroy(value PollAnswer) {
	value.Destroy()
}

type PollData struct {
	Question      string
	Answers       []string
	MaxSelections uint8
	PollKind      PollKind
}

func (r *PollData) Destroy() {
	FfiDestroyerString{}.Destroy(r.Question)
	FfiDestroyerSequenceString{}.Destroy(r.Answers)
	FfiDestroyerUint8{}.Destroy(r.MaxSelections)
	FfiDestroyerPollKind{}.Destroy(r.PollKind)
}

type FfiConverterPollData struct{}

var FfiConverterPollDataINSTANCE = FfiConverterPollData{}

func (c FfiConverterPollData) Lift(rb RustBufferI) PollData {
	return LiftFromRustBuffer[PollData](c, rb)
}

func (c FfiConverterPollData) Read(reader io.Reader) PollData {
	return PollData{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterSequenceStringINSTANCE.Read(reader),
		FfiConverterUint8INSTANCE.Read(reader),
		FfiConverterPollKindINSTANCE.Read(reader),
	}
}

func (c FfiConverterPollData) Lower(value PollData) C.RustBuffer {
	return LowerIntoRustBuffer[PollData](c, value)
}

func (c FfiConverterPollData) Write(writer io.Writer, value PollData) {
	FfiConverterStringINSTANCE.Write(writer, value.Question)
	FfiConverterSequenceStringINSTANCE.Write(writer, value.Answers)
	FfiConverterUint8INSTANCE.Write(writer, value.MaxSelections)
	FfiConverterPollKindINSTANCE.Write(writer, value.PollKind)
}

type FfiDestroyerPollData struct{}

func (_ FfiDestroyerPollData) Destroy(value PollData) {
	value.Destroy()
}

type PowerLevels struct {
	UsersDefault  *int32
	EventsDefault *int32
	StateDefault  *int32
	Ban           *int32
	Kick          *int32
	Redact        *int32
	Invite        *int32
	Notifications *NotificationPowerLevels
	Users         map[string]int32
	Events        map[string]int32
}

func (r *PowerLevels) Destroy() {
	FfiDestroyerOptionalInt32{}.Destroy(r.UsersDefault)
	FfiDestroyerOptionalInt32{}.Destroy(r.EventsDefault)
	FfiDestroyerOptionalInt32{}.Destroy(r.StateDefault)
	FfiDestroyerOptionalInt32{}.Destroy(r.Ban)
	FfiDestroyerOptionalInt32{}.Destroy(r.Kick)
	FfiDestroyerOptionalInt32{}.Destroy(r.Redact)
	FfiDestroyerOptionalInt32{}.Destroy(r.Invite)
	FfiDestroyerOptionalNotificationPowerLevels{}.Destroy(r.Notifications)
	FfiDestroyerMapStringInt32{}.Destroy(r.Users)
	FfiDestroyerMapStringInt32{}.Destroy(r.Events)
}

type FfiConverterPowerLevels struct{}

var FfiConverterPowerLevelsINSTANCE = FfiConverterPowerLevels{}

func (c FfiConverterPowerLevels) Lift(rb RustBufferI) PowerLevels {
	return LiftFromRustBuffer[PowerLevels](c, rb)
}

func (c FfiConverterPowerLevels) Read(reader io.Reader) PowerLevels {
	return PowerLevels{
		FfiConverterOptionalInt32INSTANCE.Read(reader),
		FfiConverterOptionalInt32INSTANCE.Read(reader),
		FfiConverterOptionalInt32INSTANCE.Read(reader),
		FfiConverterOptionalInt32INSTANCE.Read(reader),
		FfiConverterOptionalInt32INSTANCE.Read(reader),
		FfiConverterOptionalInt32INSTANCE.Read(reader),
		FfiConverterOptionalInt32INSTANCE.Read(reader),
		FfiConverterOptionalNotificationPowerLevelsINSTANCE.Read(reader),
		FfiConverterMapStringInt32INSTANCE.Read(reader),
		FfiConverterMapStringInt32INSTANCE.Read(reader),
	}
}

func (c FfiConverterPowerLevels) Lower(value PowerLevels) C.RustBuffer {
	return LowerIntoRustBuffer[PowerLevels](c, value)
}

func (c FfiConverterPowerLevels) Write(writer io.Writer, value PowerLevels) {
	FfiConverterOptionalInt32INSTANCE.Write(writer, value.UsersDefault)
	FfiConverterOptionalInt32INSTANCE.Write(writer, value.EventsDefault)
	FfiConverterOptionalInt32INSTANCE.Write(writer, value.StateDefault)
	FfiConverterOptionalInt32INSTANCE.Write(writer, value.Ban)
	FfiConverterOptionalInt32INSTANCE.Write(writer, value.Kick)
	FfiConverterOptionalInt32INSTANCE.Write(writer, value.Redact)
	FfiConverterOptionalInt32INSTANCE.Write(writer, value.Invite)
	FfiConverterOptionalNotificationPowerLevelsINSTANCE.Write(writer, value.Notifications)
	FfiConverterMapStringInt32INSTANCE.Write(writer, value.Users)
	FfiConverterMapStringInt32INSTANCE.Write(writer, value.Events)
}

type FfiDestroyerPowerLevels struct{}

func (_ FfiDestroyerPowerLevels) Destroy(value PowerLevels) {
	value.Destroy()
}

type PusherIdentifiers struct {
	Pushkey string
	AppId   string
}

func (r *PusherIdentifiers) Destroy() {
	FfiDestroyerString{}.Destroy(r.Pushkey)
	FfiDestroyerString{}.Destroy(r.AppId)
}

type FfiConverterPusherIdentifiers struct{}

var FfiConverterPusherIdentifiersINSTANCE = FfiConverterPusherIdentifiers{}

func (c FfiConverterPusherIdentifiers) Lift(rb RustBufferI) PusherIdentifiers {
	return LiftFromRustBuffer[PusherIdentifiers](c, rb)
}

func (c FfiConverterPusherIdentifiers) Read(reader io.Reader) PusherIdentifiers {
	return PusherIdentifiers{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterPusherIdentifiers) Lower(value PusherIdentifiers) C.RustBuffer {
	return LowerIntoRustBuffer[PusherIdentifiers](c, value)
}

func (c FfiConverterPusherIdentifiers) Write(writer io.Writer, value PusherIdentifiers) {
	FfiConverterStringINSTANCE.Write(writer, value.Pushkey)
	FfiConverterStringINSTANCE.Write(writer, value.AppId)
}

type FfiDestroyerPusherIdentifiers struct{}

func (_ FfiDestroyerPusherIdentifiers) Destroy(value PusherIdentifiers) {
	value.Destroy()
}

type Reaction struct {
	Key     string
	Senders []ReactionSenderData
}

func (r *Reaction) Destroy() {
	FfiDestroyerString{}.Destroy(r.Key)
	FfiDestroyerSequenceReactionSenderData{}.Destroy(r.Senders)
}

type FfiConverterReaction struct{}

var FfiConverterReactionINSTANCE = FfiConverterReaction{}

func (c FfiConverterReaction) Lift(rb RustBufferI) Reaction {
	return LiftFromRustBuffer[Reaction](c, rb)
}

func (c FfiConverterReaction) Read(reader io.Reader) Reaction {
	return Reaction{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterSequenceReactionSenderDataINSTANCE.Read(reader),
	}
}

func (c FfiConverterReaction) Lower(value Reaction) C.RustBuffer {
	return LowerIntoRustBuffer[Reaction](c, value)
}

func (c FfiConverterReaction) Write(writer io.Writer, value Reaction) {
	FfiConverterStringINSTANCE.Write(writer, value.Key)
	FfiConverterSequenceReactionSenderDataINSTANCE.Write(writer, value.Senders)
}

type FfiDestroyerReaction struct{}

func (_ FfiDestroyerReaction) Destroy(value Reaction) {
	value.Destroy()
}

type ReactionSenderData struct {
	SenderId  string
	Timestamp Timestamp
}

func (r *ReactionSenderData) Destroy() {
	FfiDestroyerString{}.Destroy(r.SenderId)
	FfiDestroyerTypeTimestamp{}.Destroy(r.Timestamp)
}

type FfiConverterReactionSenderData struct{}

var FfiConverterReactionSenderDataINSTANCE = FfiConverterReactionSenderData{}

func (c FfiConverterReactionSenderData) Lift(rb RustBufferI) ReactionSenderData {
	return LiftFromRustBuffer[ReactionSenderData](c, rb)
}

func (c FfiConverterReactionSenderData) Read(reader io.Reader) ReactionSenderData {
	return ReactionSenderData{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterTypeTimestampINSTANCE.Read(reader),
	}
}

func (c FfiConverterReactionSenderData) Lower(value ReactionSenderData) C.RustBuffer {
	return LowerIntoRustBuffer[ReactionSenderData](c, value)
}

func (c FfiConverterReactionSenderData) Write(writer io.Writer, value ReactionSenderData) {
	FfiConverterStringINSTANCE.Write(writer, value.SenderId)
	FfiConverterTypeTimestampINSTANCE.Write(writer, value.Timestamp)
}

type FfiDestroyerReactionSenderData struct{}

func (_ FfiDestroyerReactionSenderData) Destroy(value ReactionSenderData) {
	value.Destroy()
}

type Receipt struct {
	Timestamp *Timestamp
}

func (r *Receipt) Destroy() {
	FfiDestroyerOptionalTypeTimestamp{}.Destroy(r.Timestamp)
}

type FfiConverterReceipt struct{}

var FfiConverterReceiptINSTANCE = FfiConverterReceipt{}

func (c FfiConverterReceipt) Lift(rb RustBufferI) Receipt {
	return LiftFromRustBuffer[Receipt](c, rb)
}

func (c FfiConverterReceipt) Read(reader io.Reader) Receipt {
	return Receipt{
		FfiConverterOptionalTypeTimestampINSTANCE.Read(reader),
	}
}

func (c FfiConverterReceipt) Lower(value Receipt) C.RustBuffer {
	return LowerIntoRustBuffer[Receipt](c, value)
}

func (c FfiConverterReceipt) Write(writer io.Writer, value Receipt) {
	FfiConverterOptionalTypeTimestampINSTANCE.Write(writer, value.Timestamp)
}

type FfiDestroyerReceipt struct{}

func (_ FfiDestroyerReceipt) Destroy(value Receipt) {
	value.Destroy()
}

type ReplyParameters struct {
	// The ID of the event to reply to.
	EventId string
	// Whether to enforce a thread relation.
	EnforceThread bool
	// If enforcing a threaded relation, whether the message is a reply on a
	// thread.
	ReplyWithinThread bool
}

func (r *ReplyParameters) Destroy() {
	FfiDestroyerString{}.Destroy(r.EventId)
	FfiDestroyerBool{}.Destroy(r.EnforceThread)
	FfiDestroyerBool{}.Destroy(r.ReplyWithinThread)
}

type FfiConverterReplyParameters struct{}

var FfiConverterReplyParametersINSTANCE = FfiConverterReplyParameters{}

func (c FfiConverterReplyParameters) Lift(rb RustBufferI) ReplyParameters {
	return LiftFromRustBuffer[ReplyParameters](c, rb)
}

func (c FfiConverterReplyParameters) Read(reader io.Reader) ReplyParameters {
	return ReplyParameters{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
	}
}

func (c FfiConverterReplyParameters) Lower(value ReplyParameters) C.RustBuffer {
	return LowerIntoRustBuffer[ReplyParameters](c, value)
}

func (c FfiConverterReplyParameters) Write(writer io.Writer, value ReplyParameters) {
	FfiConverterStringINSTANCE.Write(writer, value.EventId)
	FfiConverterBoolINSTANCE.Write(writer, value.EnforceThread)
	FfiConverterBoolINSTANCE.Write(writer, value.ReplyWithinThread)
}

type FfiDestroyerReplyParameters struct{}

func (_ FfiDestroyerReplyParameters) Destroy(value ReplyParameters) {
	value.Destroy()
}

// The config to use for HTTP requests by default in this client.
type RequestConfig struct {
	// Max number of retries.
	RetryLimit *uint64
	// Timeout for a request in milliseconds.
	Timeout *uint64
	// Max number of concurrent requests. No value means no limits.
	MaxConcurrentRequests *uint64
	// Base delay between retries.
	MaxRetryTime *uint64
}

func (r *RequestConfig) Destroy() {
	FfiDestroyerOptionalUint64{}.Destroy(r.RetryLimit)
	FfiDestroyerOptionalUint64{}.Destroy(r.Timeout)
	FfiDestroyerOptionalUint64{}.Destroy(r.MaxConcurrentRequests)
	FfiDestroyerOptionalUint64{}.Destroy(r.MaxRetryTime)
}

type FfiConverterRequestConfig struct{}

var FfiConverterRequestConfigINSTANCE = FfiConverterRequestConfig{}

func (c FfiConverterRequestConfig) Lift(rb RustBufferI) RequestConfig {
	return LiftFromRustBuffer[RequestConfig](c, rb)
}

func (c FfiConverterRequestConfig) Read(reader io.Reader) RequestConfig {
	return RequestConfig{
		FfiConverterOptionalUint64INSTANCE.Read(reader),
		FfiConverterOptionalUint64INSTANCE.Read(reader),
		FfiConverterOptionalUint64INSTANCE.Read(reader),
		FfiConverterOptionalUint64INSTANCE.Read(reader),
	}
}

func (c FfiConverterRequestConfig) Lower(value RequestConfig) C.RustBuffer {
	return LowerIntoRustBuffer[RequestConfig](c, value)
}

func (c FfiConverterRequestConfig) Write(writer io.Writer, value RequestConfig) {
	FfiConverterOptionalUint64INSTANCE.Write(writer, value.RetryLimit)
	FfiConverterOptionalUint64INSTANCE.Write(writer, value.Timeout)
	FfiConverterOptionalUint64INSTANCE.Write(writer, value.MaxConcurrentRequests)
	FfiConverterOptionalUint64INSTANCE.Write(writer, value.MaxRetryTime)
}

type FfiDestroyerRequestConfig struct{}

func (_ FfiDestroyerRequestConfig) Destroy(value RequestConfig) {
	value.Destroy()
}

// Information about a room, that was resolved from a room alias.
type ResolvedRoomAlias struct {
	// The room ID that the alias resolved to.
	RoomId string
	// A list of servers that can be used to find the room by its room ID.
	Servers []string
}

func (r *ResolvedRoomAlias) Destroy() {
	FfiDestroyerString{}.Destroy(r.RoomId)
	FfiDestroyerSequenceString{}.Destroy(r.Servers)
}

type FfiConverterResolvedRoomAlias struct{}

var FfiConverterResolvedRoomAliasINSTANCE = FfiConverterResolvedRoomAlias{}

func (c FfiConverterResolvedRoomAlias) Lift(rb RustBufferI) ResolvedRoomAlias {
	return LiftFromRustBuffer[ResolvedRoomAlias](c, rb)
}

func (c FfiConverterResolvedRoomAlias) Read(reader io.Reader) ResolvedRoomAlias {
	return ResolvedRoomAlias{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterSequenceStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterResolvedRoomAlias) Lower(value ResolvedRoomAlias) C.RustBuffer {
	return LowerIntoRustBuffer[ResolvedRoomAlias](c, value)
}

func (c FfiConverterResolvedRoomAlias) Write(writer io.Writer, value ResolvedRoomAlias) {
	FfiConverterStringINSTANCE.Write(writer, value.RoomId)
	FfiConverterSequenceStringINSTANCE.Write(writer, value.Servers)
}

type FfiDestroyerResolvedRoomAlias struct{}

func (_ FfiDestroyerResolvedRoomAlias) Destroy(value ResolvedRoomAlias) {
	value.Destroy()
}

type RoomDescription struct {
	RoomId          string
	Name            *string
	Topic           *string
	Alias           *string
	AvatarUrl       *string
	JoinRule        *PublicRoomJoinRule
	IsWorldReadable bool
	JoinedMembers   uint64
}

func (r *RoomDescription) Destroy() {
	FfiDestroyerString{}.Destroy(r.RoomId)
	FfiDestroyerOptionalString{}.Destroy(r.Name)
	FfiDestroyerOptionalString{}.Destroy(r.Topic)
	FfiDestroyerOptionalString{}.Destroy(r.Alias)
	FfiDestroyerOptionalString{}.Destroy(r.AvatarUrl)
	FfiDestroyerOptionalPublicRoomJoinRule{}.Destroy(r.JoinRule)
	FfiDestroyerBool{}.Destroy(r.IsWorldReadable)
	FfiDestroyerUint64{}.Destroy(r.JoinedMembers)
}

type FfiConverterRoomDescription struct{}

var FfiConverterRoomDescriptionINSTANCE = FfiConverterRoomDescription{}

func (c FfiConverterRoomDescription) Lift(rb RustBufferI) RoomDescription {
	return LiftFromRustBuffer[RoomDescription](c, rb)
}

func (c FfiConverterRoomDescription) Read(reader io.Reader) RoomDescription {
	return RoomDescription{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalPublicRoomJoinRuleINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterUint64INSTANCE.Read(reader),
	}
}

func (c FfiConverterRoomDescription) Lower(value RoomDescription) C.RustBuffer {
	return LowerIntoRustBuffer[RoomDescription](c, value)
}

func (c FfiConverterRoomDescription) Write(writer io.Writer, value RoomDescription) {
	FfiConverterStringINSTANCE.Write(writer, value.RoomId)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Name)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Topic)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Alias)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.AvatarUrl)
	FfiConverterOptionalPublicRoomJoinRuleINSTANCE.Write(writer, value.JoinRule)
	FfiConverterBoolINSTANCE.Write(writer, value.IsWorldReadable)
	FfiConverterUint64INSTANCE.Write(writer, value.JoinedMembers)
}

type FfiDestroyerRoomDescription struct{}

func (_ FfiDestroyerRoomDescription) Destroy(value RoomDescription) {
	value.Destroy()
}

type RoomDirectorySearchEntriesResult struct {
	EntriesStream *TaskHandle
}

func (r *RoomDirectorySearchEntriesResult) Destroy() {
	FfiDestroyerTaskHandle{}.Destroy(r.EntriesStream)
}

type FfiConverterRoomDirectorySearchEntriesResult struct{}

var FfiConverterRoomDirectorySearchEntriesResultINSTANCE = FfiConverterRoomDirectorySearchEntriesResult{}

func (c FfiConverterRoomDirectorySearchEntriesResult) Lift(rb RustBufferI) RoomDirectorySearchEntriesResult {
	return LiftFromRustBuffer[RoomDirectorySearchEntriesResult](c, rb)
}

func (c FfiConverterRoomDirectorySearchEntriesResult) Read(reader io.Reader) RoomDirectorySearchEntriesResult {
	return RoomDirectorySearchEntriesResult{
		FfiConverterTaskHandleINSTANCE.Read(reader),
	}
}

func (c FfiConverterRoomDirectorySearchEntriesResult) Lower(value RoomDirectorySearchEntriesResult) C.RustBuffer {
	return LowerIntoRustBuffer[RoomDirectorySearchEntriesResult](c, value)
}

func (c FfiConverterRoomDirectorySearchEntriesResult) Write(writer io.Writer, value RoomDirectorySearchEntriesResult) {
	FfiConverterTaskHandleINSTANCE.Write(writer, value.EntriesStream)
}

type FfiDestroyerRoomDirectorySearchEntriesResult struct{}

func (_ FfiDestroyerRoomDirectorySearchEntriesResult) Destroy(value RoomDirectorySearchEntriesResult) {
	value.Destroy()
}

// Information about a member considered to be a room hero.
type RoomHero struct {
	// The user ID of the hero.
	UserId string
	// The display name of the hero.
	DisplayName *string
	// The avatar URL of the hero.
	AvatarUrl *string
}

func (r *RoomHero) Destroy() {
	FfiDestroyerString{}.Destroy(r.UserId)
	FfiDestroyerOptionalString{}.Destroy(r.DisplayName)
	FfiDestroyerOptionalString{}.Destroy(r.AvatarUrl)
}

type FfiConverterRoomHero struct{}

var FfiConverterRoomHeroINSTANCE = FfiConverterRoomHero{}

func (c FfiConverterRoomHero) Lift(rb RustBufferI) RoomHero {
	return LiftFromRustBuffer[RoomHero](c, rb)
}

func (c FfiConverterRoomHero) Read(reader io.Reader) RoomHero {
	return RoomHero{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterRoomHero) Lower(value RoomHero) C.RustBuffer {
	return LowerIntoRustBuffer[RoomHero](c, value)
}

func (c FfiConverterRoomHero) Write(writer io.Writer, value RoomHero) {
	FfiConverterStringINSTANCE.Write(writer, value.UserId)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.DisplayName)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.AvatarUrl)
}

type FfiDestroyerRoomHero struct{}

func (_ FfiDestroyerRoomHero) Destroy(value RoomHero) {
	value.Destroy()
}

type RoomInfo struct {
	Id              string
	EncryptionState matrix_sdk_base.EncryptionState
	Creator         *string
	// The room's name from the room state event if received from sync, or one
	// that's been computed otherwise.
	DisplayName *string
	// Room name as defined by the room state event only.
	RawName   *string
	Topic     *string
	AvatarUrl *string
	IsDirect  bool
	IsPublic  bool
	IsSpace   bool
	// If present, it means the room has been archived/upgraded.
	Tombstone          *RoomTombstoneInfo
	IsFavourite        bool
	CanonicalAlias     *string
	AlternativeAliases []string
	Membership         Membership
	// Member who invited the current user to a room that's in the invited
	// state.
	//
	// Can be missing if the room membership invite event is missing from the
	// store.
	Inviter                           *RoomMember
	Heroes                            []RoomHero
	ActiveMembersCount                uint64
	InvitedMembersCount               uint64
	JoinedMembersCount                uint64
	UserPowerLevels                   map[string]int64
	HighlightCount                    uint64
	NotificationCount                 uint64
	CachedUserDefinedNotificationMode *RoomNotificationMode
	HasRoomCall                       bool
	ActiveRoomCallParticipants        []string
	// Whether this room has been explicitly marked as unread
	IsMarkedUnread bool
	// "Interesting" messages received in that room, independently of the
	// notification settings.
	NumUnreadMessages uint64
	// Events that will notify the user, according to their
	// notification settings.
	NumUnreadNotifications uint64
	// Events causing mentions/highlights for the user, according to their
	// notification settings.
	NumUnreadMentions uint64
	// The currently pinned event ids.
	PinnedEventIds []string
	// The join rule for this room, if known.
	JoinRule *JoinRule
	// The history visibility for this room, if known.
	HistoryVisibility RoomHistoryVisibility
}

func (r *RoomInfo) Destroy() {
	FfiDestroyerString{}.Destroy(r.Id)
	matrix_sdk_base.FfiDestroyerEncryptionState{}.Destroy(r.EncryptionState)
	FfiDestroyerOptionalString{}.Destroy(r.Creator)
	FfiDestroyerOptionalString{}.Destroy(r.DisplayName)
	FfiDestroyerOptionalString{}.Destroy(r.RawName)
	FfiDestroyerOptionalString{}.Destroy(r.Topic)
	FfiDestroyerOptionalString{}.Destroy(r.AvatarUrl)
	FfiDestroyerBool{}.Destroy(r.IsDirect)
	FfiDestroyerBool{}.Destroy(r.IsPublic)
	FfiDestroyerBool{}.Destroy(r.IsSpace)
	FfiDestroyerOptionalRoomTombstoneInfo{}.Destroy(r.Tombstone)
	FfiDestroyerBool{}.Destroy(r.IsFavourite)
	FfiDestroyerOptionalString{}.Destroy(r.CanonicalAlias)
	FfiDestroyerSequenceString{}.Destroy(r.AlternativeAliases)
	FfiDestroyerMembership{}.Destroy(r.Membership)
	FfiDestroyerOptionalRoomMember{}.Destroy(r.Inviter)
	FfiDestroyerSequenceRoomHero{}.Destroy(r.Heroes)
	FfiDestroyerUint64{}.Destroy(r.ActiveMembersCount)
	FfiDestroyerUint64{}.Destroy(r.InvitedMembersCount)
	FfiDestroyerUint64{}.Destroy(r.JoinedMembersCount)
	FfiDestroyerMapStringInt64{}.Destroy(r.UserPowerLevels)
	FfiDestroyerUint64{}.Destroy(r.HighlightCount)
	FfiDestroyerUint64{}.Destroy(r.NotificationCount)
	FfiDestroyerOptionalRoomNotificationMode{}.Destroy(r.CachedUserDefinedNotificationMode)
	FfiDestroyerBool{}.Destroy(r.HasRoomCall)
	FfiDestroyerSequenceString{}.Destroy(r.ActiveRoomCallParticipants)
	FfiDestroyerBool{}.Destroy(r.IsMarkedUnread)
	FfiDestroyerUint64{}.Destroy(r.NumUnreadMessages)
	FfiDestroyerUint64{}.Destroy(r.NumUnreadNotifications)
	FfiDestroyerUint64{}.Destroy(r.NumUnreadMentions)
	FfiDestroyerSequenceString{}.Destroy(r.PinnedEventIds)
	FfiDestroyerOptionalJoinRule{}.Destroy(r.JoinRule)
	FfiDestroyerRoomHistoryVisibility{}.Destroy(r.HistoryVisibility)
}

type FfiConverterRoomInfo struct{}

var FfiConverterRoomInfoINSTANCE = FfiConverterRoomInfo{}

func (c FfiConverterRoomInfo) Lift(rb RustBufferI) RoomInfo {
	return LiftFromRustBuffer[RoomInfo](c, rb)
}

func (c FfiConverterRoomInfo) Read(reader io.Reader) RoomInfo {
	return RoomInfo{
		FfiConverterStringINSTANCE.Read(reader),
		matrix_sdk_base.FfiConverterEncryptionStateINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterOptionalRoomTombstoneInfoINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterSequenceStringINSTANCE.Read(reader),
		FfiConverterMembershipINSTANCE.Read(reader),
		FfiConverterOptionalRoomMemberINSTANCE.Read(reader),
		FfiConverterSequenceRoomHeroINSTANCE.Read(reader),
		FfiConverterUint64INSTANCE.Read(reader),
		FfiConverterUint64INSTANCE.Read(reader),
		FfiConverterUint64INSTANCE.Read(reader),
		FfiConverterMapStringInt64INSTANCE.Read(reader),
		FfiConverterUint64INSTANCE.Read(reader),
		FfiConverterUint64INSTANCE.Read(reader),
		FfiConverterOptionalRoomNotificationModeINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterSequenceStringINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterUint64INSTANCE.Read(reader),
		FfiConverterUint64INSTANCE.Read(reader),
		FfiConverterUint64INSTANCE.Read(reader),
		FfiConverterSequenceStringINSTANCE.Read(reader),
		FfiConverterOptionalJoinRuleINSTANCE.Read(reader),
		FfiConverterRoomHistoryVisibilityINSTANCE.Read(reader),
	}
}

func (c FfiConverterRoomInfo) Lower(value RoomInfo) C.RustBuffer {
	return LowerIntoRustBuffer[RoomInfo](c, value)
}

func (c FfiConverterRoomInfo) Write(writer io.Writer, value RoomInfo) {
	FfiConverterStringINSTANCE.Write(writer, value.Id)
	matrix_sdk_base.FfiConverterEncryptionStateINSTANCE.Write(writer, value.EncryptionState)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Creator)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.DisplayName)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.RawName)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Topic)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.AvatarUrl)
	FfiConverterBoolINSTANCE.Write(writer, value.IsDirect)
	FfiConverterBoolINSTANCE.Write(writer, value.IsPublic)
	FfiConverterBoolINSTANCE.Write(writer, value.IsSpace)
	FfiConverterOptionalRoomTombstoneInfoINSTANCE.Write(writer, value.Tombstone)
	FfiConverterBoolINSTANCE.Write(writer, value.IsFavourite)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.CanonicalAlias)
	FfiConverterSequenceStringINSTANCE.Write(writer, value.AlternativeAliases)
	FfiConverterMembershipINSTANCE.Write(writer, value.Membership)
	FfiConverterOptionalRoomMemberINSTANCE.Write(writer, value.Inviter)
	FfiConverterSequenceRoomHeroINSTANCE.Write(writer, value.Heroes)
	FfiConverterUint64INSTANCE.Write(writer, value.ActiveMembersCount)
	FfiConverterUint64INSTANCE.Write(writer, value.InvitedMembersCount)
	FfiConverterUint64INSTANCE.Write(writer, value.JoinedMembersCount)
	FfiConverterMapStringInt64INSTANCE.Write(writer, value.UserPowerLevels)
	FfiConverterUint64INSTANCE.Write(writer, value.HighlightCount)
	FfiConverterUint64INSTANCE.Write(writer, value.NotificationCount)
	FfiConverterOptionalRoomNotificationModeINSTANCE.Write(writer, value.CachedUserDefinedNotificationMode)
	FfiConverterBoolINSTANCE.Write(writer, value.HasRoomCall)
	FfiConverterSequenceStringINSTANCE.Write(writer, value.ActiveRoomCallParticipants)
	FfiConverterBoolINSTANCE.Write(writer, value.IsMarkedUnread)
	FfiConverterUint64INSTANCE.Write(writer, value.NumUnreadMessages)
	FfiConverterUint64INSTANCE.Write(writer, value.NumUnreadNotifications)
	FfiConverterUint64INSTANCE.Write(writer, value.NumUnreadMentions)
	FfiConverterSequenceStringINSTANCE.Write(writer, value.PinnedEventIds)
	FfiConverterOptionalJoinRuleINSTANCE.Write(writer, value.JoinRule)
	FfiConverterRoomHistoryVisibilityINSTANCE.Write(writer, value.HistoryVisibility)
}

type FfiDestroyerRoomInfo struct{}

func (_ FfiDestroyerRoomInfo) Destroy(value RoomInfo) {
	value.Destroy()
}

type RoomListLoadingStateResult struct {
	State       RoomListLoadingState
	StateStream *TaskHandle
}

func (r *RoomListLoadingStateResult) Destroy() {
	FfiDestroyerRoomListLoadingState{}.Destroy(r.State)
	FfiDestroyerTaskHandle{}.Destroy(r.StateStream)
}

type FfiConverterRoomListLoadingStateResult struct{}

var FfiConverterRoomListLoadingStateResultINSTANCE = FfiConverterRoomListLoadingStateResult{}

func (c FfiConverterRoomListLoadingStateResult) Lift(rb RustBufferI) RoomListLoadingStateResult {
	return LiftFromRustBuffer[RoomListLoadingStateResult](c, rb)
}

func (c FfiConverterRoomListLoadingStateResult) Read(reader io.Reader) RoomListLoadingStateResult {
	return RoomListLoadingStateResult{
		FfiConverterRoomListLoadingStateINSTANCE.Read(reader),
		FfiConverterTaskHandleINSTANCE.Read(reader),
	}
}

func (c FfiConverterRoomListLoadingStateResult) Lower(value RoomListLoadingStateResult) C.RustBuffer {
	return LowerIntoRustBuffer[RoomListLoadingStateResult](c, value)
}

func (c FfiConverterRoomListLoadingStateResult) Write(writer io.Writer, value RoomListLoadingStateResult) {
	FfiConverterRoomListLoadingStateINSTANCE.Write(writer, value.State)
	FfiConverterTaskHandleINSTANCE.Write(writer, value.StateStream)
}

type FfiDestroyerRoomListLoadingStateResult struct{}

func (_ FfiDestroyerRoomListLoadingStateResult) Destroy(value RoomListLoadingStateResult) {
	value.Destroy()
}

type RoomMember struct {
	UserId                     string
	DisplayName                *string
	AvatarUrl                  *string
	Membership                 MembershipState
	IsNameAmbiguous            bool
	PowerLevel                 int64
	NormalizedPowerLevel       int64
	IsIgnored                  bool
	SuggestedRoleForPowerLevel matrix_sdk.RoomMemberRole
	MembershipChangeReason     *string
}

func (r *RoomMember) Destroy() {
	FfiDestroyerString{}.Destroy(r.UserId)
	FfiDestroyerOptionalString{}.Destroy(r.DisplayName)
	FfiDestroyerOptionalString{}.Destroy(r.AvatarUrl)
	FfiDestroyerMembershipState{}.Destroy(r.Membership)
	FfiDestroyerBool{}.Destroy(r.IsNameAmbiguous)
	FfiDestroyerInt64{}.Destroy(r.PowerLevel)
	FfiDestroyerInt64{}.Destroy(r.NormalizedPowerLevel)
	FfiDestroyerBool{}.Destroy(r.IsIgnored)
	matrix_sdk.FfiDestroyerRoomMemberRole{}.Destroy(r.SuggestedRoleForPowerLevel)
	FfiDestroyerOptionalString{}.Destroy(r.MembershipChangeReason)
}

type FfiConverterRoomMember struct{}

var FfiConverterRoomMemberINSTANCE = FfiConverterRoomMember{}

func (c FfiConverterRoomMember) Lift(rb RustBufferI) RoomMember {
	return LiftFromRustBuffer[RoomMember](c, rb)
}

func (c FfiConverterRoomMember) Read(reader io.Reader) RoomMember {
	return RoomMember{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterMembershipStateINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterInt64INSTANCE.Read(reader),
		FfiConverterInt64INSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		matrix_sdk.FfiConverterRoomMemberRoleINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterRoomMember) Lower(value RoomMember) C.RustBuffer {
	return LowerIntoRustBuffer[RoomMember](c, value)
}

func (c FfiConverterRoomMember) Write(writer io.Writer, value RoomMember) {
	FfiConverterStringINSTANCE.Write(writer, value.UserId)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.DisplayName)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.AvatarUrl)
	FfiConverterMembershipStateINSTANCE.Write(writer, value.Membership)
	FfiConverterBoolINSTANCE.Write(writer, value.IsNameAmbiguous)
	FfiConverterInt64INSTANCE.Write(writer, value.PowerLevel)
	FfiConverterInt64INSTANCE.Write(writer, value.NormalizedPowerLevel)
	FfiConverterBoolINSTANCE.Write(writer, value.IsIgnored)
	matrix_sdk.FfiConverterRoomMemberRoleINSTANCE.Write(writer, value.SuggestedRoleForPowerLevel)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.MembershipChangeReason)
}

type FfiDestroyerRoomMember struct{}

func (_ FfiDestroyerRoomMember) Destroy(value RoomMember) {
	value.Destroy()
}

// Contains the current user's room member info and the optional room member
// info of the sender of the `m.room.member` event that this info represents.
type RoomMemberWithSenderInfo struct {
	// The room member.
	RoomMember RoomMember
	// The info of the sender of the event `room_member` is based on, if
	// available.
	SenderInfo *RoomMember
}

func (r *RoomMemberWithSenderInfo) Destroy() {
	FfiDestroyerRoomMember{}.Destroy(r.RoomMember)
	FfiDestroyerOptionalRoomMember{}.Destroy(r.SenderInfo)
}

type FfiConverterRoomMemberWithSenderInfo struct{}

var FfiConverterRoomMemberWithSenderInfoINSTANCE = FfiConverterRoomMemberWithSenderInfo{}

func (c FfiConverterRoomMemberWithSenderInfo) Lift(rb RustBufferI) RoomMemberWithSenderInfo {
	return LiftFromRustBuffer[RoomMemberWithSenderInfo](c, rb)
}

func (c FfiConverterRoomMemberWithSenderInfo) Read(reader io.Reader) RoomMemberWithSenderInfo {
	return RoomMemberWithSenderInfo{
		FfiConverterRoomMemberINSTANCE.Read(reader),
		FfiConverterOptionalRoomMemberINSTANCE.Read(reader),
	}
}

func (c FfiConverterRoomMemberWithSenderInfo) Lower(value RoomMemberWithSenderInfo) C.RustBuffer {
	return LowerIntoRustBuffer[RoomMemberWithSenderInfo](c, value)
}

func (c FfiConverterRoomMemberWithSenderInfo) Write(writer io.Writer, value RoomMemberWithSenderInfo) {
	FfiConverterRoomMemberINSTANCE.Write(writer, value.RoomMember)
	FfiConverterOptionalRoomMemberINSTANCE.Write(writer, value.SenderInfo)
}

type FfiDestroyerRoomMemberWithSenderInfo struct{}

func (_ FfiDestroyerRoomMemberWithSenderInfo) Destroy(value RoomMemberWithSenderInfo) {
	value.Destroy()
}

// `RoomNotificationSettings` represents the current settings for a `Room`
type RoomNotificationSettings struct {
	// The room notification mode
	Mode RoomNotificationMode
	// Whether the mode is the default one
	IsDefault bool
}

func (r *RoomNotificationSettings) Destroy() {
	FfiDestroyerRoomNotificationMode{}.Destroy(r.Mode)
	FfiDestroyerBool{}.Destroy(r.IsDefault)
}

type FfiConverterRoomNotificationSettings struct{}

var FfiConverterRoomNotificationSettingsINSTANCE = FfiConverterRoomNotificationSettings{}

func (c FfiConverterRoomNotificationSettings) Lift(rb RustBufferI) RoomNotificationSettings {
	return LiftFromRustBuffer[RoomNotificationSettings](c, rb)
}

func (c FfiConverterRoomNotificationSettings) Read(reader io.Reader) RoomNotificationSettings {
	return RoomNotificationSettings{
		FfiConverterRoomNotificationModeINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
	}
}

func (c FfiConverterRoomNotificationSettings) Lower(value RoomNotificationSettings) C.RustBuffer {
	return LowerIntoRustBuffer[RoomNotificationSettings](c, value)
}

func (c FfiConverterRoomNotificationSettings) Write(writer io.Writer, value RoomNotificationSettings) {
	FfiConverterRoomNotificationModeINSTANCE.Write(writer, value.Mode)
	FfiConverterBoolINSTANCE.Write(writer, value.IsDefault)
}

type FfiDestroyerRoomNotificationSettings struct{}

func (_ FfiDestroyerRoomNotificationSettings) Destroy(value RoomNotificationSettings) {
	value.Destroy()
}

type RoomPowerLevels struct {
	// The level required to ban a user.
	Ban int64
	// The level required to invite a user.
	Invite int64
	// The level required to kick a user.
	Kick int64
	// The level required to redact an event.
	Redact int64
	// The default level required to send message events.
	EventsDefault int64
	// The default level required to send state events.
	StateDefault int64
	// The default power level for every user in the room.
	UsersDefault int64
	// The level required to change the room's name.
	RoomName int64
	// The level required to change the room's avatar.
	RoomAvatar int64
	// The level required to change the room's topic.
	RoomTopic int64
}

func (r *RoomPowerLevels) Destroy() {
	FfiDestroyerInt64{}.Destroy(r.Ban)
	FfiDestroyerInt64{}.Destroy(r.Invite)
	FfiDestroyerInt64{}.Destroy(r.Kick)
	FfiDestroyerInt64{}.Destroy(r.Redact)
	FfiDestroyerInt64{}.Destroy(r.EventsDefault)
	FfiDestroyerInt64{}.Destroy(r.StateDefault)
	FfiDestroyerInt64{}.Destroy(r.UsersDefault)
	FfiDestroyerInt64{}.Destroy(r.RoomName)
	FfiDestroyerInt64{}.Destroy(r.RoomAvatar)
	FfiDestroyerInt64{}.Destroy(r.RoomTopic)
}

type FfiConverterRoomPowerLevels struct{}

var FfiConverterRoomPowerLevelsINSTANCE = FfiConverterRoomPowerLevels{}

func (c FfiConverterRoomPowerLevels) Lift(rb RustBufferI) RoomPowerLevels {
	return LiftFromRustBuffer[RoomPowerLevels](c, rb)
}

func (c FfiConverterRoomPowerLevels) Read(reader io.Reader) RoomPowerLevels {
	return RoomPowerLevels{
		FfiConverterInt64INSTANCE.Read(reader),
		FfiConverterInt64INSTANCE.Read(reader),
		FfiConverterInt64INSTANCE.Read(reader),
		FfiConverterInt64INSTANCE.Read(reader),
		FfiConverterInt64INSTANCE.Read(reader),
		FfiConverterInt64INSTANCE.Read(reader),
		FfiConverterInt64INSTANCE.Read(reader),
		FfiConverterInt64INSTANCE.Read(reader),
		FfiConverterInt64INSTANCE.Read(reader),
		FfiConverterInt64INSTANCE.Read(reader),
	}
}

func (c FfiConverterRoomPowerLevels) Lower(value RoomPowerLevels) C.RustBuffer {
	return LowerIntoRustBuffer[RoomPowerLevels](c, value)
}

func (c FfiConverterRoomPowerLevels) Write(writer io.Writer, value RoomPowerLevels) {
	FfiConverterInt64INSTANCE.Write(writer, value.Ban)
	FfiConverterInt64INSTANCE.Write(writer, value.Invite)
	FfiConverterInt64INSTANCE.Write(writer, value.Kick)
	FfiConverterInt64INSTANCE.Write(writer, value.Redact)
	FfiConverterInt64INSTANCE.Write(writer, value.EventsDefault)
	FfiConverterInt64INSTANCE.Write(writer, value.StateDefault)
	FfiConverterInt64INSTANCE.Write(writer, value.UsersDefault)
	FfiConverterInt64INSTANCE.Write(writer, value.RoomName)
	FfiConverterInt64INSTANCE.Write(writer, value.RoomAvatar)
	FfiConverterInt64INSTANCE.Write(writer, value.RoomTopic)
}

type FfiDestroyerRoomPowerLevels struct{}

func (_ FfiDestroyerRoomPowerLevels) Destroy(value RoomPowerLevels) {
	value.Destroy()
}

// The preview of a room, be it invited/joined/left, or not.
type RoomPreviewInfo struct {
	// The room id for this room.
	RoomId string
	// The canonical alias for the room.
	CanonicalAlias *string
	// The room's name, if set.
	Name *string
	// The room's topic, if set.
	Topic *string
	// The MXC URI to the room's avatar, if set.
	AvatarUrl *string
	// The number of joined members.
	NumJoinedMembers uint64
	// The number of active members, if known (joined + invited).
	NumActiveMembers *uint64
	// The room type (space, custom) or nothing, if it's a regular room.
	RoomType RoomType
	// Is the history world-readable for this room?
	IsHistoryWorldReadable *bool
	// The membership state for the current user, if known.
	Membership *Membership
	// The join rule for this room (private, public, knock, etc.).
	JoinRule JoinRule
	// Whether the room is direct or not, if known.
	IsDirect *bool
	// Room heroes.
	Heroes *[]RoomHero
}

func (r *RoomPreviewInfo) Destroy() {
	FfiDestroyerString{}.Destroy(r.RoomId)
	FfiDestroyerOptionalString{}.Destroy(r.CanonicalAlias)
	FfiDestroyerOptionalString{}.Destroy(r.Name)
	FfiDestroyerOptionalString{}.Destroy(r.Topic)
	FfiDestroyerOptionalString{}.Destroy(r.AvatarUrl)
	FfiDestroyerUint64{}.Destroy(r.NumJoinedMembers)
	FfiDestroyerOptionalUint64{}.Destroy(r.NumActiveMembers)
	FfiDestroyerRoomType{}.Destroy(r.RoomType)
	FfiDestroyerOptionalBool{}.Destroy(r.IsHistoryWorldReadable)
	FfiDestroyerOptionalMembership{}.Destroy(r.Membership)
	FfiDestroyerJoinRule{}.Destroy(r.JoinRule)
	FfiDestroyerOptionalBool{}.Destroy(r.IsDirect)
	FfiDestroyerOptionalSequenceRoomHero{}.Destroy(r.Heroes)
}

type FfiConverterRoomPreviewInfo struct{}

var FfiConverterRoomPreviewInfoINSTANCE = FfiConverterRoomPreviewInfo{}

func (c FfiConverterRoomPreviewInfo) Lift(rb RustBufferI) RoomPreviewInfo {
	return LiftFromRustBuffer[RoomPreviewInfo](c, rb)
}

func (c FfiConverterRoomPreviewInfo) Read(reader io.Reader) RoomPreviewInfo {
	return RoomPreviewInfo{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterUint64INSTANCE.Read(reader),
		FfiConverterOptionalUint64INSTANCE.Read(reader),
		FfiConverterRoomTypeINSTANCE.Read(reader),
		FfiConverterOptionalBoolINSTANCE.Read(reader),
		FfiConverterOptionalMembershipINSTANCE.Read(reader),
		FfiConverterJoinRuleINSTANCE.Read(reader),
		FfiConverterOptionalBoolINSTANCE.Read(reader),
		FfiConverterOptionalSequenceRoomHeroINSTANCE.Read(reader),
	}
}

func (c FfiConverterRoomPreviewInfo) Lower(value RoomPreviewInfo) C.RustBuffer {
	return LowerIntoRustBuffer[RoomPreviewInfo](c, value)
}

func (c FfiConverterRoomPreviewInfo) Write(writer io.Writer, value RoomPreviewInfo) {
	FfiConverterStringINSTANCE.Write(writer, value.RoomId)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.CanonicalAlias)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Name)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Topic)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.AvatarUrl)
	FfiConverterUint64INSTANCE.Write(writer, value.NumJoinedMembers)
	FfiConverterOptionalUint64INSTANCE.Write(writer, value.NumActiveMembers)
	FfiConverterRoomTypeINSTANCE.Write(writer, value.RoomType)
	FfiConverterOptionalBoolINSTANCE.Write(writer, value.IsHistoryWorldReadable)
	FfiConverterOptionalMembershipINSTANCE.Write(writer, value.Membership)
	FfiConverterJoinRuleINSTANCE.Write(writer, value.JoinRule)
	FfiConverterOptionalBoolINSTANCE.Write(writer, value.IsDirect)
	FfiConverterOptionalSequenceRoomHeroINSTANCE.Write(writer, value.Heroes)
}

type FfiDestroyerRoomPreviewInfo struct{}

func (_ FfiDestroyerRoomPreviewInfo) Destroy(value RoomPreviewInfo) {
	value.Destroy()
}

// Contains the `m.room.tombstone` state of the room, with a message about the
// room upgrade and the id of the newly created room to replace this one.
type RoomTombstoneInfo struct {
	Body              string
	ReplacementRoomId string
}

func (r *RoomTombstoneInfo) Destroy() {
	FfiDestroyerString{}.Destroy(r.Body)
	FfiDestroyerString{}.Destroy(r.ReplacementRoomId)
}

type FfiConverterRoomTombstoneInfo struct{}

var FfiConverterRoomTombstoneInfoINSTANCE = FfiConverterRoomTombstoneInfo{}

func (c FfiConverterRoomTombstoneInfo) Lift(rb RustBufferI) RoomTombstoneInfo {
	return LiftFromRustBuffer[RoomTombstoneInfo](c, rb)
}

func (c FfiConverterRoomTombstoneInfo) Read(reader io.Reader) RoomTombstoneInfo {
	return RoomTombstoneInfo{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterRoomTombstoneInfo) Lower(value RoomTombstoneInfo) C.RustBuffer {
	return LowerIntoRustBuffer[RoomTombstoneInfo](c, value)
}

func (c FfiConverterRoomTombstoneInfo) Write(writer io.Writer, value RoomTombstoneInfo) {
	FfiConverterStringINSTANCE.Write(writer, value.Body)
	FfiConverterStringINSTANCE.Write(writer, value.ReplacementRoomId)
}

type FfiDestroyerRoomTombstoneInfo struct{}

func (_ FfiDestroyerRoomTombstoneInfo) Destroy(value RoomTombstoneInfo) {
	value.Destroy()
}

// A push ruleset scopes a set of rules according to some criteria.
type Ruleset struct {
	// These rules configure behavior for (unencrypted) messages that match
	// certain patterns.
	Content []PatternedPushRule
	// These user-configured rules are given the highest priority.
	//
	// This field is named `override_` instead of `override` because the latter
	// is a reserved keyword in Rust.
	Override []ConditionalPushRule
	// These rules change the behavior of all messages for a given room.
	Room []SimplePushRule
	// These rules configure notification behavior for messages from a specific
	// Matrix user ID.
	Sender []SimplePushRule
	// These rules are identical to override rules, but have a lower priority
	// than `content`, `room` and `sender` rules.
	Underride []ConditionalPushRule
}

func (r *Ruleset) Destroy() {
	FfiDestroyerSequencePatternedPushRule{}.Destroy(r.Content)
	FfiDestroyerSequenceConditionalPushRule{}.Destroy(r.Override)
	FfiDestroyerSequenceSimplePushRule{}.Destroy(r.Room)
	FfiDestroyerSequenceSimplePushRule{}.Destroy(r.Sender)
	FfiDestroyerSequenceConditionalPushRule{}.Destroy(r.Underride)
}

type FfiConverterRuleset struct{}

var FfiConverterRulesetINSTANCE = FfiConverterRuleset{}

func (c FfiConverterRuleset) Lift(rb RustBufferI) Ruleset {
	return LiftFromRustBuffer[Ruleset](c, rb)
}

func (c FfiConverterRuleset) Read(reader io.Reader) Ruleset {
	return Ruleset{
		FfiConverterSequencePatternedPushRuleINSTANCE.Read(reader),
		FfiConverterSequenceConditionalPushRuleINSTANCE.Read(reader),
		FfiConverterSequenceSimplePushRuleINSTANCE.Read(reader),
		FfiConverterSequenceSimplePushRuleINSTANCE.Read(reader),
		FfiConverterSequenceConditionalPushRuleINSTANCE.Read(reader),
	}
}

func (c FfiConverterRuleset) Lower(value Ruleset) C.RustBuffer {
	return LowerIntoRustBuffer[Ruleset](c, value)
}

func (c FfiConverterRuleset) Write(writer io.Writer, value Ruleset) {
	FfiConverterSequencePatternedPushRuleINSTANCE.Write(writer, value.Content)
	FfiConverterSequenceConditionalPushRuleINSTANCE.Write(writer, value.Override)
	FfiConverterSequenceSimplePushRuleINSTANCE.Write(writer, value.Room)
	FfiConverterSequenceSimplePushRuleINSTANCE.Write(writer, value.Sender)
	FfiConverterSequenceConditionalPushRuleINSTANCE.Write(writer, value.Underride)
}

type FfiDestroyerRuleset struct{}

func (_ FfiDestroyerRuleset) Destroy(value Ruleset) {
	value.Destroy()
}

type SearchUsersResults struct {
	Results []UserProfile
	Limited bool
}

func (r *SearchUsersResults) Destroy() {
	FfiDestroyerSequenceUserProfile{}.Destroy(r.Results)
	FfiDestroyerBool{}.Destroy(r.Limited)
}

type FfiConverterSearchUsersResults struct{}

var FfiConverterSearchUsersResultsINSTANCE = FfiConverterSearchUsersResults{}

func (c FfiConverterSearchUsersResults) Lift(rb RustBufferI) SearchUsersResults {
	return LiftFromRustBuffer[SearchUsersResults](c, rb)
}

func (c FfiConverterSearchUsersResults) Read(reader io.Reader) SearchUsersResults {
	return SearchUsersResults{
		FfiConverterSequenceUserProfileINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
	}
}

func (c FfiConverterSearchUsersResults) Lower(value SearchUsersResults) C.RustBuffer {
	return LowerIntoRustBuffer[SearchUsersResults](c, value)
}

func (c FfiConverterSearchUsersResults) Write(writer io.Writer, value SearchUsersResults) {
	FfiConverterSequenceUserProfileINSTANCE.Write(writer, value.Results)
	FfiConverterBoolINSTANCE.Write(writer, value.Limited)
}

type FfiDestroyerSearchUsersResults struct{}

func (_ FfiDestroyerSearchUsersResults) Destroy(value SearchUsersResults) {
	value.Destroy()
}

// The key properties for the `m.secret_storage.v1.aes-hmac-sha2“ algorithm.
type SecretStorageV1AesHmacSha2Properties struct {
	// The 16-byte initialization vector, encoded as base64.
	Iv *string
	// The MAC, encoded as base64.
	Mac *string
}

func (r *SecretStorageV1AesHmacSha2Properties) Destroy() {
	FfiDestroyerOptionalString{}.Destroy(r.Iv)
	FfiDestroyerOptionalString{}.Destroy(r.Mac)
}

type FfiConverterSecretStorageV1AesHmacSha2Properties struct{}

var FfiConverterSecretStorageV1AesHmacSha2PropertiesINSTANCE = FfiConverterSecretStorageV1AesHmacSha2Properties{}

func (c FfiConverterSecretStorageV1AesHmacSha2Properties) Lift(rb RustBufferI) SecretStorageV1AesHmacSha2Properties {
	return LiftFromRustBuffer[SecretStorageV1AesHmacSha2Properties](c, rb)
}

func (c FfiConverterSecretStorageV1AesHmacSha2Properties) Read(reader io.Reader) SecretStorageV1AesHmacSha2Properties {
	return SecretStorageV1AesHmacSha2Properties{
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterSecretStorageV1AesHmacSha2Properties) Lower(value SecretStorageV1AesHmacSha2Properties) C.RustBuffer {
	return LowerIntoRustBuffer[SecretStorageV1AesHmacSha2Properties](c, value)
}

func (c FfiConverterSecretStorageV1AesHmacSha2Properties) Write(writer io.Writer, value SecretStorageV1AesHmacSha2Properties) {
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Iv)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Mac)
}

type FfiDestroyerSecretStorageV1AesHmacSha2Properties struct{}

func (_ FfiDestroyerSecretStorageV1AesHmacSha2Properties) Destroy(value SecretStorageV1AesHmacSha2Properties) {
	value.Destroy()
}

type Session struct {
	// The access token used for this session.
	AccessToken string
	// The token used for [refreshing the access token], if any.
	//
	// [refreshing the access token]: https://spec.matrix.org/v1.3/client-server-api/#refreshing-access-tokens
	RefreshToken *string
	// The user the access token was issued for.
	UserId string
	// The ID of the client device.
	DeviceId string
	// The URL for the homeserver used for this session.
	HomeserverUrl string
	// Additional data for this session if OpenID Connect was used for
	// authentication.
	OidcData *string
	// The sliding sync version used for this session.
	SlidingSyncVersion SlidingSyncVersion
}

func (r *Session) Destroy() {
	FfiDestroyerString{}.Destroy(r.AccessToken)
	FfiDestroyerOptionalString{}.Destroy(r.RefreshToken)
	FfiDestroyerString{}.Destroy(r.UserId)
	FfiDestroyerString{}.Destroy(r.DeviceId)
	FfiDestroyerString{}.Destroy(r.HomeserverUrl)
	FfiDestroyerOptionalString{}.Destroy(r.OidcData)
	FfiDestroyerSlidingSyncVersion{}.Destroy(r.SlidingSyncVersion)
}

type FfiConverterSession struct{}

var FfiConverterSessionINSTANCE = FfiConverterSession{}

func (c FfiConverterSession) Lift(rb RustBufferI) Session {
	return LiftFromRustBuffer[Session](c, rb)
}

func (c FfiConverterSession) Read(reader io.Reader) Session {
	return Session{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterSlidingSyncVersionINSTANCE.Read(reader),
	}
}

func (c FfiConverterSession) Lower(value Session) C.RustBuffer {
	return LowerIntoRustBuffer[Session](c, value)
}

func (c FfiConverterSession) Write(writer io.Writer, value Session) {
	FfiConverterStringINSTANCE.Write(writer, value.AccessToken)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.RefreshToken)
	FfiConverterStringINSTANCE.Write(writer, value.UserId)
	FfiConverterStringINSTANCE.Write(writer, value.DeviceId)
	FfiConverterStringINSTANCE.Write(writer, value.HomeserverUrl)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.OidcData)
	FfiConverterSlidingSyncVersionINSTANCE.Write(writer, value.SlidingSyncVersion)
}

type FfiDestroyerSession struct{}

func (_ FfiDestroyerSession) Destroy(value Session) {
	value.Destroy()
}

// Details about the incoming verification request
type SessionVerificationRequestDetails struct {
	SenderProfile     UserProfile
	FlowId            string
	DeviceId          string
	DeviceDisplayName *string
	// First time this device was seen in milliseconds since epoch.
	FirstSeenTimestamp Timestamp
}

func (r *SessionVerificationRequestDetails) Destroy() {
	FfiDestroyerUserProfile{}.Destroy(r.SenderProfile)
	FfiDestroyerString{}.Destroy(r.FlowId)
	FfiDestroyerString{}.Destroy(r.DeviceId)
	FfiDestroyerOptionalString{}.Destroy(r.DeviceDisplayName)
	FfiDestroyerTypeTimestamp{}.Destroy(r.FirstSeenTimestamp)
}

type FfiConverterSessionVerificationRequestDetails struct{}

var FfiConverterSessionVerificationRequestDetailsINSTANCE = FfiConverterSessionVerificationRequestDetails{}

func (c FfiConverterSessionVerificationRequestDetails) Lift(rb RustBufferI) SessionVerificationRequestDetails {
	return LiftFromRustBuffer[SessionVerificationRequestDetails](c, rb)
}

func (c FfiConverterSessionVerificationRequestDetails) Read(reader io.Reader) SessionVerificationRequestDetails {
	return SessionVerificationRequestDetails{
		FfiConverterUserProfileINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterTypeTimestampINSTANCE.Read(reader),
	}
}

func (c FfiConverterSessionVerificationRequestDetails) Lower(value SessionVerificationRequestDetails) C.RustBuffer {
	return LowerIntoRustBuffer[SessionVerificationRequestDetails](c, value)
}

func (c FfiConverterSessionVerificationRequestDetails) Write(writer io.Writer, value SessionVerificationRequestDetails) {
	FfiConverterUserProfileINSTANCE.Write(writer, value.SenderProfile)
	FfiConverterStringINSTANCE.Write(writer, value.FlowId)
	FfiConverterStringINSTANCE.Write(writer, value.DeviceId)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.DeviceDisplayName)
	FfiConverterTypeTimestampINSTANCE.Write(writer, value.FirstSeenTimestamp)
}

type FfiDestroyerSessionVerificationRequestDetails struct{}

func (_ FfiDestroyerSessionVerificationRequestDetails) Destroy(value SessionVerificationRequestDetails) {
	value.Destroy()
}

type SetData struct {
	Index uint32
	Item  *TimelineItem
}

func (r *SetData) Destroy() {
	FfiDestroyerUint32{}.Destroy(r.Index)
	FfiDestroyerTimelineItem{}.Destroy(r.Item)
}

type FfiConverterSetData struct{}

var FfiConverterSetDataINSTANCE = FfiConverterSetData{}

func (c FfiConverterSetData) Lift(rb RustBufferI) SetData {
	return LiftFromRustBuffer[SetData](c, rb)
}

func (c FfiConverterSetData) Read(reader io.Reader) SetData {
	return SetData{
		FfiConverterUint32INSTANCE.Read(reader),
		FfiConverterTimelineItemINSTANCE.Read(reader),
	}
}

func (c FfiConverterSetData) Lower(value SetData) C.RustBuffer {
	return LowerIntoRustBuffer[SetData](c, value)
}

func (c FfiConverterSetData) Write(writer io.Writer, value SetData) {
	FfiConverterUint32INSTANCE.Write(writer, value.Index)
	FfiConverterTimelineItemINSTANCE.Write(writer, value.Item)
}

type FfiDestroyerSetData struct{}

func (_ FfiDestroyerSetData) Destroy(value SetData) {
	value.Destroy()
}

// A push rule is a single rule that states under what conditions an event
// should be passed onto a push gateway and how the notification should be
// presented.
type SimplePushRule struct {
	// Actions to determine if and how a notification is delivered for events
	// matching this rule.
	Actions []Action
	// Whether this is a default rule, or has been set explicitly.
	Default bool
	// Whether the push rule is enabled or not.
	Enabled bool
	// The ID of this rule.
	//
	// This is generally the Matrix ID of the entity that it applies to.
	RuleId string
}

func (r *SimplePushRule) Destroy() {
	FfiDestroyerSequenceAction{}.Destroy(r.Actions)
	FfiDestroyerBool{}.Destroy(r.Default)
	FfiDestroyerBool{}.Destroy(r.Enabled)
	FfiDestroyerString{}.Destroy(r.RuleId)
}

type FfiConverterSimplePushRule struct{}

var FfiConverterSimplePushRuleINSTANCE = FfiConverterSimplePushRule{}

func (c FfiConverterSimplePushRule) Lift(rb RustBufferI) SimplePushRule {
	return LiftFromRustBuffer[SimplePushRule](c, rb)
}

func (c FfiConverterSimplePushRule) Read(reader io.Reader) SimplePushRule {
	return SimplePushRule{
		FfiConverterSequenceActionINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterSimplePushRule) Lower(value SimplePushRule) C.RustBuffer {
	return LowerIntoRustBuffer[SimplePushRule](c, value)
}

func (c FfiConverterSimplePushRule) Write(writer io.Writer, value SimplePushRule) {
	FfiConverterSequenceActionINSTANCE.Write(writer, value.Actions)
	FfiConverterBoolINSTANCE.Write(writer, value.Default)
	FfiConverterBoolINSTANCE.Write(writer, value.Enabled)
	FfiConverterStringINSTANCE.Write(writer, value.RuleId)
}

type FfiDestroyerSimplePushRule struct{}

func (_ FfiDestroyerSimplePushRule) Destroy(value SimplePushRule) {
	value.Destroy()
}

// Information about a tag.
type TagInfo struct {
	// Value to use for lexicographically ordering rooms with this tag.
	Order *float64
}

func (r *TagInfo) Destroy() {
	FfiDestroyerOptionalFloat64{}.Destroy(r.Order)
}

type FfiConverterTagInfo struct{}

var FfiConverterTagInfoINSTANCE = FfiConverterTagInfo{}

func (c FfiConverterTagInfo) Lift(rb RustBufferI) TagInfo {
	return LiftFromRustBuffer[TagInfo](c, rb)
}

func (c FfiConverterTagInfo) Read(reader io.Reader) TagInfo {
	return TagInfo{
		FfiConverterOptionalFloat64INSTANCE.Read(reader),
	}
}

func (c FfiConverterTagInfo) Lower(value TagInfo) C.RustBuffer {
	return LowerIntoRustBuffer[TagInfo](c, value)
}

func (c FfiConverterTagInfo) Write(writer io.Writer, value TagInfo) {
	FfiConverterOptionalFloat64INSTANCE.Write(writer, value.Order)
}

type FfiDestroyerTagInfo struct{}

func (_ FfiDestroyerTagInfo) Destroy(value TagInfo) {
	value.Destroy()
}

type TextMessageContent struct {
	Body      string
	Formatted *FormattedBody
}

func (r *TextMessageContent) Destroy() {
	FfiDestroyerString{}.Destroy(r.Body)
	FfiDestroyerOptionalFormattedBody{}.Destroy(r.Formatted)
}

type FfiConverterTextMessageContent struct{}

var FfiConverterTextMessageContentINSTANCE = FfiConverterTextMessageContent{}

func (c FfiConverterTextMessageContent) Lift(rb RustBufferI) TextMessageContent {
	return LiftFromRustBuffer[TextMessageContent](c, rb)
}

func (c FfiConverterTextMessageContent) Read(reader io.Reader) TextMessageContent {
	return TextMessageContent{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalFormattedBodyINSTANCE.Read(reader),
	}
}

func (c FfiConverterTextMessageContent) Lower(value TextMessageContent) C.RustBuffer {
	return LowerIntoRustBuffer[TextMessageContent](c, value)
}

func (c FfiConverterTextMessageContent) Write(writer io.Writer, value TextMessageContent) {
	FfiConverterStringINSTANCE.Write(writer, value.Body)
	FfiConverterOptionalFormattedBodyINSTANCE.Write(writer, value.Formatted)
}

type FfiDestroyerTextMessageContent struct{}

func (_ FfiDestroyerTextMessageContent) Destroy(value TextMessageContent) {
	value.Destroy()
}

type ThumbnailInfo struct {
	Height   *uint64
	Width    *uint64
	Mimetype *string
	Size     *uint64
}

func (r *ThumbnailInfo) Destroy() {
	FfiDestroyerOptionalUint64{}.Destroy(r.Height)
	FfiDestroyerOptionalUint64{}.Destroy(r.Width)
	FfiDestroyerOptionalString{}.Destroy(r.Mimetype)
	FfiDestroyerOptionalUint64{}.Destroy(r.Size)
}

type FfiConverterThumbnailInfo struct{}

var FfiConverterThumbnailInfoINSTANCE = FfiConverterThumbnailInfo{}

func (c FfiConverterThumbnailInfo) Lift(rb RustBufferI) ThumbnailInfo {
	return LiftFromRustBuffer[ThumbnailInfo](c, rb)
}

func (c FfiConverterThumbnailInfo) Read(reader io.Reader) ThumbnailInfo {
	return ThumbnailInfo{
		FfiConverterOptionalUint64INSTANCE.Read(reader),
		FfiConverterOptionalUint64INSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalUint64INSTANCE.Read(reader),
	}
}

func (c FfiConverterThumbnailInfo) Lower(value ThumbnailInfo) C.RustBuffer {
	return LowerIntoRustBuffer[ThumbnailInfo](c, value)
}

func (c FfiConverterThumbnailInfo) Write(writer io.Writer, value ThumbnailInfo) {
	FfiConverterOptionalUint64INSTANCE.Write(writer, value.Height)
	FfiConverterOptionalUint64INSTANCE.Write(writer, value.Width)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Mimetype)
	FfiConverterOptionalUint64INSTANCE.Write(writer, value.Size)
}

type FfiDestroyerThumbnailInfo struct{}

func (_ FfiDestroyerThumbnailInfo) Destroy(value ThumbnailInfo) {
	value.Destroy()
}

// Various options used to configure the timeline's behavior.
type TimelineConfiguration struct {
	// What should the timeline focus on?
	Focus TimelineFocus
	// How should we filter out events from the timeline?
	Filter TimelineFilter
	// An optional String that will be prepended to
	// all the timeline item's internal IDs, making it possible to
	// distinguish different timeline instances from each other.
	InternalIdPrefix *string
	// How often to insert date dividers
	DateDividerMode DateDividerMode
	// Should the read receipts and read markers be tracked for the timeline
	// items in this instance?
	//
	// As this has a non negligible performance impact, make sure to enable it
	// only when you need it.
	TrackReadReceipts bool
	// Whether this timeline instance should report UTDs through the client's
	// delegate.
	ReportUtds bool
}

func (r *TimelineConfiguration) Destroy() {
	FfiDestroyerTimelineFocus{}.Destroy(r.Focus)
	FfiDestroyerTimelineFilter{}.Destroy(r.Filter)
	FfiDestroyerOptionalString{}.Destroy(r.InternalIdPrefix)
	FfiDestroyerDateDividerMode{}.Destroy(r.DateDividerMode)
	FfiDestroyerBool{}.Destroy(r.TrackReadReceipts)
	FfiDestroyerBool{}.Destroy(r.ReportUtds)
}

type FfiConverterTimelineConfiguration struct{}

var FfiConverterTimelineConfigurationINSTANCE = FfiConverterTimelineConfiguration{}

func (c FfiConverterTimelineConfiguration) Lift(rb RustBufferI) TimelineConfiguration {
	return LiftFromRustBuffer[TimelineConfiguration](c, rb)
}

func (c FfiConverterTimelineConfiguration) Read(reader io.Reader) TimelineConfiguration {
	return TimelineConfiguration{
		FfiConverterTimelineFocusINSTANCE.Read(reader),
		FfiConverterTimelineFilterINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterDateDividerModeINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
	}
}

func (c FfiConverterTimelineConfiguration) Lower(value TimelineConfiguration) C.RustBuffer {
	return LowerIntoRustBuffer[TimelineConfiguration](c, value)
}

func (c FfiConverterTimelineConfiguration) Write(writer io.Writer, value TimelineConfiguration) {
	FfiConverterTimelineFocusINSTANCE.Write(writer, value.Focus)
	FfiConverterTimelineFilterINSTANCE.Write(writer, value.Filter)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.InternalIdPrefix)
	FfiConverterDateDividerModeINSTANCE.Write(writer, value.DateDividerMode)
	FfiConverterBoolINSTANCE.Write(writer, value.TrackReadReceipts)
	FfiConverterBoolINSTANCE.Write(writer, value.ReportUtds)
}

type FfiDestroyerTimelineConfiguration struct{}

func (_ FfiDestroyerTimelineConfiguration) Destroy(value TimelineConfiguration) {
	value.Destroy()
}

type TimelineUniqueId struct {
	Id string
}

func (r *TimelineUniqueId) Destroy() {
	FfiDestroyerString{}.Destroy(r.Id)
}

type FfiConverterTimelineUniqueId struct{}

var FfiConverterTimelineUniqueIdINSTANCE = FfiConverterTimelineUniqueId{}

func (c FfiConverterTimelineUniqueId) Lift(rb RustBufferI) TimelineUniqueId {
	return LiftFromRustBuffer[TimelineUniqueId](c, rb)
}

func (c FfiConverterTimelineUniqueId) Read(reader io.Reader) TimelineUniqueId {
	return TimelineUniqueId{
		FfiConverterStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterTimelineUniqueId) Lower(value TimelineUniqueId) C.RustBuffer {
	return LowerIntoRustBuffer[TimelineUniqueId](c, value)
}

func (c FfiConverterTimelineUniqueId) Write(writer io.Writer, value TimelineUniqueId) {
	FfiConverterStringINSTANCE.Write(writer, value.Id)
}

type FfiDestroyerTimelineUniqueId struct{}

func (_ FfiDestroyerTimelineUniqueId) Destroy(value TimelineUniqueId) {
	value.Destroy()
}

type TracingConfiguration struct {
	// The desired log level.
	LogLevel LogLevel
	// All the log packs, that will be set to `TRACE` when they're enabled.
	TraceLogPacks []TraceLogPacks
	// Additional targets that the FFI client would like to use.
	//
	// This can include, for instance, the target names for created
	// [`crate::tracing::Span`]. These targets will use the global log level by
	// default.
	ExtraTargets []string
	// Whether to log to stdout, or in the logcat on Android.
	WriteToStdoutOrSystem bool
	// If set, configures rotated log files where to write additional logs.
	WriteToFiles *TracingFileConfiguration
}

func (r *TracingConfiguration) Destroy() {
	FfiDestroyerLogLevel{}.Destroy(r.LogLevel)
	FfiDestroyerSequenceTraceLogPacks{}.Destroy(r.TraceLogPacks)
	FfiDestroyerSequenceString{}.Destroy(r.ExtraTargets)
	FfiDestroyerBool{}.Destroy(r.WriteToStdoutOrSystem)
	FfiDestroyerOptionalTracingFileConfiguration{}.Destroy(r.WriteToFiles)
}

type FfiConverterTracingConfiguration struct{}

var FfiConverterTracingConfigurationINSTANCE = FfiConverterTracingConfiguration{}

func (c FfiConverterTracingConfiguration) Lift(rb RustBufferI) TracingConfiguration {
	return LiftFromRustBuffer[TracingConfiguration](c, rb)
}

func (c FfiConverterTracingConfiguration) Read(reader io.Reader) TracingConfiguration {
	return TracingConfiguration{
		FfiConverterLogLevelINSTANCE.Read(reader),
		FfiConverterSequenceTraceLogPacksINSTANCE.Read(reader),
		FfiConverterSequenceStringINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterOptionalTracingFileConfigurationINSTANCE.Read(reader),
	}
}

func (c FfiConverterTracingConfiguration) Lower(value TracingConfiguration) C.RustBuffer {
	return LowerIntoRustBuffer[TracingConfiguration](c, value)
}

func (c FfiConverterTracingConfiguration) Write(writer io.Writer, value TracingConfiguration) {
	FfiConverterLogLevelINSTANCE.Write(writer, value.LogLevel)
	FfiConverterSequenceTraceLogPacksINSTANCE.Write(writer, value.TraceLogPacks)
	FfiConverterSequenceStringINSTANCE.Write(writer, value.ExtraTargets)
	FfiConverterBoolINSTANCE.Write(writer, value.WriteToStdoutOrSystem)
	FfiConverterOptionalTracingFileConfigurationINSTANCE.Write(writer, value.WriteToFiles)
}

type FfiDestroyerTracingConfiguration struct{}

func (_ FfiDestroyerTracingConfiguration) Destroy(value TracingConfiguration) {
	value.Destroy()
}

// Configuration to save logs to (rotated) log-files.
type TracingFileConfiguration struct {
	// Base location for all the log files.
	Path string
	// Prefix for the log files' names.
	FilePrefix string
	// Optional suffix for the log file's names.
	FileSuffix *string
	// Maximum number of rotated files.
	//
	// If not set, there's no max limit, i.e. the number of log files is
	// unlimited.
	MaxFiles *uint64
}

func (r *TracingFileConfiguration) Destroy() {
	FfiDestroyerString{}.Destroy(r.Path)
	FfiDestroyerString{}.Destroy(r.FilePrefix)
	FfiDestroyerOptionalString{}.Destroy(r.FileSuffix)
	FfiDestroyerOptionalUint64{}.Destroy(r.MaxFiles)
}

type FfiConverterTracingFileConfiguration struct{}

var FfiConverterTracingFileConfigurationINSTANCE = FfiConverterTracingFileConfiguration{}

func (c FfiConverterTracingFileConfiguration) Lift(rb RustBufferI) TracingFileConfiguration {
	return LiftFromRustBuffer[TracingFileConfiguration](c, rb)
}

func (c FfiConverterTracingFileConfiguration) Read(reader io.Reader) TracingFileConfiguration {
	return TracingFileConfiguration{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalUint64INSTANCE.Read(reader),
	}
}

func (c FfiConverterTracingFileConfiguration) Lower(value TracingFileConfiguration) C.RustBuffer {
	return LowerIntoRustBuffer[TracingFileConfiguration](c, value)
}

func (c FfiConverterTracingFileConfiguration) Write(writer io.Writer, value TracingFileConfiguration) {
	FfiConverterStringINSTANCE.Write(writer, value.Path)
	FfiConverterStringINSTANCE.Write(writer, value.FilePrefix)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.FileSuffix)
	FfiConverterOptionalUint64INSTANCE.Write(writer, value.MaxFiles)
}

type FfiDestroyerTracingFileConfiguration struct{}

func (_ FfiDestroyerTracingFileConfiguration) Destroy(value TracingFileConfiguration) {
	value.Destroy()
}

type TransmissionProgress struct {
	Current uint64
	Total   uint64
}

func (r *TransmissionProgress) Destroy() {
	FfiDestroyerUint64{}.Destroy(r.Current)
	FfiDestroyerUint64{}.Destroy(r.Total)
}

type FfiConverterTransmissionProgress struct{}

var FfiConverterTransmissionProgressINSTANCE = FfiConverterTransmissionProgress{}

func (c FfiConverterTransmissionProgress) Lift(rb RustBufferI) TransmissionProgress {
	return LiftFromRustBuffer[TransmissionProgress](c, rb)
}

func (c FfiConverterTransmissionProgress) Read(reader io.Reader) TransmissionProgress {
	return TransmissionProgress{
		FfiConverterUint64INSTANCE.Read(reader),
		FfiConverterUint64INSTANCE.Read(reader),
	}
}

func (c FfiConverterTransmissionProgress) Lower(value TransmissionProgress) C.RustBuffer {
	return LowerIntoRustBuffer[TransmissionProgress](c, value)
}

func (c FfiConverterTransmissionProgress) Write(writer io.Writer, value TransmissionProgress) {
	FfiConverterUint64INSTANCE.Write(writer, value.Current)
	FfiConverterUint64INSTANCE.Write(writer, value.Total)
}

type FfiDestroyerTransmissionProgress struct{}

func (_ FfiDestroyerTransmissionProgress) Destroy(value TransmissionProgress) {
	value.Destroy()
}

type UnableToDecryptInfo struct {
	// The identifier of the event that couldn't get decrypted.
	EventId string
	// If the event could be decrypted late (that is, the event was encrypted
	// at first, but could be decrypted later on), then this indicates the
	// time it took to decrypt the event. If it is not set, this is
	// considered a definite UTD.
	//
	// If set, this is in milliseconds.
	TimeToDecryptMs *uint64
	// What we know about what caused this UTD. E.g. was this event sent when
	// we were not a member of this room?
	Cause matrix_sdk_crypto.UtdCause
	// The difference between the event creation time (`origin_server_ts`) and
	// the time our device was created. If negative, this event was sent
	// *before* our device was created.
	EventLocalAgeMillis int64
	// Whether the user had verified their own identity at the point they
	// received the UTD event.
	UserTrustsOwnIdentity bool
	// The homeserver of the user that sent the undecryptable event.
	SenderHomeserver string
	// Our local user's own homeserver, or `None` if the client is not logged
	// in.
	OwnHomeserver *string
}

func (r *UnableToDecryptInfo) Destroy() {
	FfiDestroyerString{}.Destroy(r.EventId)
	FfiDestroyerOptionalUint64{}.Destroy(r.TimeToDecryptMs)
	matrix_sdk_crypto.FfiDestroyerUtdCause{}.Destroy(r.Cause)
	FfiDestroyerInt64{}.Destroy(r.EventLocalAgeMillis)
	FfiDestroyerBool{}.Destroy(r.UserTrustsOwnIdentity)
	FfiDestroyerString{}.Destroy(r.SenderHomeserver)
	FfiDestroyerOptionalString{}.Destroy(r.OwnHomeserver)
}

type FfiConverterUnableToDecryptInfo struct{}

var FfiConverterUnableToDecryptInfoINSTANCE = FfiConverterUnableToDecryptInfo{}

func (c FfiConverterUnableToDecryptInfo) Lift(rb RustBufferI) UnableToDecryptInfo {
	return LiftFromRustBuffer[UnableToDecryptInfo](c, rb)
}

func (c FfiConverterUnableToDecryptInfo) Read(reader io.Reader) UnableToDecryptInfo {
	return UnableToDecryptInfo{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalUint64INSTANCE.Read(reader),
		matrix_sdk_crypto.FfiConverterUtdCauseINSTANCE.Read(reader),
		FfiConverterInt64INSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterUnableToDecryptInfo) Lower(value UnableToDecryptInfo) C.RustBuffer {
	return LowerIntoRustBuffer[UnableToDecryptInfo](c, value)
}

func (c FfiConverterUnableToDecryptInfo) Write(writer io.Writer, value UnableToDecryptInfo) {
	FfiConverterStringINSTANCE.Write(writer, value.EventId)
	FfiConverterOptionalUint64INSTANCE.Write(writer, value.TimeToDecryptMs)
	matrix_sdk_crypto.FfiConverterUtdCauseINSTANCE.Write(writer, value.Cause)
	FfiConverterInt64INSTANCE.Write(writer, value.EventLocalAgeMillis)
	FfiConverterBoolINSTANCE.Write(writer, value.UserTrustsOwnIdentity)
	FfiConverterStringINSTANCE.Write(writer, value.SenderHomeserver)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.OwnHomeserver)
}

type FfiDestroyerUnableToDecryptInfo struct{}

func (_ FfiDestroyerUnableToDecryptInfo) Destroy(value UnableToDecryptInfo) {
	value.Destroy()
}

type UnstableAudioDetailsContent struct {
	Duration time.Duration
	Waveform []uint16
}

func (r *UnstableAudioDetailsContent) Destroy() {
	FfiDestroyerDuration{}.Destroy(r.Duration)
	FfiDestroyerSequenceUint16{}.Destroy(r.Waveform)
}

type FfiConverterUnstableAudioDetailsContent struct{}

var FfiConverterUnstableAudioDetailsContentINSTANCE = FfiConverterUnstableAudioDetailsContent{}

func (c FfiConverterUnstableAudioDetailsContent) Lift(rb RustBufferI) UnstableAudioDetailsContent {
	return LiftFromRustBuffer[UnstableAudioDetailsContent](c, rb)
}

func (c FfiConverterUnstableAudioDetailsContent) Read(reader io.Reader) UnstableAudioDetailsContent {
	return UnstableAudioDetailsContent{
		FfiConverterDurationINSTANCE.Read(reader),
		FfiConverterSequenceUint16INSTANCE.Read(reader),
	}
}

func (c FfiConverterUnstableAudioDetailsContent) Lower(value UnstableAudioDetailsContent) C.RustBuffer {
	return LowerIntoRustBuffer[UnstableAudioDetailsContent](c, value)
}

func (c FfiConverterUnstableAudioDetailsContent) Write(writer io.Writer, value UnstableAudioDetailsContent) {
	FfiConverterDurationINSTANCE.Write(writer, value.Duration)
	FfiConverterSequenceUint16INSTANCE.Write(writer, value.Waveform)
}

type FfiDestroyerUnstableAudioDetailsContent struct{}

func (_ FfiDestroyerUnstableAudioDetailsContent) Destroy(value UnstableAudioDetailsContent) {
	value.Destroy()
}

type UnstableVoiceContent struct {
}

func (r *UnstableVoiceContent) Destroy() {
}

type FfiConverterUnstableVoiceContent struct{}

var FfiConverterUnstableVoiceContentINSTANCE = FfiConverterUnstableVoiceContent{}

func (c FfiConverterUnstableVoiceContent) Lift(rb RustBufferI) UnstableVoiceContent {
	return LiftFromRustBuffer[UnstableVoiceContent](c, rb)
}

func (c FfiConverterUnstableVoiceContent) Read(reader io.Reader) UnstableVoiceContent {
	return UnstableVoiceContent{}
}

func (c FfiConverterUnstableVoiceContent) Lower(value UnstableVoiceContent) C.RustBuffer {
	return LowerIntoRustBuffer[UnstableVoiceContent](c, value)
}

func (c FfiConverterUnstableVoiceContent) Write(writer io.Writer, value UnstableVoiceContent) {
}

type FfiDestroyerUnstableVoiceContent struct{}

func (_ FfiDestroyerUnstableVoiceContent) Destroy(value UnstableVoiceContent) {
	value.Destroy()
}

type UploadParameters struct {
	// Source from which to upload data
	Source UploadSource
	// Optional non-formatted caption, for clients that support it.
	Caption *string
	// Optional HTML-formatted caption, for clients that support it.
	FormattedCaption *FormattedBody
	// Optional intentional mentions to be sent with the media.
	Mentions *Mentions
	// Optional parameters for sending the media as (threaded) reply.
	ReplyParams *ReplyParameters
	// Should the media be sent with the send queue, or synchronously?
	//
	// Watching progress only works with the synchronous method, at the moment.
	UseSendQueue bool
}

func (r *UploadParameters) Destroy() {
	FfiDestroyerUploadSource{}.Destroy(r.Source)
	FfiDestroyerOptionalString{}.Destroy(r.Caption)
	FfiDestroyerOptionalFormattedBody{}.Destroy(r.FormattedCaption)
	FfiDestroyerOptionalMentions{}.Destroy(r.Mentions)
	FfiDestroyerOptionalReplyParameters{}.Destroy(r.ReplyParams)
	FfiDestroyerBool{}.Destroy(r.UseSendQueue)
}

type FfiConverterUploadParameters struct{}

var FfiConverterUploadParametersINSTANCE = FfiConverterUploadParameters{}

func (c FfiConverterUploadParameters) Lift(rb RustBufferI) UploadParameters {
	return LiftFromRustBuffer[UploadParameters](c, rb)
}

func (c FfiConverterUploadParameters) Read(reader io.Reader) UploadParameters {
	return UploadParameters{
		FfiConverterUploadSourceINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalFormattedBodyINSTANCE.Read(reader),
		FfiConverterOptionalMentionsINSTANCE.Read(reader),
		FfiConverterOptionalReplyParametersINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
	}
}

func (c FfiConverterUploadParameters) Lower(value UploadParameters) C.RustBuffer {
	return LowerIntoRustBuffer[UploadParameters](c, value)
}

func (c FfiConverterUploadParameters) Write(writer io.Writer, value UploadParameters) {
	FfiConverterUploadSourceINSTANCE.Write(writer, value.Source)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Caption)
	FfiConverterOptionalFormattedBodyINSTANCE.Write(writer, value.FormattedCaption)
	FfiConverterOptionalMentionsINSTANCE.Write(writer, value.Mentions)
	FfiConverterOptionalReplyParametersINSTANCE.Write(writer, value.ReplyParams)
	FfiConverterBoolINSTANCE.Write(writer, value.UseSendQueue)
}

type FfiDestroyerUploadParameters struct{}

func (_ FfiDestroyerUploadParameters) Destroy(value UploadParameters) {
	value.Destroy()
}

// An update for a particular user's power level within the room.
type UserPowerLevelUpdate struct {
	// The user ID of the user to update.
	UserId string
	// The power level to assign to the user.
	PowerLevel int64
}

func (r *UserPowerLevelUpdate) Destroy() {
	FfiDestroyerString{}.Destroy(r.UserId)
	FfiDestroyerInt64{}.Destroy(r.PowerLevel)
}

type FfiConverterUserPowerLevelUpdate struct{}

var FfiConverterUserPowerLevelUpdateINSTANCE = FfiConverterUserPowerLevelUpdate{}

func (c FfiConverterUserPowerLevelUpdate) Lift(rb RustBufferI) UserPowerLevelUpdate {
	return LiftFromRustBuffer[UserPowerLevelUpdate](c, rb)
}

func (c FfiConverterUserPowerLevelUpdate) Read(reader io.Reader) UserPowerLevelUpdate {
	return UserPowerLevelUpdate{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterInt64INSTANCE.Read(reader),
	}
}

func (c FfiConverterUserPowerLevelUpdate) Lower(value UserPowerLevelUpdate) C.RustBuffer {
	return LowerIntoRustBuffer[UserPowerLevelUpdate](c, value)
}

func (c FfiConverterUserPowerLevelUpdate) Write(writer io.Writer, value UserPowerLevelUpdate) {
	FfiConverterStringINSTANCE.Write(writer, value.UserId)
	FfiConverterInt64INSTANCE.Write(writer, value.PowerLevel)
}

type FfiDestroyerUserPowerLevelUpdate struct{}

func (_ FfiDestroyerUserPowerLevelUpdate) Destroy(value UserPowerLevelUpdate) {
	value.Destroy()
}

type UserProfile struct {
	UserId      string
	DisplayName *string
	AvatarUrl   *string
}

func (r *UserProfile) Destroy() {
	FfiDestroyerString{}.Destroy(r.UserId)
	FfiDestroyerOptionalString{}.Destroy(r.DisplayName)
	FfiDestroyerOptionalString{}.Destroy(r.AvatarUrl)
}

type FfiConverterUserProfile struct{}

var FfiConverterUserProfileINSTANCE = FfiConverterUserProfile{}

func (c FfiConverterUserProfile) Lift(rb RustBufferI) UserProfile {
	return LiftFromRustBuffer[UserProfile](c, rb)
}

func (c FfiConverterUserProfile) Read(reader io.Reader) UserProfile {
	return UserProfile{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterUserProfile) Lower(value UserProfile) C.RustBuffer {
	return LowerIntoRustBuffer[UserProfile](c, value)
}

func (c FfiConverterUserProfile) Write(writer io.Writer, value UserProfile) {
	FfiConverterStringINSTANCE.Write(writer, value.UserId)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.DisplayName)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.AvatarUrl)
}

type FfiDestroyerUserProfile struct{}

func (_ FfiDestroyerUserProfile) Destroy(value UserProfile) {
	value.Destroy()
}

// A user-defined tag name.
type UserTagName struct {
	Name string
}

func (r *UserTagName) Destroy() {
	FfiDestroyerString{}.Destroy(r.Name)
}

type FfiConverterUserTagName struct{}

var FfiConverterUserTagNameINSTANCE = FfiConverterUserTagName{}

func (c FfiConverterUserTagName) Lift(rb RustBufferI) UserTagName {
	return LiftFromRustBuffer[UserTagName](c, rb)
}

func (c FfiConverterUserTagName) Read(reader io.Reader) UserTagName {
	return UserTagName{
		FfiConverterStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterUserTagName) Lower(value UserTagName) C.RustBuffer {
	return LowerIntoRustBuffer[UserTagName](c, value)
}

func (c FfiConverterUserTagName) Write(writer io.Writer, value UserTagName) {
	FfiConverterStringINSTANCE.Write(writer, value.Name)
}

type FfiDestroyerUserTagName struct{}

func (_ FfiDestroyerUserTagName) Destroy(value UserTagName) {
	value.Destroy()
}

type VideoInfo struct {
	Duration        *time.Duration
	Height          *uint64
	Width           *uint64
	Mimetype        *string
	Size            *uint64
	ThumbnailInfo   *ThumbnailInfo
	ThumbnailSource **MediaSource
	Blurhash        *string
}

func (r *VideoInfo) Destroy() {
	FfiDestroyerOptionalDuration{}.Destroy(r.Duration)
	FfiDestroyerOptionalUint64{}.Destroy(r.Height)
	FfiDestroyerOptionalUint64{}.Destroy(r.Width)
	FfiDestroyerOptionalString{}.Destroy(r.Mimetype)
	FfiDestroyerOptionalUint64{}.Destroy(r.Size)
	FfiDestroyerOptionalThumbnailInfo{}.Destroy(r.ThumbnailInfo)
	FfiDestroyerOptionalMediaSource{}.Destroy(r.ThumbnailSource)
	FfiDestroyerOptionalString{}.Destroy(r.Blurhash)
}

type FfiConverterVideoInfo struct{}

var FfiConverterVideoInfoINSTANCE = FfiConverterVideoInfo{}

func (c FfiConverterVideoInfo) Lift(rb RustBufferI) VideoInfo {
	return LiftFromRustBuffer[VideoInfo](c, rb)
}

func (c FfiConverterVideoInfo) Read(reader io.Reader) VideoInfo {
	return VideoInfo{
		FfiConverterOptionalDurationINSTANCE.Read(reader),
		FfiConverterOptionalUint64INSTANCE.Read(reader),
		FfiConverterOptionalUint64INSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalUint64INSTANCE.Read(reader),
		FfiConverterOptionalThumbnailInfoINSTANCE.Read(reader),
		FfiConverterOptionalMediaSourceINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterVideoInfo) Lower(value VideoInfo) C.RustBuffer {
	return LowerIntoRustBuffer[VideoInfo](c, value)
}

func (c FfiConverterVideoInfo) Write(writer io.Writer, value VideoInfo) {
	FfiConverterOptionalDurationINSTANCE.Write(writer, value.Duration)
	FfiConverterOptionalUint64INSTANCE.Write(writer, value.Height)
	FfiConverterOptionalUint64INSTANCE.Write(writer, value.Width)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Mimetype)
	FfiConverterOptionalUint64INSTANCE.Write(writer, value.Size)
	FfiConverterOptionalThumbnailInfoINSTANCE.Write(writer, value.ThumbnailInfo)
	FfiConverterOptionalMediaSourceINSTANCE.Write(writer, value.ThumbnailSource)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Blurhash)
}

type FfiDestroyerVideoInfo struct{}

func (_ FfiDestroyerVideoInfo) Destroy(value VideoInfo) {
	value.Destroy()
}

type VideoMessageContent struct {
	// The computed filename, for use in a client.
	Filename         string
	Caption          *string
	FormattedCaption *FormattedBody
	Source           *MediaSource
	Info             *VideoInfo
}

func (r *VideoMessageContent) Destroy() {
	FfiDestroyerString{}.Destroy(r.Filename)
	FfiDestroyerOptionalString{}.Destroy(r.Caption)
	FfiDestroyerOptionalFormattedBody{}.Destroy(r.FormattedCaption)
	FfiDestroyerMediaSource{}.Destroy(r.Source)
	FfiDestroyerOptionalVideoInfo{}.Destroy(r.Info)
}

type FfiConverterVideoMessageContent struct{}

var FfiConverterVideoMessageContentINSTANCE = FfiConverterVideoMessageContent{}

func (c FfiConverterVideoMessageContent) Lift(rb RustBufferI) VideoMessageContent {
	return LiftFromRustBuffer[VideoMessageContent](c, rb)
}

func (c FfiConverterVideoMessageContent) Read(reader io.Reader) VideoMessageContent {
	return VideoMessageContent{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalFormattedBodyINSTANCE.Read(reader),
		FfiConverterMediaSourceINSTANCE.Read(reader),
		FfiConverterOptionalVideoInfoINSTANCE.Read(reader),
	}
}

func (c FfiConverterVideoMessageContent) Lower(value VideoMessageContent) C.RustBuffer {
	return LowerIntoRustBuffer[VideoMessageContent](c, value)
}

func (c FfiConverterVideoMessageContent) Write(writer io.Writer, value VideoMessageContent) {
	FfiConverterStringINSTANCE.Write(writer, value.Filename)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Caption)
	FfiConverterOptionalFormattedBodyINSTANCE.Write(writer, value.FormattedCaption)
	FfiConverterMediaSourceINSTANCE.Write(writer, value.Source)
	FfiConverterOptionalVideoInfoINSTANCE.Write(writer, value.Info)
}

type FfiDestroyerVideoMessageContent struct{}

func (_ FfiDestroyerVideoMessageContent) Destroy(value VideoMessageContent) {
	value.Destroy()
}

// Properties to create a new virtual Element Call widget.
type VirtualElementCallWidgetOptions struct {
	// The url to the Element Call app including any `/room` path if required.
	//
	// E.g. <https://call.element.io>, <https://call.element.dev>, <https://call.element.dev/room>
	ElementCallUrl string
	// The widget id.
	WidgetId string
	// The url that is used as the target for the PostMessages sent
	// by the widget (to the client).
	//
	// For a web app client this is the client url. In case of using other
	// platforms the client most likely is setup up to listen to
	// postmessages in the same webview the widget is hosted. In this case
	// the `parent_url` is set to the url of the webview with the widget. Be
	// aware that this means that the widget will receive its own postmessage
	// messages. The `matrix-widget-api` (js) ignores those so this works but
	// it might break custom implementations.
	//
	// Defaults to `element_call_url` for the non-iframe (dedicated webview)
	// usecase.
	ParentUrl *string
	// Whether the branding header of Element call should be hidden.
	//
	// Default: `true`
	HideHeader *bool
	// If set, the lobby will be skipped and the widget will join the
	// call on the `io.element.join` action.
	//
	// Default: `false`
	Preload *bool
	// The font scale which will be used inside element call.
	//
	// Default: `1`
	FontScale *float64
	// Whether element call should prompt the user to open in the browser or
	// the app.
	//
	// Default: `false`
	AppPrompt *bool
	// Make it not possible to get to the calls list in the webview.
	//
	// Default: `true`
	ConfineToRoom *bool
	// The font to use, to adapt to the system font.
	Font *string
	// The encryption system to use.
	//
	// Use `EncryptionSystem::Unencrypted` to disable encryption.
	Encryption EncryptionSystem
	// The intent of showing the call.
	// If the user wants to start a call or join an existing one.
	// Controls if the lobby is skipped or not.
	Intent *Intent
	// Do not show the screenshare button.
	HideScreensharing bool
	// Can be used to pass a PostHog id to element call.
	PosthogUserId *string
	// The host of the posthog api.
	// Supported since Element Call v0.9.0. Only used by the embedded package.
	PosthogApiHost *string
	// The key for the posthog api.
	// Supported since Element Call v0.9.0. Only used by the embedded package.
	PosthogApiKey *string
	// The url to use for submitting rageshakes.
	// Supported since Element Call v0.9.0. Only used by the embedded package.
	RageshakeSubmitUrl *string
	// Sentry [DSN](https://docs.sentry.io/concepts/key-terms/dsn-explainer/)
	// Supported since Element Call v0.9.0. Only used by the embedded package.
	SentryDsn *string
	// Sentry [environment](https://docs.sentry.io/concepts/key-terms/key-terms/)
	// Supported since Element Call v0.9.0. Only used by the embedded package.
	SentryEnvironment *string
	// - `false`: the webview shows a a list of devices injected by the
	// client. (used on ios & android)
	ControlledMediaDevices bool
}

func (r *VirtualElementCallWidgetOptions) Destroy() {
	FfiDestroyerString{}.Destroy(r.ElementCallUrl)
	FfiDestroyerString{}.Destroy(r.WidgetId)
	FfiDestroyerOptionalString{}.Destroy(r.ParentUrl)
	FfiDestroyerOptionalBool{}.Destroy(r.HideHeader)
	FfiDestroyerOptionalBool{}.Destroy(r.Preload)
	FfiDestroyerOptionalFloat64{}.Destroy(r.FontScale)
	FfiDestroyerOptionalBool{}.Destroy(r.AppPrompt)
	FfiDestroyerOptionalBool{}.Destroy(r.ConfineToRoom)
	FfiDestroyerOptionalString{}.Destroy(r.Font)
	FfiDestroyerEncryptionSystem{}.Destroy(r.Encryption)
	FfiDestroyerOptionalIntent{}.Destroy(r.Intent)
	FfiDestroyerBool{}.Destroy(r.HideScreensharing)
	FfiDestroyerOptionalString{}.Destroy(r.PosthogUserId)
	FfiDestroyerOptionalString{}.Destroy(r.PosthogApiHost)
	FfiDestroyerOptionalString{}.Destroy(r.PosthogApiKey)
	FfiDestroyerOptionalString{}.Destroy(r.RageshakeSubmitUrl)
	FfiDestroyerOptionalString{}.Destroy(r.SentryDsn)
	FfiDestroyerOptionalString{}.Destroy(r.SentryEnvironment)
	FfiDestroyerBool{}.Destroy(r.ControlledMediaDevices)
}

type FfiConverterVirtualElementCallWidgetOptions struct{}

var FfiConverterVirtualElementCallWidgetOptionsINSTANCE = FfiConverterVirtualElementCallWidgetOptions{}

func (c FfiConverterVirtualElementCallWidgetOptions) Lift(rb RustBufferI) VirtualElementCallWidgetOptions {
	return LiftFromRustBuffer[VirtualElementCallWidgetOptions](c, rb)
}

func (c FfiConverterVirtualElementCallWidgetOptions) Read(reader io.Reader) VirtualElementCallWidgetOptions {
	return VirtualElementCallWidgetOptions{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalBoolINSTANCE.Read(reader),
		FfiConverterOptionalBoolINSTANCE.Read(reader),
		FfiConverterOptionalFloat64INSTANCE.Read(reader),
		FfiConverterOptionalBoolINSTANCE.Read(reader),
		FfiConverterOptionalBoolINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterEncryptionSystemINSTANCE.Read(reader),
		FfiConverterOptionalIntentINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterOptionalStringINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
	}
}

func (c FfiConverterVirtualElementCallWidgetOptions) Lower(value VirtualElementCallWidgetOptions) C.RustBuffer {
	return LowerIntoRustBuffer[VirtualElementCallWidgetOptions](c, value)
}

func (c FfiConverterVirtualElementCallWidgetOptions) Write(writer io.Writer, value VirtualElementCallWidgetOptions) {
	FfiConverterStringINSTANCE.Write(writer, value.ElementCallUrl)
	FfiConverterStringINSTANCE.Write(writer, value.WidgetId)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.ParentUrl)
	FfiConverterOptionalBoolINSTANCE.Write(writer, value.HideHeader)
	FfiConverterOptionalBoolINSTANCE.Write(writer, value.Preload)
	FfiConverterOptionalFloat64INSTANCE.Write(writer, value.FontScale)
	FfiConverterOptionalBoolINSTANCE.Write(writer, value.AppPrompt)
	FfiConverterOptionalBoolINSTANCE.Write(writer, value.ConfineToRoom)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.Font)
	FfiConverterEncryptionSystemINSTANCE.Write(writer, value.Encryption)
	FfiConverterOptionalIntentINSTANCE.Write(writer, value.Intent)
	FfiConverterBoolINSTANCE.Write(writer, value.HideScreensharing)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.PosthogUserId)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.PosthogApiHost)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.PosthogApiKey)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.RageshakeSubmitUrl)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.SentryDsn)
	FfiConverterOptionalStringINSTANCE.Write(writer, value.SentryEnvironment)
	FfiConverterBoolINSTANCE.Write(writer, value.ControlledMediaDevices)
}

type FfiDestroyerVirtualElementCallWidgetOptions struct{}

func (_ FfiDestroyerVirtualElementCallWidgetOptions) Destroy(value VirtualElementCallWidgetOptions) {
	value.Destroy()
}

// Capabilities that a widget can request from a client.
type WidgetCapabilities struct {
	// Types of the messages that a widget wants to be able to fetch.
	Read []WidgetEventFilter
	// Types of the messages that a widget wants to be able to send.
	Send []WidgetEventFilter
	// If this capability is requested by the widget, it can not operate
	// separately from the Matrix client.
	//
	// This means clients should not offer to open the widget in a separate
	// browser/tab/webview that is not connected to the postmessage widget-api.
	RequiresClient bool
	// This allows the widget to ask the client to update delayed events.
	UpdateDelayedEvent bool
	// This allows the widget to send events with a delay.
	SendDelayedEvent bool
}

func (r *WidgetCapabilities) Destroy() {
	FfiDestroyerSequenceWidgetEventFilter{}.Destroy(r.Read)
	FfiDestroyerSequenceWidgetEventFilter{}.Destroy(r.Send)
	FfiDestroyerBool{}.Destroy(r.RequiresClient)
	FfiDestroyerBool{}.Destroy(r.UpdateDelayedEvent)
	FfiDestroyerBool{}.Destroy(r.SendDelayedEvent)
}

type FfiConverterWidgetCapabilities struct{}

var FfiConverterWidgetCapabilitiesINSTANCE = FfiConverterWidgetCapabilities{}

func (c FfiConverterWidgetCapabilities) Lift(rb RustBufferI) WidgetCapabilities {
	return LiftFromRustBuffer[WidgetCapabilities](c, rb)
}

func (c FfiConverterWidgetCapabilities) Read(reader io.Reader) WidgetCapabilities {
	return WidgetCapabilities{
		FfiConverterSequenceWidgetEventFilterINSTANCE.Read(reader),
		FfiConverterSequenceWidgetEventFilterINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
	}
}

func (c FfiConverterWidgetCapabilities) Lower(value WidgetCapabilities) C.RustBuffer {
	return LowerIntoRustBuffer[WidgetCapabilities](c, value)
}

func (c FfiConverterWidgetCapabilities) Write(writer io.Writer, value WidgetCapabilities) {
	FfiConverterSequenceWidgetEventFilterINSTANCE.Write(writer, value.Read)
	FfiConverterSequenceWidgetEventFilterINSTANCE.Write(writer, value.Send)
	FfiConverterBoolINSTANCE.Write(writer, value.RequiresClient)
	FfiConverterBoolINSTANCE.Write(writer, value.UpdateDelayedEvent)
	FfiConverterBoolINSTANCE.Write(writer, value.SendDelayedEvent)
}

type FfiDestroyerWidgetCapabilities struct{}

func (_ FfiDestroyerWidgetCapabilities) Destroy(value WidgetCapabilities) {
	value.Destroy()
}

type WidgetDriverAndHandle struct {
	Driver *WidgetDriver
	Handle *WidgetDriverHandle
}

func (r *WidgetDriverAndHandle) Destroy() {
	FfiDestroyerWidgetDriver{}.Destroy(r.Driver)
	FfiDestroyerWidgetDriverHandle{}.Destroy(r.Handle)
}

type FfiConverterWidgetDriverAndHandle struct{}

var FfiConverterWidgetDriverAndHandleINSTANCE = FfiConverterWidgetDriverAndHandle{}

func (c FfiConverterWidgetDriverAndHandle) Lift(rb RustBufferI) WidgetDriverAndHandle {
	return LiftFromRustBuffer[WidgetDriverAndHandle](c, rb)
}

func (c FfiConverterWidgetDriverAndHandle) Read(reader io.Reader) WidgetDriverAndHandle {
	return WidgetDriverAndHandle{
		FfiConverterWidgetDriverINSTANCE.Read(reader),
		FfiConverterWidgetDriverHandleINSTANCE.Read(reader),
	}
}

func (c FfiConverterWidgetDriverAndHandle) Lower(value WidgetDriverAndHandle) C.RustBuffer {
	return LowerIntoRustBuffer[WidgetDriverAndHandle](c, value)
}

func (c FfiConverterWidgetDriverAndHandle) Write(writer io.Writer, value WidgetDriverAndHandle) {
	FfiConverterWidgetDriverINSTANCE.Write(writer, value.Driver)
	FfiConverterWidgetDriverHandleINSTANCE.Write(writer, value.Handle)
}

type FfiDestroyerWidgetDriverAndHandle struct{}

func (_ FfiDestroyerWidgetDriverAndHandle) Destroy(value WidgetDriverAndHandle) {
	value.Destroy()
}

// Information about a widget.
type WidgetSettings struct {
	// Widget's unique identifier.
	WidgetId string
	// Whether or not the widget should be initialized on load message
	// (`ContentLoad` message), or upon creation/attaching of the widget to
	// the SDK's state machine that drives the API.
	InitAfterContentLoad bool
	// This contains the url from the widget state event.
	// In this url placeholders can be used to pass information from the client
	// to the widget. Possible values are: `$widgetId`, `$parentUrl`,
	// `$userId`, `$lang`, `$fontScale`, `$analyticsID`.
	//
	// # Examples
	//
	// e.g `http://widget.domain?username=$userId`
	// will become: `http://widget.domain?username=@user_matrix_id:server.domain`.
	RawUrl string
}

func (r *WidgetSettings) Destroy() {
	FfiDestroyerString{}.Destroy(r.WidgetId)
	FfiDestroyerBool{}.Destroy(r.InitAfterContentLoad)
	FfiDestroyerString{}.Destroy(r.RawUrl)
}

type FfiConverterWidgetSettings struct{}

var FfiConverterWidgetSettingsINSTANCE = FfiConverterWidgetSettings{}

func (c FfiConverterWidgetSettings) Lift(rb RustBufferI) WidgetSettings {
	return LiftFromRustBuffer[WidgetSettings](c, rb)
}

func (c FfiConverterWidgetSettings) Read(reader io.Reader) WidgetSettings {
	return WidgetSettings{
		FfiConverterStringINSTANCE.Read(reader),
		FfiConverterBoolINSTANCE.Read(reader),
		FfiConverterStringINSTANCE.Read(reader),
	}
}

func (c FfiConverterWidgetSettings) Lower(value WidgetSettings) C.RustBuffer {
	return LowerIntoRustBuffer[WidgetSettings](c, value)
}

func (c FfiConverterWidgetSettings) Write(writer io.Writer, value WidgetSettings) {
	FfiConverterStringINSTANCE.Write(writer, value.WidgetId)
	FfiConverterBoolINSTANCE.Write(writer, value.InitAfterContentLoad)
	FfiConverterStringINSTANCE.Write(writer, value.RawUrl)
}

type FfiDestroyerWidgetSettings struct{}

func (_ FfiDestroyerWidgetSettings) Destroy(value WidgetSettings) {
	value.Destroy()
}

// Global account data events.
type AccountDataEvent interface {
	Destroy()
}

// m.direct
type AccountDataEventDirect struct {
	Map map[string][]string
}

func (e AccountDataEventDirect) Destroy() {
	FfiDestroyerMapStringSequenceString{}.Destroy(e.Map)
}

// m.identity_server
type AccountDataEventIdentityServer struct {
	BaseUrl *string
}

func (e AccountDataEventIdentityServer) Destroy() {
	FfiDestroyerOptionalString{}.Destroy(e.BaseUrl)
}

// m.ignored_user_list
type AccountDataEventIgnoredUserList struct {
	IgnoredUsers map[string]IgnoredUser
}

func (e AccountDataEventIgnoredUserList) Destroy() {
	FfiDestroyerMapStringIgnoredUser{}.Destroy(e.IgnoredUsers)
}

// m.push_rules
type AccountDataEventPushRules struct {
	Global Ruleset
}

func (e AccountDataEventPushRules) Destroy() {
	FfiDestroyerRuleset{}.Destroy(e.Global)
}

// m.secret_storage.default_key
type AccountDataEventSecretStorageDefaultKey struct {
	KeyId string
}

func (e AccountDataEventSecretStorageDefaultKey) Destroy() {
	FfiDestroyerString{}.Destroy(e.KeyId)
}

// m.secret_storage.key.*
type AccountDataEventSecretStorageKey struct {
	KeyId      string
	Name       *string
	Algorithm  SecretStorageEncryptionAlgorithm
	Passphrase *PassPhrase
}

func (e AccountDataEventSecretStorageKey) Destroy() {
	FfiDestroyerString{}.Destroy(e.KeyId)
	FfiDestroyerOptionalString{}.Destroy(e.Name)
	FfiDestroyerSecretStorageEncryptionAlgorithm{}.Destroy(e.Algorithm)
	FfiDestroyerOptionalPassPhrase{}.Destroy(e.Passphrase)
}

type FfiConverterAccountDataEvent struct{}

var FfiConverterAccountDataEventINSTANCE = FfiConverterAccountDataEvent{}

func (c FfiConverterAccountDataEvent) Lift(rb RustBufferI) AccountDataEvent {
	return LiftFromRustBuffer[AccountDataEvent](c, rb)
}

func (c FfiConverterAccountDataEvent) Lower(value AccountDataEvent) C.RustBuffer {
	return LowerIntoRustBuffer[AccountDataEvent](c, value)
}
func (FfiConverterAccountDataEvent) Read(reader io.Reader) AccountDataEvent {
	id := readInt32(reader)
	switch id {
	case 1:
		return AccountDataEventDirect{
			FfiConverterMapStringSequenceStringINSTANCE.Read(reader),
		}
	case 2:
		return AccountDataEventIdentityServer{
			FfiConverterOptionalStringINSTANCE.Read(reader),
		}
	case 3:
		return AccountDataEventIgnoredUserList{
			FfiConverterMapStringIgnoredUserINSTANCE.Read(reader),
		}
	case 4:
		return AccountDataEventPushRules{
			FfiConverterRulesetINSTANCE.Read(reader),
		}
	case 5:
		return AccountDataEventSecretStorageDefaultKey{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 6:
		return AccountDataEventSecretStorageKey{
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterSecretStorageEncryptionAlgorithmINSTANCE.Read(reader),
			FfiConverterOptionalPassPhraseINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterAccountDataEvent.Read()", id))
	}
}

func (FfiConverterAccountDataEvent) Write(writer io.Writer, value AccountDataEvent) {
	switch variant_value := value.(type) {
	case AccountDataEventDirect:
		writeInt32(writer, 1)
		FfiConverterMapStringSequenceStringINSTANCE.Write(writer, variant_value.Map)
	case AccountDataEventIdentityServer:
		writeInt32(writer, 2)
		FfiConverterOptionalStringINSTANCE.Write(writer, variant_value.BaseUrl)
	case AccountDataEventIgnoredUserList:
		writeInt32(writer, 3)
		FfiConverterMapStringIgnoredUserINSTANCE.Write(writer, variant_value.IgnoredUsers)
	case AccountDataEventPushRules:
		writeInt32(writer, 4)
		FfiConverterRulesetINSTANCE.Write(writer, variant_value.Global)
	case AccountDataEventSecretStorageDefaultKey:
		writeInt32(writer, 5)
		FfiConverterStringINSTANCE.Write(writer, variant_value.KeyId)
	case AccountDataEventSecretStorageKey:
		writeInt32(writer, 6)
		FfiConverterStringINSTANCE.Write(writer, variant_value.KeyId)
		FfiConverterOptionalStringINSTANCE.Write(writer, variant_value.Name)
		FfiConverterSecretStorageEncryptionAlgorithmINSTANCE.Write(writer, variant_value.Algorithm)
		FfiConverterOptionalPassPhraseINSTANCE.Write(writer, variant_value.Passphrase)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterAccountDataEvent.Write", value))
	}
}

type FfiDestroyerAccountDataEvent struct{}

func (_ FfiDestroyerAccountDataEvent) Destroy(value AccountDataEvent) {
	value.Destroy()
}

// Types of global account data events.
type AccountDataEventType interface {
	Destroy()
}

// m.direct
type AccountDataEventTypeDirect struct {
}

func (e AccountDataEventTypeDirect) Destroy() {
}

// m.identity_server
type AccountDataEventTypeIdentityServer struct {
}

func (e AccountDataEventTypeIdentityServer) Destroy() {
}

// m.ignored_user_list
type AccountDataEventTypeIgnoredUserList struct {
}

func (e AccountDataEventTypeIgnoredUserList) Destroy() {
}

// m.push_rules
type AccountDataEventTypePushRules struct {
}

func (e AccountDataEventTypePushRules) Destroy() {
}

// m.secret_storage.default_key
type AccountDataEventTypeSecretStorageDefaultKey struct {
}

func (e AccountDataEventTypeSecretStorageDefaultKey) Destroy() {
}

// m.secret_storage.key.*
type AccountDataEventTypeSecretStorageKey struct {
	KeyId string
}

func (e AccountDataEventTypeSecretStorageKey) Destroy() {
	FfiDestroyerString{}.Destroy(e.KeyId)
}

type FfiConverterAccountDataEventType struct{}

var FfiConverterAccountDataEventTypeINSTANCE = FfiConverterAccountDataEventType{}

func (c FfiConverterAccountDataEventType) Lift(rb RustBufferI) AccountDataEventType {
	return LiftFromRustBuffer[AccountDataEventType](c, rb)
}

func (c FfiConverterAccountDataEventType) Lower(value AccountDataEventType) C.RustBuffer {
	return LowerIntoRustBuffer[AccountDataEventType](c, value)
}
func (FfiConverterAccountDataEventType) Read(reader io.Reader) AccountDataEventType {
	id := readInt32(reader)
	switch id {
	case 1:
		return AccountDataEventTypeDirect{}
	case 2:
		return AccountDataEventTypeIdentityServer{}
	case 3:
		return AccountDataEventTypeIgnoredUserList{}
	case 4:
		return AccountDataEventTypePushRules{}
	case 5:
		return AccountDataEventTypeSecretStorageDefaultKey{}
	case 6:
		return AccountDataEventTypeSecretStorageKey{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterAccountDataEventType.Read()", id))
	}
}

func (FfiConverterAccountDataEventType) Write(writer io.Writer, value AccountDataEventType) {
	switch variant_value := value.(type) {
	case AccountDataEventTypeDirect:
		writeInt32(writer, 1)
	case AccountDataEventTypeIdentityServer:
		writeInt32(writer, 2)
	case AccountDataEventTypeIgnoredUserList:
		writeInt32(writer, 3)
	case AccountDataEventTypePushRules:
		writeInt32(writer, 4)
	case AccountDataEventTypeSecretStorageDefaultKey:
		writeInt32(writer, 5)
	case AccountDataEventTypeSecretStorageKey:
		writeInt32(writer, 6)
		FfiConverterStringINSTANCE.Write(writer, variant_value.KeyId)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterAccountDataEventType.Write", value))
	}
}

type FfiDestroyerAccountDataEventType struct{}

func (_ FfiDestroyerAccountDataEventType) Destroy(value AccountDataEventType) {
	value.Destroy()
}

type AccountManagementAction interface {
	Destroy()
}
type AccountManagementActionProfile struct {
}

func (e AccountManagementActionProfile) Destroy() {
}

type AccountManagementActionSessionsList struct {
}

func (e AccountManagementActionSessionsList) Destroy() {
}

type AccountManagementActionSessionView struct {
	DeviceId string
}

func (e AccountManagementActionSessionView) Destroy() {
	FfiDestroyerString{}.Destroy(e.DeviceId)
}

type AccountManagementActionSessionEnd struct {
	DeviceId string
}

func (e AccountManagementActionSessionEnd) Destroy() {
	FfiDestroyerString{}.Destroy(e.DeviceId)
}

type AccountManagementActionAccountDeactivate struct {
}

func (e AccountManagementActionAccountDeactivate) Destroy() {
}

type AccountManagementActionCrossSigningReset struct {
}

func (e AccountManagementActionCrossSigningReset) Destroy() {
}

type FfiConverterAccountManagementAction struct{}

var FfiConverterAccountManagementActionINSTANCE = FfiConverterAccountManagementAction{}

func (c FfiConverterAccountManagementAction) Lift(rb RustBufferI) AccountManagementAction {
	return LiftFromRustBuffer[AccountManagementAction](c, rb)
}

func (c FfiConverterAccountManagementAction) Lower(value AccountManagementAction) C.RustBuffer {
	return LowerIntoRustBuffer[AccountManagementAction](c, value)
}
func (FfiConverterAccountManagementAction) Read(reader io.Reader) AccountManagementAction {
	id := readInt32(reader)
	switch id {
	case 1:
		return AccountManagementActionProfile{}
	case 2:
		return AccountManagementActionSessionsList{}
	case 3:
		return AccountManagementActionSessionView{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 4:
		return AccountManagementActionSessionEnd{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 5:
		return AccountManagementActionAccountDeactivate{}
	case 6:
		return AccountManagementActionCrossSigningReset{}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterAccountManagementAction.Read()", id))
	}
}

func (FfiConverterAccountManagementAction) Write(writer io.Writer, value AccountManagementAction) {
	switch variant_value := value.(type) {
	case AccountManagementActionProfile:
		writeInt32(writer, 1)
	case AccountManagementActionSessionsList:
		writeInt32(writer, 2)
	case AccountManagementActionSessionView:
		writeInt32(writer, 3)
		FfiConverterStringINSTANCE.Write(writer, variant_value.DeviceId)
	case AccountManagementActionSessionEnd:
		writeInt32(writer, 4)
		FfiConverterStringINSTANCE.Write(writer, variant_value.DeviceId)
	case AccountManagementActionAccountDeactivate:
		writeInt32(writer, 5)
	case AccountManagementActionCrossSigningReset:
		writeInt32(writer, 6)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterAccountManagementAction.Write", value))
	}
}

type FfiDestroyerAccountManagementAction struct{}

func (_ FfiDestroyerAccountManagementAction) Destroy(value AccountManagementAction) {
	value.Destroy()
}

// Enum representing the push notification actions for a rule.
type Action interface {
	Destroy()
}

// Causes matching events to generate a notification.
type ActionNotify struct {
}

func (e ActionNotify) Destroy() {
}

// Sets an entry in the 'tweaks' dictionary sent to the push gateway.
type ActionSetTweak struct {
	Value Tweak
}

func (e ActionSetTweak) Destroy() {
	FfiDestroyerTweak{}.Destroy(e.Value)
}

type FfiConverterAction struct{}

var FfiConverterActionINSTANCE = FfiConverterAction{}

func (c FfiConverterAction) Lift(rb RustBufferI) Action {
	return LiftFromRustBuffer[Action](c, rb)
}

func (c FfiConverterAction) Lower(value Action) C.RustBuffer {
	return LowerIntoRustBuffer[Action](c, value)
}
func (FfiConverterAction) Read(reader io.Reader) Action {
	id := readInt32(reader)
	switch id {
	case 1:
		return ActionNotify{}
	case 2:
		return ActionSetTweak{
			FfiConverterTweakINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterAction.Read()", id))
	}
}

func (FfiConverterAction) Write(writer io.Writer, value Action) {
	switch variant_value := value.(type) {
	case ActionNotify:
		writeInt32(writer, 1)
	case ActionSetTweak:
		writeInt32(writer, 2)
		FfiConverterTweakINSTANCE.Write(writer, variant_value.Value)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterAction.Write", value))
	}
}

type FfiDestroyerAction struct{}

func (_ FfiDestroyerAction) Destroy(value Action) {
	value.Destroy()
}

// An allow rule which defines a condition that allows joining a room.
type AllowRule interface {
	Destroy()
}

// Only a member of the `room_id` Room can join the one this rule is used
// in.
type AllowRuleRoomMembership struct {
	RoomId string
}

func (e AllowRuleRoomMembership) Destroy() {
	FfiDestroyerString{}.Destroy(e.RoomId)
}

// A custom allow rule implementation, containing its JSON representation
// as a `String`.
type AllowRuleCustom struct {
	Json string
}

func (e AllowRuleCustom) Destroy() {
	FfiDestroyerString{}.Destroy(e.Json)
}

type FfiConverterAllowRule struct{}

var FfiConverterAllowRuleINSTANCE = FfiConverterAllowRule{}

func (c FfiConverterAllowRule) Lift(rb RustBufferI) AllowRule {
	return LiftFromRustBuffer[AllowRule](c, rb)
}

func (c FfiConverterAllowRule) Lower(value AllowRule) C.RustBuffer {
	return LowerIntoRustBuffer[AllowRule](c, value)
}
func (FfiConverterAllowRule) Read(reader io.Reader) AllowRule {
	id := readInt32(reader)
	switch id {
	case 1:
		return AllowRuleRoomMembership{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 2:
		return AllowRuleCustom{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterAllowRule.Read()", id))
	}
}

func (FfiConverterAllowRule) Write(writer io.Writer, value AllowRule) {
	switch variant_value := value.(type) {
	case AllowRuleRoomMembership:
		writeInt32(writer, 1)
		FfiConverterStringINSTANCE.Write(writer, variant_value.RoomId)
	case AllowRuleCustom:
		writeInt32(writer, 2)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Json)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterAllowRule.Write", value))
	}
}

type FfiDestroyerAllowRule struct{}

func (_ FfiDestroyerAllowRule) Destroy(value AllowRule) {
	value.Destroy()
}

type AssetType uint

const (
	AssetTypeSender AssetType = 1
	AssetTypePin    AssetType = 2
)

type FfiConverterAssetType struct{}

var FfiConverterAssetTypeINSTANCE = FfiConverterAssetType{}

func (c FfiConverterAssetType) Lift(rb RustBufferI) AssetType {
	return LiftFromRustBuffer[AssetType](c, rb)
}

func (c FfiConverterAssetType) Lower(value AssetType) C.RustBuffer {
	return LowerIntoRustBuffer[AssetType](c, value)
}
func (FfiConverterAssetType) Read(reader io.Reader) AssetType {
	id := readInt32(reader)
	return AssetType(id)
}

func (FfiConverterAssetType) Write(writer io.Writer, value AssetType) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerAssetType struct{}

func (_ FfiDestroyerAssetType) Destroy(value AssetType) {
}

type AuthData interface {
	Destroy()
}

// Password-based authentication (`m.login.password`).
type AuthDataPassword struct {
	PasswordDetails AuthDataPasswordDetails
}

func (e AuthDataPassword) Destroy() {
	FfiDestroyerAuthDataPasswordDetails{}.Destroy(e.PasswordDetails)
}

type FfiConverterAuthData struct{}

var FfiConverterAuthDataINSTANCE = FfiConverterAuthData{}

func (c FfiConverterAuthData) Lift(rb RustBufferI) AuthData {
	return LiftFromRustBuffer[AuthData](c, rb)
}

func (c FfiConverterAuthData) Lower(value AuthData) C.RustBuffer {
	return LowerIntoRustBuffer[AuthData](c, value)
}
func (FfiConverterAuthData) Read(reader io.Reader) AuthData {
	id := readInt32(reader)
	switch id {
	case 1:
		return AuthDataPassword{
			FfiConverterAuthDataPasswordDetailsINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterAuthData.Read()", id))
	}
}

func (FfiConverterAuthData) Write(writer io.Writer, value AuthData) {
	switch variant_value := value.(type) {
	case AuthDataPassword:
		writeInt32(writer, 1)
		FfiConverterAuthDataPasswordDetailsINSTANCE.Write(writer, variant_value.PasswordDetails)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterAuthData.Write", value))
	}
}

type FfiDestroyerAuthData struct{}

func (_ FfiDestroyerAuthData) Destroy(value AuthData) {
	value.Destroy()
}

type BackupState uint

const (
	BackupStateUnknown     BackupState = 1
	BackupStateCreating    BackupState = 2
	BackupStateEnabling    BackupState = 3
	BackupStateResuming    BackupState = 4
	BackupStateEnabled     BackupState = 5
	BackupStateDownloading BackupState = 6
	BackupStateDisabling   BackupState = 7
)

type FfiConverterBackupState struct{}

var FfiConverterBackupStateINSTANCE = FfiConverterBackupState{}

func (c FfiConverterBackupState) Lift(rb RustBufferI) BackupState {
	return LiftFromRustBuffer[BackupState](c, rb)
}

func (c FfiConverterBackupState) Lower(value BackupState) C.RustBuffer {
	return LowerIntoRustBuffer[BackupState](c, value)
}
func (FfiConverterBackupState) Read(reader io.Reader) BackupState {
	id := readInt32(reader)
	return BackupState(id)
}

func (FfiConverterBackupState) Write(writer io.Writer, value BackupState) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerBackupState struct{}

func (_ FfiDestroyerBackupState) Destroy(value BackupState) {
}

type BackupUploadState interface {
	Destroy()
}
type BackupUploadStateWaiting struct {
}

func (e BackupUploadStateWaiting) Destroy() {
}

type BackupUploadStateUploading struct {
	BackedUpCount uint32
	TotalCount    uint32
}

func (e BackupUploadStateUploading) Destroy() {
	FfiDestroyerUint32{}.Destroy(e.BackedUpCount)
	FfiDestroyerUint32{}.Destroy(e.TotalCount)
}

type BackupUploadStateError struct {
}

func (e BackupUploadStateError) Destroy() {
}

type BackupUploadStateDone struct {
}

func (e BackupUploadStateDone) Destroy() {
}

type FfiConverterBackupUploadState struct{}

var FfiConverterBackupUploadStateINSTANCE = FfiConverterBackupUploadState{}

func (c FfiConverterBackupUploadState) Lift(rb RustBufferI) BackupUploadState {
	return LiftFromRustBuffer[BackupUploadState](c, rb)
}

func (c FfiConverterBackupUploadState) Lower(value BackupUploadState) C.RustBuffer {
	return LowerIntoRustBuffer[BackupUploadState](c, value)
}
func (FfiConverterBackupUploadState) Read(reader io.Reader) BackupUploadState {
	id := readInt32(reader)
	switch id {
	case 1:
		return BackupUploadStateWaiting{}
	case 2:
		return BackupUploadStateUploading{
			FfiConverterUint32INSTANCE.Read(reader),
			FfiConverterUint32INSTANCE.Read(reader),
		}
	case 3:
		return BackupUploadStateError{}
	case 4:
		return BackupUploadStateDone{}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterBackupUploadState.Read()", id))
	}
}

func (FfiConverterBackupUploadState) Write(writer io.Writer, value BackupUploadState) {
	switch variant_value := value.(type) {
	case BackupUploadStateWaiting:
		writeInt32(writer, 1)
	case BackupUploadStateUploading:
		writeInt32(writer, 2)
		FfiConverterUint32INSTANCE.Write(writer, variant_value.BackedUpCount)
		FfiConverterUint32INSTANCE.Write(writer, variant_value.TotalCount)
	case BackupUploadStateError:
		writeInt32(writer, 3)
	case BackupUploadStateDone:
		writeInt32(writer, 4)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterBackupUploadState.Write", value))
	}
}

type FfiDestroyerBackupUploadState struct{}

func (_ FfiDestroyerBackupUploadState) Destroy(value BackupUploadState) {
	value.Destroy()
}

type ClientBuildError struct {
	err error
}

// Convience method to turn *ClientBuildError into error
// Avoiding treating nil pointer as non nil error interface
func (err *ClientBuildError) AsError() error {
	if err == nil {
		return nil
	} else {
		return err
	}
}

func (err ClientBuildError) Error() string {
	return fmt.Sprintf("ClientBuildError: %s", err.err.Error())
}

func (err ClientBuildError) Unwrap() error {
	return err.err
}

// Err* are used for checking error type with `errors.Is`
var ErrClientBuildErrorInvalidServerName = fmt.Errorf("ClientBuildErrorInvalidServerName")
var ErrClientBuildErrorServerUnreachable = fmt.Errorf("ClientBuildErrorServerUnreachable")
var ErrClientBuildErrorWellKnownLookupFailed = fmt.Errorf("ClientBuildErrorWellKnownLookupFailed")
var ErrClientBuildErrorWellKnownDeserializationError = fmt.Errorf("ClientBuildErrorWellKnownDeserializationError")
var ErrClientBuildErrorSlidingSync = fmt.Errorf("ClientBuildErrorSlidingSync")
var ErrClientBuildErrorSlidingSyncVersion = fmt.Errorf("ClientBuildErrorSlidingSyncVersion")
var ErrClientBuildErrorSdk = fmt.Errorf("ClientBuildErrorSdk")
var ErrClientBuildErrorEventCache = fmt.Errorf("ClientBuildErrorEventCache")
var ErrClientBuildErrorGeneric = fmt.Errorf("ClientBuildErrorGeneric")

// Variant structs
type ClientBuildErrorInvalidServerName struct {
	message string
}

func NewClientBuildErrorInvalidServerName() *ClientBuildError {
	return &ClientBuildError{err: &ClientBuildErrorInvalidServerName{}}
}

func (e ClientBuildErrorInvalidServerName) destroy() {
}

func (err ClientBuildErrorInvalidServerName) Error() string {
	return fmt.Sprintf("InvalidServerName: %s", err.message)
}

func (self ClientBuildErrorInvalidServerName) Is(target error) bool {
	return target == ErrClientBuildErrorInvalidServerName
}

type ClientBuildErrorServerUnreachable struct {
	message string
}

func NewClientBuildErrorServerUnreachable() *ClientBuildError {
	return &ClientBuildError{err: &ClientBuildErrorServerUnreachable{}}
}

func (e ClientBuildErrorServerUnreachable) destroy() {
}

func (err ClientBuildErrorServerUnreachable) Error() string {
	return fmt.Sprintf("ServerUnreachable: %s", err.message)
}

func (self ClientBuildErrorServerUnreachable) Is(target error) bool {
	return target == ErrClientBuildErrorServerUnreachable
}

type ClientBuildErrorWellKnownLookupFailed struct {
	message string
}

func NewClientBuildErrorWellKnownLookupFailed() *ClientBuildError {
	return &ClientBuildError{err: &ClientBuildErrorWellKnownLookupFailed{}}
}

func (e ClientBuildErrorWellKnownLookupFailed) destroy() {
}

func (err ClientBuildErrorWellKnownLookupFailed) Error() string {
	return fmt.Sprintf("WellKnownLookupFailed: %s", err.message)
}

func (self ClientBuildErrorWellKnownLookupFailed) Is(target error) bool {
	return target == ErrClientBuildErrorWellKnownLookupFailed
}

type ClientBuildErrorWellKnownDeserializationError struct {
	message string
}

func NewClientBuildErrorWellKnownDeserializationError() *ClientBuildError {
	return &ClientBuildError{err: &ClientBuildErrorWellKnownDeserializationError{}}
}

func (e ClientBuildErrorWellKnownDeserializationError) destroy() {
}

func (err ClientBuildErrorWellKnownDeserializationError) Error() string {
	return fmt.Sprintf("WellKnownDeserializationError: %s", err.message)
}

func (self ClientBuildErrorWellKnownDeserializationError) Is(target error) bool {
	return target == ErrClientBuildErrorWellKnownDeserializationError
}

type ClientBuildErrorSlidingSync struct {
	message string
}

func NewClientBuildErrorSlidingSync() *ClientBuildError {
	return &ClientBuildError{err: &ClientBuildErrorSlidingSync{}}
}

func (e ClientBuildErrorSlidingSync) destroy() {
}

func (err ClientBuildErrorSlidingSync) Error() string {
	return fmt.Sprintf("SlidingSync: %s", err.message)
}

func (self ClientBuildErrorSlidingSync) Is(target error) bool {
	return target == ErrClientBuildErrorSlidingSync
}

type ClientBuildErrorSlidingSyncVersion struct {
	message string
}

func NewClientBuildErrorSlidingSyncVersion() *ClientBuildError {
	return &ClientBuildError{err: &ClientBuildErrorSlidingSyncVersion{}}
}

func (e ClientBuildErrorSlidingSyncVersion) destroy() {
}

func (err ClientBuildErrorSlidingSyncVersion) Error() string {
	return fmt.Sprintf("SlidingSyncVersion: %s", err.message)
}

func (self ClientBuildErrorSlidingSyncVersion) Is(target error) bool {
	return target == ErrClientBuildErrorSlidingSyncVersion
}

type ClientBuildErrorSdk struct {
	message string
}

func NewClientBuildErrorSdk() *ClientBuildError {
	return &ClientBuildError{err: &ClientBuildErrorSdk{}}
}

func (e ClientBuildErrorSdk) destroy() {
}

func (err ClientBuildErrorSdk) Error() string {
	return fmt.Sprintf("Sdk: %s", err.message)
}

func (self ClientBuildErrorSdk) Is(target error) bool {
	return target == ErrClientBuildErrorSdk
}

type ClientBuildErrorEventCache struct {
	message string
}

func NewClientBuildErrorEventCache() *ClientBuildError {
	return &ClientBuildError{err: &ClientBuildErrorEventCache{}}
}

func (e ClientBuildErrorEventCache) destroy() {
}

func (err ClientBuildErrorEventCache) Error() string {
	return fmt.Sprintf("EventCache: %s", err.message)
}

func (self ClientBuildErrorEventCache) Is(target error) bool {
	return target == ErrClientBuildErrorEventCache
}

type ClientBuildErrorGeneric struct {
	message string
}

func NewClientBuildErrorGeneric() *ClientBuildError {
	return &ClientBuildError{err: &ClientBuildErrorGeneric{}}
}

func (e ClientBuildErrorGeneric) destroy() {
}

func (err ClientBuildErrorGeneric) Error() string {
	return fmt.Sprintf("Generic: %s", err.message)
}

func (self ClientBuildErrorGeneric) Is(target error) bool {
	return target == ErrClientBuildErrorGeneric
}

type FfiConverterClientBuildError struct{}

var FfiConverterClientBuildErrorINSTANCE = FfiConverterClientBuildError{}

func (c FfiConverterClientBuildError) Lift(eb RustBufferI) *ClientBuildError {
	return LiftFromRustBuffer[*ClientBuildError](c, eb)
}

func (c FfiConverterClientBuildError) Lower(value *ClientBuildError) C.RustBuffer {
	return LowerIntoRustBuffer[*ClientBuildError](c, value)
}

func (c FfiConverterClientBuildError) Read(reader io.Reader) *ClientBuildError {
	errorID := readUint32(reader)

	message := FfiConverterStringINSTANCE.Read(reader)
	switch errorID {
	case 1:
		return &ClientBuildError{&ClientBuildErrorInvalidServerName{message}}
	case 2:
		return &ClientBuildError{&ClientBuildErrorServerUnreachable{message}}
	case 3:
		return &ClientBuildError{&ClientBuildErrorWellKnownLookupFailed{message}}
	case 4:
		return &ClientBuildError{&ClientBuildErrorWellKnownDeserializationError{message}}
	case 5:
		return &ClientBuildError{&ClientBuildErrorSlidingSync{message}}
	case 6:
		return &ClientBuildError{&ClientBuildErrorSlidingSyncVersion{message}}
	case 7:
		return &ClientBuildError{&ClientBuildErrorSdk{message}}
	case 8:
		return &ClientBuildError{&ClientBuildErrorEventCache{message}}
	case 9:
		return &ClientBuildError{&ClientBuildErrorGeneric{message}}
	default:
		panic(fmt.Sprintf("Unknown error code %d in FfiConverterClientBuildError.Read()", errorID))
	}

}

func (c FfiConverterClientBuildError) Write(writer io.Writer, value *ClientBuildError) {
	switch variantValue := value.err.(type) {
	case *ClientBuildErrorInvalidServerName:
		writeInt32(writer, 1)
	case *ClientBuildErrorServerUnreachable:
		writeInt32(writer, 2)
	case *ClientBuildErrorWellKnownLookupFailed:
		writeInt32(writer, 3)
	case *ClientBuildErrorWellKnownDeserializationError:
		writeInt32(writer, 4)
	case *ClientBuildErrorSlidingSync:
		writeInt32(writer, 5)
	case *ClientBuildErrorSlidingSyncVersion:
		writeInt32(writer, 6)
	case *ClientBuildErrorSdk:
		writeInt32(writer, 7)
	case *ClientBuildErrorEventCache:
		writeInt32(writer, 8)
	case *ClientBuildErrorGeneric:
		writeInt32(writer, 9)
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiConverterClientBuildError.Write", value))
	}
}

type FfiDestroyerClientBuildError struct{}

func (_ FfiDestroyerClientBuildError) Destroy(value *ClientBuildError) {
	switch variantValue := value.err.(type) {
	case ClientBuildErrorInvalidServerName:
		variantValue.destroy()
	case ClientBuildErrorServerUnreachable:
		variantValue.destroy()
	case ClientBuildErrorWellKnownLookupFailed:
		variantValue.destroy()
	case ClientBuildErrorWellKnownDeserializationError:
		variantValue.destroy()
	case ClientBuildErrorSlidingSync:
		variantValue.destroy()
	case ClientBuildErrorSlidingSyncVersion:
		variantValue.destroy()
	case ClientBuildErrorSdk:
		variantValue.destroy()
	case ClientBuildErrorEventCache:
		variantValue.destroy()
	case ClientBuildErrorGeneric:
		variantValue.destroy()
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiDestroyerClientBuildError.Destroy", value))
	}
}

type ClientError struct {
	err error
}

// Convience method to turn *ClientError into error
// Avoiding treating nil pointer as non nil error interface
func (err *ClientError) AsError() error {
	if err == nil {
		return nil
	} else {
		return err
	}
}

func (err ClientError) Error() string {
	return fmt.Sprintf("ClientError: %s", err.err.Error())
}

func (err ClientError) Unwrap() error {
	return err.err
}

// Err* are used for checking error type with `errors.Is`
var ErrClientErrorGeneric = fmt.Errorf("ClientErrorGeneric")
var ErrClientErrorMatrixApi = fmt.Errorf("ClientErrorMatrixApi")

// Variant structs
type ClientErrorGeneric struct {
	Msg     string
	Details *string
}

func NewClientErrorGeneric(
	msg string,
	details *string,
) *ClientError {
	return &ClientError{err: &ClientErrorGeneric{
		Msg:     msg,
		Details: details}}
}

func (e ClientErrorGeneric) destroy() {
	FfiDestroyerString{}.Destroy(e.Msg)
	FfiDestroyerOptionalString{}.Destroy(e.Details)
}

func (err ClientErrorGeneric) Error() string {
	return fmt.Sprint("Generic",
		": ",

		"Msg=",
		err.Msg,
		", ",
		"Details=",
		err.Details,
	)
}

func (self ClientErrorGeneric) Is(target error) bool {
	return target == ErrClientErrorGeneric
}

type ClientErrorMatrixApi struct {
	Kind    ErrorKind
	Code    string
	Msg     string
	Details *string
}

func NewClientErrorMatrixApi(
	kind ErrorKind,
	code string,
	msg string,
	details *string,
) *ClientError {
	return &ClientError{err: &ClientErrorMatrixApi{
		Kind:    kind,
		Code:    code,
		Msg:     msg,
		Details: details}}
}

func (e ClientErrorMatrixApi) destroy() {
	FfiDestroyerErrorKind{}.Destroy(e.Kind)
	FfiDestroyerString{}.Destroy(e.Code)
	FfiDestroyerString{}.Destroy(e.Msg)
	FfiDestroyerOptionalString{}.Destroy(e.Details)
}

func (err ClientErrorMatrixApi) Error() string {
	return fmt.Sprint("MatrixApi",
		": ",

		"Kind=",
		err.Kind,
		", ",
		"Code=",
		err.Code,
		", ",
		"Msg=",
		err.Msg,
		", ",
		"Details=",
		err.Details,
	)
}

func (self ClientErrorMatrixApi) Is(target error) bool {
	return target == ErrClientErrorMatrixApi
}

type FfiConverterClientError struct{}

var FfiConverterClientErrorINSTANCE = FfiConverterClientError{}

func (c FfiConverterClientError) Lift(eb RustBufferI) *ClientError {
	return LiftFromRustBuffer[*ClientError](c, eb)
}

func (c FfiConverterClientError) Lower(value *ClientError) C.RustBuffer {
	return LowerIntoRustBuffer[*ClientError](c, value)
}

func (c FfiConverterClientError) Read(reader io.Reader) *ClientError {
	errorID := readUint32(reader)

	switch errorID {
	case 1:
		return &ClientError{&ClientErrorGeneric{
			Msg:     FfiConverterStringINSTANCE.Read(reader),
			Details: FfiConverterOptionalStringINSTANCE.Read(reader),
		}}
	case 2:
		return &ClientError{&ClientErrorMatrixApi{
			Kind:    FfiConverterErrorKindINSTANCE.Read(reader),
			Code:    FfiConverterStringINSTANCE.Read(reader),
			Msg:     FfiConverterStringINSTANCE.Read(reader),
			Details: FfiConverterOptionalStringINSTANCE.Read(reader),
		}}
	default:
		panic(fmt.Sprintf("Unknown error code %d in FfiConverterClientError.Read()", errorID))
	}
}

func (c FfiConverterClientError) Write(writer io.Writer, value *ClientError) {
	switch variantValue := value.err.(type) {
	case *ClientErrorGeneric:
		writeInt32(writer, 1)
		FfiConverterStringINSTANCE.Write(writer, variantValue.Msg)
		FfiConverterOptionalStringINSTANCE.Write(writer, variantValue.Details)
	case *ClientErrorMatrixApi:
		writeInt32(writer, 2)
		FfiConverterErrorKindINSTANCE.Write(writer, variantValue.Kind)
		FfiConverterStringINSTANCE.Write(writer, variantValue.Code)
		FfiConverterStringINSTANCE.Write(writer, variantValue.Msg)
		FfiConverterOptionalStringINSTANCE.Write(writer, variantValue.Details)
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiConverterClientError.Write", value))
	}
}

type FfiDestroyerClientError struct{}

func (_ FfiDestroyerClientError) Destroy(value *ClientError) {
	switch variantValue := value.err.(type) {
	case ClientErrorGeneric:
		variantValue.destroy()
	case ClientErrorMatrixApi:
		variantValue.destroy()
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiDestroyerClientError.Destroy", value))
	}
}

type ComparisonOperator uint

const (
	// Equals
	ComparisonOperatorEq ComparisonOperator = 1
	// Less than
	ComparisonOperatorLt ComparisonOperator = 2
	// Greater than
	ComparisonOperatorGt ComparisonOperator = 3
	// Greater or equal
	ComparisonOperatorGe ComparisonOperator = 4
	// Less or equal
	ComparisonOperatorLe ComparisonOperator = 5
)

type FfiConverterComparisonOperator struct{}

var FfiConverterComparisonOperatorINSTANCE = FfiConverterComparisonOperator{}

func (c FfiConverterComparisonOperator) Lift(rb RustBufferI) ComparisonOperator {
	return LiftFromRustBuffer[ComparisonOperator](c, rb)
}

func (c FfiConverterComparisonOperator) Lower(value ComparisonOperator) C.RustBuffer {
	return LowerIntoRustBuffer[ComparisonOperator](c, value)
}
func (FfiConverterComparisonOperator) Read(reader io.Reader) ComparisonOperator {
	id := readInt32(reader)
	return ComparisonOperator(id)
}

func (FfiConverterComparisonOperator) Write(writer io.Writer, value ComparisonOperator) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerComparisonOperator struct{}

func (_ FfiDestroyerComparisonOperator) Destroy(value ComparisonOperator) {
}

// The type of draft of the composer.
type ComposerDraftType interface {
	Destroy()
}

// The draft is a new message.
type ComposerDraftTypeNewMessage struct {
}

func (e ComposerDraftTypeNewMessage) Destroy() {
}

// The draft is a reply to an event.
type ComposerDraftTypeReply struct {
	EventId string
}

func (e ComposerDraftTypeReply) Destroy() {
	FfiDestroyerString{}.Destroy(e.EventId)
}

// The draft is an edit of an event.
type ComposerDraftTypeEdit struct {
	EventId string
}

func (e ComposerDraftTypeEdit) Destroy() {
	FfiDestroyerString{}.Destroy(e.EventId)
}

type FfiConverterComposerDraftType struct{}

var FfiConverterComposerDraftTypeINSTANCE = FfiConverterComposerDraftType{}

func (c FfiConverterComposerDraftType) Lift(rb RustBufferI) ComposerDraftType {
	return LiftFromRustBuffer[ComposerDraftType](c, rb)
}

func (c FfiConverterComposerDraftType) Lower(value ComposerDraftType) C.RustBuffer {
	return LowerIntoRustBuffer[ComposerDraftType](c, value)
}
func (FfiConverterComposerDraftType) Read(reader io.Reader) ComposerDraftType {
	id := readInt32(reader)
	switch id {
	case 1:
		return ComposerDraftTypeNewMessage{}
	case 2:
		return ComposerDraftTypeReply{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 3:
		return ComposerDraftTypeEdit{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterComposerDraftType.Read()", id))
	}
}

func (FfiConverterComposerDraftType) Write(writer io.Writer, value ComposerDraftType) {
	switch variant_value := value.(type) {
	case ComposerDraftTypeNewMessage:
		writeInt32(writer, 1)
	case ComposerDraftTypeReply:
		writeInt32(writer, 2)
		FfiConverterStringINSTANCE.Write(writer, variant_value.EventId)
	case ComposerDraftTypeEdit:
		writeInt32(writer, 3)
		FfiConverterStringINSTANCE.Write(writer, variant_value.EventId)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterComposerDraftType.Write", value))
	}
}

type FfiDestroyerComposerDraftType struct{}

func (_ FfiDestroyerComposerDraftType) Destroy(value ComposerDraftType) {
	value.Destroy()
}

type CrossSigningResetAuthType interface {
	Destroy()
}

// The homeserver requires user-interactive authentication.
type CrossSigningResetAuthTypeUiaa struct {
}

func (e CrossSigningResetAuthTypeUiaa) Destroy() {
}

type CrossSigningResetAuthTypeOidc struct {
	Info OidcCrossSigningResetInfo
}

func (e CrossSigningResetAuthTypeOidc) Destroy() {
	FfiDestroyerOidcCrossSigningResetInfo{}.Destroy(e.Info)
}

type FfiConverterCrossSigningResetAuthType struct{}

var FfiConverterCrossSigningResetAuthTypeINSTANCE = FfiConverterCrossSigningResetAuthType{}

func (c FfiConverterCrossSigningResetAuthType) Lift(rb RustBufferI) CrossSigningResetAuthType {
	return LiftFromRustBuffer[CrossSigningResetAuthType](c, rb)
}

func (c FfiConverterCrossSigningResetAuthType) Lower(value CrossSigningResetAuthType) C.RustBuffer {
	return LowerIntoRustBuffer[CrossSigningResetAuthType](c, value)
}
func (FfiConverterCrossSigningResetAuthType) Read(reader io.Reader) CrossSigningResetAuthType {
	id := readInt32(reader)
	switch id {
	case 1:
		return CrossSigningResetAuthTypeUiaa{}
	case 2:
		return CrossSigningResetAuthTypeOidc{
			FfiConverterOidcCrossSigningResetInfoINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterCrossSigningResetAuthType.Read()", id))
	}
}

func (FfiConverterCrossSigningResetAuthType) Write(writer io.Writer, value CrossSigningResetAuthType) {
	switch variant_value := value.(type) {
	case CrossSigningResetAuthTypeUiaa:
		writeInt32(writer, 1)
	case CrossSigningResetAuthTypeOidc:
		writeInt32(writer, 2)
		FfiConverterOidcCrossSigningResetInfoINSTANCE.Write(writer, variant_value.Info)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterCrossSigningResetAuthType.Write", value))
	}
}

type FfiDestroyerCrossSigningResetAuthType struct{}

func (_ FfiDestroyerCrossSigningResetAuthType) Destroy(value CrossSigningResetAuthType) {
	value.Destroy()
}

// Changes how date dividers get inserted, either in between each day or in
// between each month
type DateDividerMode uint

const (
	DateDividerModeDaily   DateDividerMode = 1
	DateDividerModeMonthly DateDividerMode = 2
)

type FfiConverterDateDividerMode struct{}

var FfiConverterDateDividerModeINSTANCE = FfiConverterDateDividerMode{}

func (c FfiConverterDateDividerMode) Lift(rb RustBufferI) DateDividerMode {
	return LiftFromRustBuffer[DateDividerMode](c, rb)
}

func (c FfiConverterDateDividerMode) Lower(value DateDividerMode) C.RustBuffer {
	return LowerIntoRustBuffer[DateDividerMode](c, value)
}
func (FfiConverterDateDividerMode) Read(reader io.Reader) DateDividerMode {
	id := readInt32(reader)
	return DateDividerMode(id)
}

func (FfiConverterDateDividerMode) Write(writer io.Writer, value DateDividerMode) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerDateDividerMode struct{}

func (_ FfiDestroyerDateDividerMode) Destroy(value DateDividerMode) {
}

type EditedContent interface {
	Destroy()
}
type EditedContentRoomMessage struct {
	Content *RoomMessageEventContentWithoutRelation
}

func (e EditedContentRoomMessage) Destroy() {
	FfiDestroyerRoomMessageEventContentWithoutRelation{}.Destroy(e.Content)
}

type EditedContentMediaCaption struct {
	Caption          *string
	FormattedCaption *FormattedBody
	Mentions         *Mentions
}

func (e EditedContentMediaCaption) Destroy() {
	FfiDestroyerOptionalString{}.Destroy(e.Caption)
	FfiDestroyerOptionalFormattedBody{}.Destroy(e.FormattedCaption)
	FfiDestroyerOptionalMentions{}.Destroy(e.Mentions)
}

type EditedContentPollStart struct {
	PollData PollData
}

func (e EditedContentPollStart) Destroy() {
	FfiDestroyerPollData{}.Destroy(e.PollData)
}

type FfiConverterEditedContent struct{}

var FfiConverterEditedContentINSTANCE = FfiConverterEditedContent{}

func (c FfiConverterEditedContent) Lift(rb RustBufferI) EditedContent {
	return LiftFromRustBuffer[EditedContent](c, rb)
}

func (c FfiConverterEditedContent) Lower(value EditedContent) C.RustBuffer {
	return LowerIntoRustBuffer[EditedContent](c, value)
}
func (FfiConverterEditedContent) Read(reader io.Reader) EditedContent {
	id := readInt32(reader)
	switch id {
	case 1:
		return EditedContentRoomMessage{
			FfiConverterRoomMessageEventContentWithoutRelationINSTANCE.Read(reader),
		}
	case 2:
		return EditedContentMediaCaption{
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalFormattedBodyINSTANCE.Read(reader),
			FfiConverterOptionalMentionsINSTANCE.Read(reader),
		}
	case 3:
		return EditedContentPollStart{
			FfiConverterPollDataINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterEditedContent.Read()", id))
	}
}

func (FfiConverterEditedContent) Write(writer io.Writer, value EditedContent) {
	switch variant_value := value.(type) {
	case EditedContentRoomMessage:
		writeInt32(writer, 1)
		FfiConverterRoomMessageEventContentWithoutRelationINSTANCE.Write(writer, variant_value.Content)
	case EditedContentMediaCaption:
		writeInt32(writer, 2)
		FfiConverterOptionalStringINSTANCE.Write(writer, variant_value.Caption)
		FfiConverterOptionalFormattedBodyINSTANCE.Write(writer, variant_value.FormattedCaption)
		FfiConverterOptionalMentionsINSTANCE.Write(writer, variant_value.Mentions)
	case EditedContentPollStart:
		writeInt32(writer, 3)
		FfiConverterPollDataINSTANCE.Write(writer, variant_value.PollData)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterEditedContent.Write", value))
	}
}

type FfiDestroyerEditedContent struct{}

func (_ FfiDestroyerEditedContent) Destroy(value EditedContent) {
	value.Destroy()
}

type EnableRecoveryProgress interface {
	Destroy()
}
type EnableRecoveryProgressStarting struct {
}

func (e EnableRecoveryProgressStarting) Destroy() {
}

type EnableRecoveryProgressCreatingBackup struct {
}

func (e EnableRecoveryProgressCreatingBackup) Destroy() {
}

type EnableRecoveryProgressCreatingRecoveryKey struct {
}

func (e EnableRecoveryProgressCreatingRecoveryKey) Destroy() {
}

type EnableRecoveryProgressBackingUp struct {
	BackedUpCount uint32
	TotalCount    uint32
}

func (e EnableRecoveryProgressBackingUp) Destroy() {
	FfiDestroyerUint32{}.Destroy(e.BackedUpCount)
	FfiDestroyerUint32{}.Destroy(e.TotalCount)
}

type EnableRecoveryProgressRoomKeyUploadError struct {
}

func (e EnableRecoveryProgressRoomKeyUploadError) Destroy() {
}

type EnableRecoveryProgressDone struct {
	RecoveryKey string
}

func (e EnableRecoveryProgressDone) Destroy() {
	FfiDestroyerString{}.Destroy(e.RecoveryKey)
}

type FfiConverterEnableRecoveryProgress struct{}

var FfiConverterEnableRecoveryProgressINSTANCE = FfiConverterEnableRecoveryProgress{}

func (c FfiConverterEnableRecoveryProgress) Lift(rb RustBufferI) EnableRecoveryProgress {
	return LiftFromRustBuffer[EnableRecoveryProgress](c, rb)
}

func (c FfiConverterEnableRecoveryProgress) Lower(value EnableRecoveryProgress) C.RustBuffer {
	return LowerIntoRustBuffer[EnableRecoveryProgress](c, value)
}
func (FfiConverterEnableRecoveryProgress) Read(reader io.Reader) EnableRecoveryProgress {
	id := readInt32(reader)
	switch id {
	case 1:
		return EnableRecoveryProgressStarting{}
	case 2:
		return EnableRecoveryProgressCreatingBackup{}
	case 3:
		return EnableRecoveryProgressCreatingRecoveryKey{}
	case 4:
		return EnableRecoveryProgressBackingUp{
			FfiConverterUint32INSTANCE.Read(reader),
			FfiConverterUint32INSTANCE.Read(reader),
		}
	case 5:
		return EnableRecoveryProgressRoomKeyUploadError{}
	case 6:
		return EnableRecoveryProgressDone{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterEnableRecoveryProgress.Read()", id))
	}
}

func (FfiConverterEnableRecoveryProgress) Write(writer io.Writer, value EnableRecoveryProgress) {
	switch variant_value := value.(type) {
	case EnableRecoveryProgressStarting:
		writeInt32(writer, 1)
	case EnableRecoveryProgressCreatingBackup:
		writeInt32(writer, 2)
	case EnableRecoveryProgressCreatingRecoveryKey:
		writeInt32(writer, 3)
	case EnableRecoveryProgressBackingUp:
		writeInt32(writer, 4)
		FfiConverterUint32INSTANCE.Write(writer, variant_value.BackedUpCount)
		FfiConverterUint32INSTANCE.Write(writer, variant_value.TotalCount)
	case EnableRecoveryProgressRoomKeyUploadError:
		writeInt32(writer, 5)
	case EnableRecoveryProgressDone:
		writeInt32(writer, 6)
		FfiConverterStringINSTANCE.Write(writer, variant_value.RecoveryKey)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterEnableRecoveryProgress.Write", value))
	}
}

type FfiDestroyerEnableRecoveryProgress struct{}

func (_ FfiDestroyerEnableRecoveryProgress) Destroy(value EnableRecoveryProgress) {
	value.Destroy()
}

type EncryptedMessage interface {
	Destroy()
}
type EncryptedMessageOlmV1Curve25519AesSha2 struct {
	SenderKey string
}

func (e EncryptedMessageOlmV1Curve25519AesSha2) Destroy() {
	FfiDestroyerString{}.Destroy(e.SenderKey)
}

type EncryptedMessageMegolmV1AesSha2 struct {
	SessionId string
	Cause     matrix_sdk_crypto.UtdCause
}

func (e EncryptedMessageMegolmV1AesSha2) Destroy() {
	FfiDestroyerString{}.Destroy(e.SessionId)
	matrix_sdk_crypto.FfiDestroyerUtdCause{}.Destroy(e.Cause)
}

type EncryptedMessageUnknown struct {
}

func (e EncryptedMessageUnknown) Destroy() {
}

type FfiConverterEncryptedMessage struct{}

var FfiConverterEncryptedMessageINSTANCE = FfiConverterEncryptedMessage{}

func (c FfiConverterEncryptedMessage) Lift(rb RustBufferI) EncryptedMessage {
	return LiftFromRustBuffer[EncryptedMessage](c, rb)
}

func (c FfiConverterEncryptedMessage) Lower(value EncryptedMessage) C.RustBuffer {
	return LowerIntoRustBuffer[EncryptedMessage](c, value)
}
func (FfiConverterEncryptedMessage) Read(reader io.Reader) EncryptedMessage {
	id := readInt32(reader)
	switch id {
	case 1:
		return EncryptedMessageOlmV1Curve25519AesSha2{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 2:
		return EncryptedMessageMegolmV1AesSha2{
			FfiConverterStringINSTANCE.Read(reader),
			matrix_sdk_crypto.FfiConverterUtdCauseINSTANCE.Read(reader),
		}
	case 3:
		return EncryptedMessageUnknown{}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterEncryptedMessage.Read()", id))
	}
}

func (FfiConverterEncryptedMessage) Write(writer io.Writer, value EncryptedMessage) {
	switch variant_value := value.(type) {
	case EncryptedMessageOlmV1Curve25519AesSha2:
		writeInt32(writer, 1)
		FfiConverterStringINSTANCE.Write(writer, variant_value.SenderKey)
	case EncryptedMessageMegolmV1AesSha2:
		writeInt32(writer, 2)
		FfiConverterStringINSTANCE.Write(writer, variant_value.SessionId)
		matrix_sdk_crypto.FfiConverterUtdCauseINSTANCE.Write(writer, variant_value.Cause)
	case EncryptedMessageUnknown:
		writeInt32(writer, 3)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterEncryptedMessage.Write", value))
	}
}

type FfiDestroyerEncryptedMessage struct{}

func (_ FfiDestroyerEncryptedMessage) Destroy(value EncryptedMessage) {
	value.Destroy()
}

// Defines if a call is encrypted and which encryption system should be used.
//
// This controls the url parameters: `perParticipantE2EE`, `password`.
type EncryptionSystem interface {
	Destroy()
}

// Equivalent to the element call url parameter: `enableE2EE=false`
type EncryptionSystemUnencrypted struct {
}

func (e EncryptionSystemUnencrypted) Destroy() {
}

// Equivalent to the element call url parameter:
// `perParticipantE2EE=true`
type EncryptionSystemPerParticipantKeys struct {
}

func (e EncryptionSystemPerParticipantKeys) Destroy() {
}

// Equivalent to the element call url parameter:
// `password={secret}`
type EncryptionSystemSharedSecret struct {
	Secret string
}

func (e EncryptionSystemSharedSecret) Destroy() {
	FfiDestroyerString{}.Destroy(e.Secret)
}

type FfiConverterEncryptionSystem struct{}

var FfiConverterEncryptionSystemINSTANCE = FfiConverterEncryptionSystem{}

func (c FfiConverterEncryptionSystem) Lift(rb RustBufferI) EncryptionSystem {
	return LiftFromRustBuffer[EncryptionSystem](c, rb)
}

func (c FfiConverterEncryptionSystem) Lower(value EncryptionSystem) C.RustBuffer {
	return LowerIntoRustBuffer[EncryptionSystem](c, value)
}
func (FfiConverterEncryptionSystem) Read(reader io.Reader) EncryptionSystem {
	id := readInt32(reader)
	switch id {
	case 1:
		return EncryptionSystemUnencrypted{}
	case 2:
		return EncryptionSystemPerParticipantKeys{}
	case 3:
		return EncryptionSystemSharedSecret{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterEncryptionSystem.Read()", id))
	}
}

func (FfiConverterEncryptionSystem) Write(writer io.Writer, value EncryptionSystem) {
	switch variant_value := value.(type) {
	case EncryptionSystemUnencrypted:
		writeInt32(writer, 1)
	case EncryptionSystemPerParticipantKeys:
		writeInt32(writer, 2)
	case EncryptionSystemSharedSecret:
		writeInt32(writer, 3)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Secret)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterEncryptionSystem.Write", value))
	}
}

type FfiDestroyerEncryptionSystem struct{}

func (_ FfiDestroyerEncryptionSystem) Destroy(value EncryptionSystem) {
	value.Destroy()
}

type ErrorKind interface {
	Destroy()
}

// `M_BAD_ALIAS`
//
// One or more [room aliases] within the `m.room.canonical_alias` event do
// not point to the room ID for which the state event is to be sent to.
//
// [room aliases]: https://spec.matrix.org/latest/client-server-api/#room-aliases
type ErrorKindBadAlias struct {
}

func (e ErrorKindBadAlias) Destroy() {
}

// `M_BAD_JSON`
//
// The request contained valid JSON, but it was malformed in some way, e.g.
// missing required keys, invalid values for keys.
type ErrorKindBadJson struct {
}

func (e ErrorKindBadJson) Destroy() {
}

// `M_BAD_STATE`
//
// The state change requested cannot be performed, such as attempting to
// unban a user who is not banned.
type ErrorKindBadState struct {
}

func (e ErrorKindBadState) Destroy() {
}

// `M_BAD_STATUS`
//
// The application service returned a bad status.
type ErrorKindBadStatus struct {
	Status *uint16
	Body   *string
}

func (e ErrorKindBadStatus) Destroy() {
	FfiDestroyerOptionalUint16{}.Destroy(e.Status)
	FfiDestroyerOptionalString{}.Destroy(e.Body)
}

// `M_CANNOT_LEAVE_SERVER_NOTICE_ROOM`
//
// The user is unable to reject an invite to join the [server notices]
// room.
//
// [server notices]: https://spec.matrix.org/latest/client-server-api/#server-notices
type ErrorKindCannotLeaveServerNoticeRoom struct {
}

func (e ErrorKindCannotLeaveServerNoticeRoom) Destroy() {
}

// `M_CANNOT_OVERWRITE_MEDIA`
//
// The [`create_content_async`] endpoint was called with a media ID that
// already has content.
//
// [`create_content_async`]: crate::media::create_content_async
type ErrorKindCannotOverwriteMedia struct {
}

func (e ErrorKindCannotOverwriteMedia) Destroy() {
}

// `M_CAPTCHA_INVALID`
//
// The Captcha provided did not match what was expected.
type ErrorKindCaptchaInvalid struct {
}

func (e ErrorKindCaptchaInvalid) Destroy() {
}

// `M_CAPTCHA_NEEDED`
//
// A Captcha is required to complete the request.
type ErrorKindCaptchaNeeded struct {
}

func (e ErrorKindCaptchaNeeded) Destroy() {
}

// `M_CONNECTION_FAILED`
//
// The connection to the application service failed.
type ErrorKindConnectionFailed struct {
}

func (e ErrorKindConnectionFailed) Destroy() {
}

// `M_CONNECTION_TIMEOUT`
//
// The connection to the application service timed out.
type ErrorKindConnectionTimeout struct {
}

func (e ErrorKindConnectionTimeout) Destroy() {
}

// `M_DUPLICATE_ANNOTATION`
//
// The request is an attempt to send a [duplicate annotation].
//
// [duplicate annotation]: https://spec.matrix.org/latest/client-server-api/#avoiding-duplicate-annotations
type ErrorKindDuplicateAnnotation struct {
}

func (e ErrorKindDuplicateAnnotation) Destroy() {
}

// `M_EXCLUSIVE`
//
// The resource being requested is reserved by an application service, or
// the application service making the request has not created the
// resource.
type ErrorKindExclusive struct {
}

func (e ErrorKindExclusive) Destroy() {
}

// `M_FORBIDDEN`
//
// Forbidden access, e.g. joining a room without permission, failed login.
type ErrorKindForbidden struct {
}

func (e ErrorKindForbidden) Destroy() {
}

// `M_GUEST_ACCESS_FORBIDDEN`
//
// The room or resource does not permit [guests] to access it.
//
// [guests]: https://spec.matrix.org/latest/client-server-api/#guest-access
type ErrorKindGuestAccessForbidden struct {
}

func (e ErrorKindGuestAccessForbidden) Destroy() {
}

// `M_INCOMPATIBLE_ROOM_VERSION`
//
// The client attempted to join a room that has a version the server does
// not support.
type ErrorKindIncompatibleRoomVersion struct {
	RoomVersion string
}

func (e ErrorKindIncompatibleRoomVersion) Destroy() {
	FfiDestroyerString{}.Destroy(e.RoomVersion)
}

// `M_INVALID_PARAM`
//
// A parameter that was specified has the wrong value. For example, the
// server expected an integer and instead received a string.
type ErrorKindInvalidParam struct {
}

func (e ErrorKindInvalidParam) Destroy() {
}

// `M_INVALID_ROOM_STATE`
//
// The initial state implied by the parameters to the [`create_room`]
// request is invalid, e.g. the user's `power_level` is set below that
// necessary to set the room name.
//
// [`create_room`]: crate::room::create_room
type ErrorKindInvalidRoomState struct {
}

func (e ErrorKindInvalidRoomState) Destroy() {
}

// `M_INVALID_USERNAME`
//
// The desired user name is not valid.
type ErrorKindInvalidUsername struct {
}

func (e ErrorKindInvalidUsername) Destroy() {
}

// `M_LIMIT_EXCEEDED`
//
// The request has been refused due to [rate limiting]: too many requests
// have been sent in a short period of time.
//
// [rate limiting]: https://spec.matrix.org/latest/client-server-api/#rate-limiting
type ErrorKindLimitExceeded struct {
	RetryAfterMs *uint64
}

func (e ErrorKindLimitExceeded) Destroy() {
	FfiDestroyerOptionalUint64{}.Destroy(e.RetryAfterMs)
}

// `M_MISSING_PARAM`
//
// A required parameter was missing from the request.
type ErrorKindMissingParam struct {
}

func (e ErrorKindMissingParam) Destroy() {
}

// `M_MISSING_TOKEN`
//
// No [access token] was specified for the request, but one is required.
//
// [access token]: https://spec.matrix.org/latest/client-server-api/#client-authentication
type ErrorKindMissingToken struct {
}

func (e ErrorKindMissingToken) Destroy() {
}

// `M_NOT_FOUND`
//
// No resource was found for this request.
type ErrorKindNotFound struct {
}

func (e ErrorKindNotFound) Destroy() {
}

// `M_NOT_JSON`
//
// The request did not contain valid JSON.
type ErrorKindNotJson struct {
}

func (e ErrorKindNotJson) Destroy() {
}

// `M_NOT_YET_UPLOADED`
//
// An `mxc:` URI generated with the [`create_mxc_uri`] endpoint was used
// and the content is not yet available.
//
// [`create_mxc_uri`]: crate::media::create_mxc_uri
type ErrorKindNotYetUploaded struct {
}

func (e ErrorKindNotYetUploaded) Destroy() {
}

// `M_RESOURCE_LIMIT_EXCEEDED`
//
// The request cannot be completed because the homeserver has reached a
// resource limit imposed on it. For example, a homeserver held in a
// shared hosting environment may reach a resource limit if it starts
// using too much memory or disk space.
type ErrorKindResourceLimitExceeded struct {
	AdminContact string
}

func (e ErrorKindResourceLimitExceeded) Destroy() {
	FfiDestroyerString{}.Destroy(e.AdminContact)
}

// `M_ROOM_IN_USE`
//
// The [room alias] specified in the [`create_room`] request is already
// taken.
//
// [`create_room`]: crate::room::create_room
// [room alias]: https://spec.matrix.org/latest/client-server-api/#room-aliases
type ErrorKindRoomInUse struct {
}

func (e ErrorKindRoomInUse) Destroy() {
}

// `M_SERVER_NOT_TRUSTED`
//
// The client's request used a third-party server, e.g. identity server,
// that this server does not trust.
type ErrorKindServerNotTrusted struct {
}

func (e ErrorKindServerNotTrusted) Destroy() {
}

// `M_THREEPID_AUTH_FAILED`
//
// Authentication could not be performed on the [third-party identifier].
//
// [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
type ErrorKindThreepidAuthFailed struct {
}

func (e ErrorKindThreepidAuthFailed) Destroy() {
}

// `M_THREEPID_DENIED`
//
// The server does not permit this [third-party identifier]. This may
// happen if the server only permits, for example, email addresses from
// a particular domain.
//
// [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
type ErrorKindThreepidDenied struct {
}

func (e ErrorKindThreepidDenied) Destroy() {
}

// `M_THREEPID_IN_USE`
//
// The [third-party identifier] is already in use by another user.
//
// [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
type ErrorKindThreepidInUse struct {
}

func (e ErrorKindThreepidInUse) Destroy() {
}

// `M_THREEPID_MEDIUM_NOT_SUPPORTED`
//
// The homeserver does not support adding a [third-party identifier] of the
// given medium.
//
// [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
type ErrorKindThreepidMediumNotSupported struct {
}

func (e ErrorKindThreepidMediumNotSupported) Destroy() {
}

// `M_THREEPID_NOT_FOUND`
//
// No account matching the given [third-party identifier] could be found.
//
// [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
type ErrorKindThreepidNotFound struct {
}

func (e ErrorKindThreepidNotFound) Destroy() {
}

// `M_TOO_LARGE`
//
// The request or entity was too large.
type ErrorKindTooLarge struct {
}

func (e ErrorKindTooLarge) Destroy() {
}

// `M_UNABLE_TO_AUTHORISE_JOIN`
//
// The room is [restricted] and none of the conditions can be validated by
// the homeserver. This can happen if the homeserver does not know
// about any of the rooms listed as conditions, for example.
//
// [restricted]: https://spec.matrix.org/latest/client-server-api/#restricted-rooms
type ErrorKindUnableToAuthorizeJoin struct {
}

func (e ErrorKindUnableToAuthorizeJoin) Destroy() {
}

// `M_UNABLE_TO_GRANT_JOIN`
//
// A different server should be attempted for the join. This is typically
// because the resident server can see that the joining user satisfies
// one or more conditions, such as in the case of [restricted rooms],
// but the resident server would be unable to meet the authorization
// rules.
//
// [restricted rooms]: https://spec.matrix.org/latest/client-server-api/#restricted-rooms
type ErrorKindUnableToGrantJoin struct {
}

func (e ErrorKindUnableToGrantJoin) Destroy() {
}

// `M_UNAUTHORIZED`
//
// The request was not correctly authorized. Usually due to login failures.
type ErrorKindUnauthorized struct {
}

func (e ErrorKindUnauthorized) Destroy() {
}

// `M_UNKNOWN`
//
// An unknown error has occurred.
type ErrorKindUnknown struct {
}

func (e ErrorKindUnknown) Destroy() {
}

// `M_UNKNOWN_TOKEN`
//
// The [access or refresh token] specified was not recognized.
//
// [access or refresh token]: https://spec.matrix.org/latest/client-server-api/#client-authentication
type ErrorKindUnknownToken struct {
	SoftLogout bool
}

func (e ErrorKindUnknownToken) Destroy() {
	FfiDestroyerBool{}.Destroy(e.SoftLogout)
}

// `M_UNRECOGNIZED`
//
// The server did not understand the request.
//
// This is expected to be returned with a 404 HTTP status code if the
// endpoint is not implemented or a 405 HTTP status code if the
// endpoint is implemented, but the incorrect HTTP method is used.
type ErrorKindUnrecognized struct {
}

func (e ErrorKindUnrecognized) Destroy() {
}

// `M_UNSUPPORTED_ROOM_VERSION`
//
// The request to [`create_room`] used a room version that the server does
// not support.
//
// [`create_room`]: crate::room::create_room
type ErrorKindUnsupportedRoomVersion struct {
}

func (e ErrorKindUnsupportedRoomVersion) Destroy() {
}

// `M_URL_NOT_SET`
//
// The application service doesn't have a URL configured.
type ErrorKindUrlNotSet struct {
}

func (e ErrorKindUrlNotSet) Destroy() {
}

// `M_USER_DEACTIVATED`
//
// The user ID associated with the request has been deactivated.
type ErrorKindUserDeactivated struct {
}

func (e ErrorKindUserDeactivated) Destroy() {
}

// `M_USER_IN_USE`
//
// The desired user ID is already taken.
type ErrorKindUserInUse struct {
}

func (e ErrorKindUserInUse) Destroy() {
}

// `M_USER_LOCKED`
//
// The account has been [locked] and cannot be used at this time.
//
// [locked]: https://spec.matrix.org/latest/client-server-api/#account-locking
type ErrorKindUserLocked struct {
}

func (e ErrorKindUserLocked) Destroy() {
}

// `M_USER_SUSPENDED`
//
// The account has been [suspended] and can only be used for limited
// actions at this time.
//
// [suspended]: https://spec.matrix.org/latest/client-server-api/#account-suspension
type ErrorKindUserSuspended struct {
}

func (e ErrorKindUserSuspended) Destroy() {
}

// `M_WEAK_PASSWORD`
//
// The password was [rejected] by the server for being too weak.
//
// [rejected]: https://spec.matrix.org/latest/client-server-api/#notes-on-password-management
type ErrorKindWeakPassword struct {
}

func (e ErrorKindWeakPassword) Destroy() {
}

// `M_WRONG_ROOM_KEYS_VERSION`
//
// The version of the [room keys backup] provided in the request does not
// match the current backup version.
//
// [room keys backup]: https://spec.matrix.org/latest/client-server-api/#server-side-key-backups
type ErrorKindWrongRoomKeysVersion struct {
	CurrentVersion *string
}

func (e ErrorKindWrongRoomKeysVersion) Destroy() {
	FfiDestroyerOptionalString{}.Destroy(e.CurrentVersion)
}

// A custom API error.
type ErrorKindCustom struct {
	Errcode string
}

func (e ErrorKindCustom) Destroy() {
	FfiDestroyerString{}.Destroy(e.Errcode)
}

type FfiConverterErrorKind struct{}

var FfiConverterErrorKindINSTANCE = FfiConverterErrorKind{}

func (c FfiConverterErrorKind) Lift(rb RustBufferI) ErrorKind {
	return LiftFromRustBuffer[ErrorKind](c, rb)
}

func (c FfiConverterErrorKind) Lower(value ErrorKind) C.RustBuffer {
	return LowerIntoRustBuffer[ErrorKind](c, value)
}
func (FfiConverterErrorKind) Read(reader io.Reader) ErrorKind {
	id := readInt32(reader)
	switch id {
	case 1:
		return ErrorKindBadAlias{}
	case 2:
		return ErrorKindBadJson{}
	case 3:
		return ErrorKindBadState{}
	case 4:
		return ErrorKindBadStatus{
			FfiConverterOptionalUint16INSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
		}
	case 5:
		return ErrorKindCannotLeaveServerNoticeRoom{}
	case 6:
		return ErrorKindCannotOverwriteMedia{}
	case 7:
		return ErrorKindCaptchaInvalid{}
	case 8:
		return ErrorKindCaptchaNeeded{}
	case 9:
		return ErrorKindConnectionFailed{}
	case 10:
		return ErrorKindConnectionTimeout{}
	case 11:
		return ErrorKindDuplicateAnnotation{}
	case 12:
		return ErrorKindExclusive{}
	case 13:
		return ErrorKindForbidden{}
	case 14:
		return ErrorKindGuestAccessForbidden{}
	case 15:
		return ErrorKindIncompatibleRoomVersion{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 16:
		return ErrorKindInvalidParam{}
	case 17:
		return ErrorKindInvalidRoomState{}
	case 18:
		return ErrorKindInvalidUsername{}
	case 19:
		return ErrorKindLimitExceeded{
			FfiConverterOptionalUint64INSTANCE.Read(reader),
		}
	case 20:
		return ErrorKindMissingParam{}
	case 21:
		return ErrorKindMissingToken{}
	case 22:
		return ErrorKindNotFound{}
	case 23:
		return ErrorKindNotJson{}
	case 24:
		return ErrorKindNotYetUploaded{}
	case 25:
		return ErrorKindResourceLimitExceeded{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 26:
		return ErrorKindRoomInUse{}
	case 27:
		return ErrorKindServerNotTrusted{}
	case 28:
		return ErrorKindThreepidAuthFailed{}
	case 29:
		return ErrorKindThreepidDenied{}
	case 30:
		return ErrorKindThreepidInUse{}
	case 31:
		return ErrorKindThreepidMediumNotSupported{}
	case 32:
		return ErrorKindThreepidNotFound{}
	case 33:
		return ErrorKindTooLarge{}
	case 34:
		return ErrorKindUnableToAuthorizeJoin{}
	case 35:
		return ErrorKindUnableToGrantJoin{}
	case 36:
		return ErrorKindUnauthorized{}
	case 37:
		return ErrorKindUnknown{}
	case 38:
		return ErrorKindUnknownToken{
			FfiConverterBoolINSTANCE.Read(reader),
		}
	case 39:
		return ErrorKindUnrecognized{}
	case 40:
		return ErrorKindUnsupportedRoomVersion{}
	case 41:
		return ErrorKindUrlNotSet{}
	case 42:
		return ErrorKindUserDeactivated{}
	case 43:
		return ErrorKindUserInUse{}
	case 44:
		return ErrorKindUserLocked{}
	case 45:
		return ErrorKindUserSuspended{}
	case 46:
		return ErrorKindWeakPassword{}
	case 47:
		return ErrorKindWrongRoomKeysVersion{
			FfiConverterOptionalStringINSTANCE.Read(reader),
		}
	case 48:
		return ErrorKindCustom{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterErrorKind.Read()", id))
	}
}

func (FfiConverterErrorKind) Write(writer io.Writer, value ErrorKind) {
	switch variant_value := value.(type) {
	case ErrorKindBadAlias:
		writeInt32(writer, 1)
	case ErrorKindBadJson:
		writeInt32(writer, 2)
	case ErrorKindBadState:
		writeInt32(writer, 3)
	case ErrorKindBadStatus:
		writeInt32(writer, 4)
		FfiConverterOptionalUint16INSTANCE.Write(writer, variant_value.Status)
		FfiConverterOptionalStringINSTANCE.Write(writer, variant_value.Body)
	case ErrorKindCannotLeaveServerNoticeRoom:
		writeInt32(writer, 5)
	case ErrorKindCannotOverwriteMedia:
		writeInt32(writer, 6)
	case ErrorKindCaptchaInvalid:
		writeInt32(writer, 7)
	case ErrorKindCaptchaNeeded:
		writeInt32(writer, 8)
	case ErrorKindConnectionFailed:
		writeInt32(writer, 9)
	case ErrorKindConnectionTimeout:
		writeInt32(writer, 10)
	case ErrorKindDuplicateAnnotation:
		writeInt32(writer, 11)
	case ErrorKindExclusive:
		writeInt32(writer, 12)
	case ErrorKindForbidden:
		writeInt32(writer, 13)
	case ErrorKindGuestAccessForbidden:
		writeInt32(writer, 14)
	case ErrorKindIncompatibleRoomVersion:
		writeInt32(writer, 15)
		FfiConverterStringINSTANCE.Write(writer, variant_value.RoomVersion)
	case ErrorKindInvalidParam:
		writeInt32(writer, 16)
	case ErrorKindInvalidRoomState:
		writeInt32(writer, 17)
	case ErrorKindInvalidUsername:
		writeInt32(writer, 18)
	case ErrorKindLimitExceeded:
		writeInt32(writer, 19)
		FfiConverterOptionalUint64INSTANCE.Write(writer, variant_value.RetryAfterMs)
	case ErrorKindMissingParam:
		writeInt32(writer, 20)
	case ErrorKindMissingToken:
		writeInt32(writer, 21)
	case ErrorKindNotFound:
		writeInt32(writer, 22)
	case ErrorKindNotJson:
		writeInt32(writer, 23)
	case ErrorKindNotYetUploaded:
		writeInt32(writer, 24)
	case ErrorKindResourceLimitExceeded:
		writeInt32(writer, 25)
		FfiConverterStringINSTANCE.Write(writer, variant_value.AdminContact)
	case ErrorKindRoomInUse:
		writeInt32(writer, 26)
	case ErrorKindServerNotTrusted:
		writeInt32(writer, 27)
	case ErrorKindThreepidAuthFailed:
		writeInt32(writer, 28)
	case ErrorKindThreepidDenied:
		writeInt32(writer, 29)
	case ErrorKindThreepidInUse:
		writeInt32(writer, 30)
	case ErrorKindThreepidMediumNotSupported:
		writeInt32(writer, 31)
	case ErrorKindThreepidNotFound:
		writeInt32(writer, 32)
	case ErrorKindTooLarge:
		writeInt32(writer, 33)
	case ErrorKindUnableToAuthorizeJoin:
		writeInt32(writer, 34)
	case ErrorKindUnableToGrantJoin:
		writeInt32(writer, 35)
	case ErrorKindUnauthorized:
		writeInt32(writer, 36)
	case ErrorKindUnknown:
		writeInt32(writer, 37)
	case ErrorKindUnknownToken:
		writeInt32(writer, 38)
		FfiConverterBoolINSTANCE.Write(writer, variant_value.SoftLogout)
	case ErrorKindUnrecognized:
		writeInt32(writer, 39)
	case ErrorKindUnsupportedRoomVersion:
		writeInt32(writer, 40)
	case ErrorKindUrlNotSet:
		writeInt32(writer, 41)
	case ErrorKindUserDeactivated:
		writeInt32(writer, 42)
	case ErrorKindUserInUse:
		writeInt32(writer, 43)
	case ErrorKindUserLocked:
		writeInt32(writer, 44)
	case ErrorKindUserSuspended:
		writeInt32(writer, 45)
	case ErrorKindWeakPassword:
		writeInt32(writer, 46)
	case ErrorKindWrongRoomKeysVersion:
		writeInt32(writer, 47)
		FfiConverterOptionalStringINSTANCE.Write(writer, variant_value.CurrentVersion)
	case ErrorKindCustom:
		writeInt32(writer, 48)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Errcode)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterErrorKind.Write", value))
	}
}

type FfiDestroyerErrorKind struct{}

func (_ FfiDestroyerErrorKind) Destroy(value ErrorKind) {
	value.Destroy()
}

// Contains the 2 possible identifiers of an event, either it has a remote
// event id or a local transaction id, never both or none.
type EventOrTransactionId interface {
	Destroy()
}
type EventOrTransactionIdEventId struct {
	EventId string
}

func (e EventOrTransactionIdEventId) Destroy() {
	FfiDestroyerString{}.Destroy(e.EventId)
}

type EventOrTransactionIdTransactionId struct {
	TransactionId string
}

func (e EventOrTransactionIdTransactionId) Destroy() {
	FfiDestroyerString{}.Destroy(e.TransactionId)
}

type FfiConverterEventOrTransactionId struct{}

var FfiConverterEventOrTransactionIdINSTANCE = FfiConverterEventOrTransactionId{}

func (c FfiConverterEventOrTransactionId) Lift(rb RustBufferI) EventOrTransactionId {
	return LiftFromRustBuffer[EventOrTransactionId](c, rb)
}

func (c FfiConverterEventOrTransactionId) Lower(value EventOrTransactionId) C.RustBuffer {
	return LowerIntoRustBuffer[EventOrTransactionId](c, value)
}
func (FfiConverterEventOrTransactionId) Read(reader io.Reader) EventOrTransactionId {
	id := readInt32(reader)
	switch id {
	case 1:
		return EventOrTransactionIdEventId{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 2:
		return EventOrTransactionIdTransactionId{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterEventOrTransactionId.Read()", id))
	}
}

func (FfiConverterEventOrTransactionId) Write(writer io.Writer, value EventOrTransactionId) {
	switch variant_value := value.(type) {
	case EventOrTransactionIdEventId:
		writeInt32(writer, 1)
		FfiConverterStringINSTANCE.Write(writer, variant_value.EventId)
	case EventOrTransactionIdTransactionId:
		writeInt32(writer, 2)
		FfiConverterStringINSTANCE.Write(writer, variant_value.TransactionId)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterEventOrTransactionId.Write", value))
	}
}

type FfiDestroyerEventOrTransactionId struct{}

func (_ FfiDestroyerEventOrTransactionId) Destroy(value EventOrTransactionId) {
	value.Destroy()
}

// This type represents the “send state” of a local event timeline item.
type EventSendState interface {
	Destroy()
}

// The local event has not been sent yet.
type EventSendStateNotSentYet struct {
}

func (e EventSendStateNotSentYet) Destroy() {
}

// The local event has been sent to the server, but unsuccessfully: The
// sending has failed.
type EventSendStateSendingFailed struct {
	Error         QueueWedgeError
	IsRecoverable bool
}

func (e EventSendStateSendingFailed) Destroy() {
	FfiDestroyerQueueWedgeError{}.Destroy(e.Error)
	FfiDestroyerBool{}.Destroy(e.IsRecoverable)
}

// The local event has been sent successfully to the server.
type EventSendStateSent struct {
	EventId string
}

func (e EventSendStateSent) Destroy() {
	FfiDestroyerString{}.Destroy(e.EventId)
}

type FfiConverterEventSendState struct{}

var FfiConverterEventSendStateINSTANCE = FfiConverterEventSendState{}

func (c FfiConverterEventSendState) Lift(rb RustBufferI) EventSendState {
	return LiftFromRustBuffer[EventSendState](c, rb)
}

func (c FfiConverterEventSendState) Lower(value EventSendState) C.RustBuffer {
	return LowerIntoRustBuffer[EventSendState](c, value)
}
func (FfiConverterEventSendState) Read(reader io.Reader) EventSendState {
	id := readInt32(reader)
	switch id {
	case 1:
		return EventSendStateNotSentYet{}
	case 2:
		return EventSendStateSendingFailed{
			FfiConverterQueueWedgeErrorINSTANCE.Read(reader),
			FfiConverterBoolINSTANCE.Read(reader),
		}
	case 3:
		return EventSendStateSent{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterEventSendState.Read()", id))
	}
}

func (FfiConverterEventSendState) Write(writer io.Writer, value EventSendState) {
	switch variant_value := value.(type) {
	case EventSendStateNotSentYet:
		writeInt32(writer, 1)
	case EventSendStateSendingFailed:
		writeInt32(writer, 2)
		FfiConverterQueueWedgeErrorINSTANCE.Write(writer, variant_value.Error)
		FfiConverterBoolINSTANCE.Write(writer, variant_value.IsRecoverable)
	case EventSendStateSent:
		writeInt32(writer, 3)
		FfiConverterStringINSTANCE.Write(writer, variant_value.EventId)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterEventSendState.Write", value))
	}
}

type FfiDestroyerEventSendState struct{}

func (_ FfiDestroyerEventSendState) Destroy(value EventSendState) {
	value.Destroy()
}

type FilterTimelineEventType interface {
	Destroy()
}
type FilterTimelineEventTypeMessageLike struct {
	EventType MessageLikeEventType
}

func (e FilterTimelineEventTypeMessageLike) Destroy() {
	FfiDestroyerMessageLikeEventType{}.Destroy(e.EventType)
}

type FilterTimelineEventTypeState struct {
	EventType StateEventType
}

func (e FilterTimelineEventTypeState) Destroy() {
	FfiDestroyerStateEventType{}.Destroy(e.EventType)
}

type FfiConverterFilterTimelineEventType struct{}

var FfiConverterFilterTimelineEventTypeINSTANCE = FfiConverterFilterTimelineEventType{}

func (c FfiConverterFilterTimelineEventType) Lift(rb RustBufferI) FilterTimelineEventType {
	return LiftFromRustBuffer[FilterTimelineEventType](c, rb)
}

func (c FfiConverterFilterTimelineEventType) Lower(value FilterTimelineEventType) C.RustBuffer {
	return LowerIntoRustBuffer[FilterTimelineEventType](c, value)
}
func (FfiConverterFilterTimelineEventType) Read(reader io.Reader) FilterTimelineEventType {
	id := readInt32(reader)
	switch id {
	case 1:
		return FilterTimelineEventTypeMessageLike{
			FfiConverterMessageLikeEventTypeINSTANCE.Read(reader),
		}
	case 2:
		return FilterTimelineEventTypeState{
			FfiConverterStateEventTypeINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterFilterTimelineEventType.Read()", id))
	}
}

func (FfiConverterFilterTimelineEventType) Write(writer io.Writer, value FilterTimelineEventType) {
	switch variant_value := value.(type) {
	case FilterTimelineEventTypeMessageLike:
		writeInt32(writer, 1)
		FfiConverterMessageLikeEventTypeINSTANCE.Write(writer, variant_value.EventType)
	case FilterTimelineEventTypeState:
		writeInt32(writer, 2)
		FfiConverterStateEventTypeINSTANCE.Write(writer, variant_value.EventType)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterFilterTimelineEventType.Write", value))
	}
}

type FfiDestroyerFilterTimelineEventType struct{}

func (_ FfiDestroyerFilterTimelineEventType) Destroy(value FilterTimelineEventType) {
	value.Destroy()
}

type FocusEventError struct {
	err error
}

// Convience method to turn *FocusEventError into error
// Avoiding treating nil pointer as non nil error interface
func (err *FocusEventError) AsError() error {
	if err == nil {
		return nil
	} else {
		return err
	}
}

func (err FocusEventError) Error() string {
	return fmt.Sprintf("FocusEventError: %s", err.err.Error())
}

func (err FocusEventError) Unwrap() error {
	return err.err
}

// Err* are used for checking error type with `errors.Is`
var ErrFocusEventErrorInvalidEventId = fmt.Errorf("FocusEventErrorInvalidEventId")
var ErrFocusEventErrorEventNotFound = fmt.Errorf("FocusEventErrorEventNotFound")
var ErrFocusEventErrorOther = fmt.Errorf("FocusEventErrorOther")

// Variant structs
type FocusEventErrorInvalidEventId struct {
	EventId string
	Err     string
}

func NewFocusEventErrorInvalidEventId(
	eventId string,
	err string,
) *FocusEventError {
	return &FocusEventError{err: &FocusEventErrorInvalidEventId{
		EventId: eventId,
		Err:     err}}
}

func (e FocusEventErrorInvalidEventId) destroy() {
	FfiDestroyerString{}.Destroy(e.EventId)
	FfiDestroyerString{}.Destroy(e.Err)
}

func (err FocusEventErrorInvalidEventId) Error() string {
	return fmt.Sprint("InvalidEventId",
		": ",

		"EventId=",
		err.EventId,
		", ",
		"Err=",
		err.Err,
	)
}

func (self FocusEventErrorInvalidEventId) Is(target error) bool {
	return target == ErrFocusEventErrorInvalidEventId
}

type FocusEventErrorEventNotFound struct {
	EventId string
}

func NewFocusEventErrorEventNotFound(
	eventId string,
) *FocusEventError {
	return &FocusEventError{err: &FocusEventErrorEventNotFound{
		EventId: eventId}}
}

func (e FocusEventErrorEventNotFound) destroy() {
	FfiDestroyerString{}.Destroy(e.EventId)
}

func (err FocusEventErrorEventNotFound) Error() string {
	return fmt.Sprint("EventNotFound",
		": ",

		"EventId=",
		err.EventId,
	)
}

func (self FocusEventErrorEventNotFound) Is(target error) bool {
	return target == ErrFocusEventErrorEventNotFound
}

type FocusEventErrorOther struct {
	Msg string
}

func NewFocusEventErrorOther(
	msg string,
) *FocusEventError {
	return &FocusEventError{err: &FocusEventErrorOther{
		Msg: msg}}
}

func (e FocusEventErrorOther) destroy() {
	FfiDestroyerString{}.Destroy(e.Msg)
}

func (err FocusEventErrorOther) Error() string {
	return fmt.Sprint("Other",
		": ",

		"Msg=",
		err.Msg,
	)
}

func (self FocusEventErrorOther) Is(target error) bool {
	return target == ErrFocusEventErrorOther
}

type FfiConverterFocusEventError struct{}

var FfiConverterFocusEventErrorINSTANCE = FfiConverterFocusEventError{}

func (c FfiConverterFocusEventError) Lift(eb RustBufferI) *FocusEventError {
	return LiftFromRustBuffer[*FocusEventError](c, eb)
}

func (c FfiConverterFocusEventError) Lower(value *FocusEventError) C.RustBuffer {
	return LowerIntoRustBuffer[*FocusEventError](c, value)
}

func (c FfiConverterFocusEventError) Read(reader io.Reader) *FocusEventError {
	errorID := readUint32(reader)

	switch errorID {
	case 1:
		return &FocusEventError{&FocusEventErrorInvalidEventId{
			EventId: FfiConverterStringINSTANCE.Read(reader),
			Err:     FfiConverterStringINSTANCE.Read(reader),
		}}
	case 2:
		return &FocusEventError{&FocusEventErrorEventNotFound{
			EventId: FfiConverterStringINSTANCE.Read(reader),
		}}
	case 3:
		return &FocusEventError{&FocusEventErrorOther{
			Msg: FfiConverterStringINSTANCE.Read(reader),
		}}
	default:
		panic(fmt.Sprintf("Unknown error code %d in FfiConverterFocusEventError.Read()", errorID))
	}
}

func (c FfiConverterFocusEventError) Write(writer io.Writer, value *FocusEventError) {
	switch variantValue := value.err.(type) {
	case *FocusEventErrorInvalidEventId:
		writeInt32(writer, 1)
		FfiConverterStringINSTANCE.Write(writer, variantValue.EventId)
		FfiConverterStringINSTANCE.Write(writer, variantValue.Err)
	case *FocusEventErrorEventNotFound:
		writeInt32(writer, 2)
		FfiConverterStringINSTANCE.Write(writer, variantValue.EventId)
	case *FocusEventErrorOther:
		writeInt32(writer, 3)
		FfiConverterStringINSTANCE.Write(writer, variantValue.Msg)
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiConverterFocusEventError.Write", value))
	}
}

type FfiDestroyerFocusEventError struct{}

func (_ FfiDestroyerFocusEventError) Destroy(value *FocusEventError) {
	switch variantValue := value.err.(type) {
	case FocusEventErrorInvalidEventId:
		variantValue.destroy()
	case FocusEventErrorEventNotFound:
		variantValue.destroy()
	case FocusEventErrorOther:
		variantValue.destroy()
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiDestroyerFocusEventError.Destroy", value))
	}
}

type HumanQrLoginError struct {
	err error
}

// Convience method to turn *HumanQrLoginError into error
// Avoiding treating nil pointer as non nil error interface
func (err *HumanQrLoginError) AsError() error {
	if err == nil {
		return nil
	} else {
		return err
	}
}

func (err HumanQrLoginError) Error() string {
	return fmt.Sprintf("HumanQrLoginError: %s", err.err.Error())
}

func (err HumanQrLoginError) Unwrap() error {
	return err.err
}

// Err* are used for checking error type with `errors.Is`
var ErrHumanQrLoginErrorLinkingNotSupported = fmt.Errorf("HumanQrLoginErrorLinkingNotSupported")
var ErrHumanQrLoginErrorCancelled = fmt.Errorf("HumanQrLoginErrorCancelled")
var ErrHumanQrLoginErrorExpired = fmt.Errorf("HumanQrLoginErrorExpired")
var ErrHumanQrLoginErrorConnectionInsecure = fmt.Errorf("HumanQrLoginErrorConnectionInsecure")
var ErrHumanQrLoginErrorDeclined = fmt.Errorf("HumanQrLoginErrorDeclined")
var ErrHumanQrLoginErrorUnknown = fmt.Errorf("HumanQrLoginErrorUnknown")
var ErrHumanQrLoginErrorSlidingSyncNotAvailable = fmt.Errorf("HumanQrLoginErrorSlidingSyncNotAvailable")
var ErrHumanQrLoginErrorOidcMetadataInvalid = fmt.Errorf("HumanQrLoginErrorOidcMetadataInvalid")
var ErrHumanQrLoginErrorOtherDeviceNotSignedIn = fmt.Errorf("HumanQrLoginErrorOtherDeviceNotSignedIn")

// Variant structs
type HumanQrLoginErrorLinkingNotSupported struct {
}

func NewHumanQrLoginErrorLinkingNotSupported() *HumanQrLoginError {
	return &HumanQrLoginError{err: &HumanQrLoginErrorLinkingNotSupported{}}
}

func (e HumanQrLoginErrorLinkingNotSupported) destroy() {
}

func (err HumanQrLoginErrorLinkingNotSupported) Error() string {
	return fmt.Sprint("LinkingNotSupported")
}

func (self HumanQrLoginErrorLinkingNotSupported) Is(target error) bool {
	return target == ErrHumanQrLoginErrorLinkingNotSupported
}

type HumanQrLoginErrorCancelled struct {
}

func NewHumanQrLoginErrorCancelled() *HumanQrLoginError {
	return &HumanQrLoginError{err: &HumanQrLoginErrorCancelled{}}
}

func (e HumanQrLoginErrorCancelled) destroy() {
}

func (err HumanQrLoginErrorCancelled) Error() string {
	return fmt.Sprint("Cancelled")
}

func (self HumanQrLoginErrorCancelled) Is(target error) bool {
	return target == ErrHumanQrLoginErrorCancelled
}

type HumanQrLoginErrorExpired struct {
}

func NewHumanQrLoginErrorExpired() *HumanQrLoginError {
	return &HumanQrLoginError{err: &HumanQrLoginErrorExpired{}}
}

func (e HumanQrLoginErrorExpired) destroy() {
}

func (err HumanQrLoginErrorExpired) Error() string {
	return fmt.Sprint("Expired")
}

func (self HumanQrLoginErrorExpired) Is(target error) bool {
	return target == ErrHumanQrLoginErrorExpired
}

type HumanQrLoginErrorConnectionInsecure struct {
}

func NewHumanQrLoginErrorConnectionInsecure() *HumanQrLoginError {
	return &HumanQrLoginError{err: &HumanQrLoginErrorConnectionInsecure{}}
}

func (e HumanQrLoginErrorConnectionInsecure) destroy() {
}

func (err HumanQrLoginErrorConnectionInsecure) Error() string {
	return fmt.Sprint("ConnectionInsecure")
}

func (self HumanQrLoginErrorConnectionInsecure) Is(target error) bool {
	return target == ErrHumanQrLoginErrorConnectionInsecure
}

type HumanQrLoginErrorDeclined struct {
}

func NewHumanQrLoginErrorDeclined() *HumanQrLoginError {
	return &HumanQrLoginError{err: &HumanQrLoginErrorDeclined{}}
}

func (e HumanQrLoginErrorDeclined) destroy() {
}

func (err HumanQrLoginErrorDeclined) Error() string {
	return fmt.Sprint("Declined")
}

func (self HumanQrLoginErrorDeclined) Is(target error) bool {
	return target == ErrHumanQrLoginErrorDeclined
}

type HumanQrLoginErrorUnknown struct {
}

func NewHumanQrLoginErrorUnknown() *HumanQrLoginError {
	return &HumanQrLoginError{err: &HumanQrLoginErrorUnknown{}}
}

func (e HumanQrLoginErrorUnknown) destroy() {
}

func (err HumanQrLoginErrorUnknown) Error() string {
	return fmt.Sprint("Unknown")
}

func (self HumanQrLoginErrorUnknown) Is(target error) bool {
	return target == ErrHumanQrLoginErrorUnknown
}

type HumanQrLoginErrorSlidingSyncNotAvailable struct {
}

func NewHumanQrLoginErrorSlidingSyncNotAvailable() *HumanQrLoginError {
	return &HumanQrLoginError{err: &HumanQrLoginErrorSlidingSyncNotAvailable{}}
}

func (e HumanQrLoginErrorSlidingSyncNotAvailable) destroy() {
}

func (err HumanQrLoginErrorSlidingSyncNotAvailable) Error() string {
	return fmt.Sprint("SlidingSyncNotAvailable")
}

func (self HumanQrLoginErrorSlidingSyncNotAvailable) Is(target error) bool {
	return target == ErrHumanQrLoginErrorSlidingSyncNotAvailable
}

type HumanQrLoginErrorOidcMetadataInvalid struct {
}

func NewHumanQrLoginErrorOidcMetadataInvalid() *HumanQrLoginError {
	return &HumanQrLoginError{err: &HumanQrLoginErrorOidcMetadataInvalid{}}
}

func (e HumanQrLoginErrorOidcMetadataInvalid) destroy() {
}

func (err HumanQrLoginErrorOidcMetadataInvalid) Error() string {
	return fmt.Sprint("OidcMetadataInvalid")
}

func (self HumanQrLoginErrorOidcMetadataInvalid) Is(target error) bool {
	return target == ErrHumanQrLoginErrorOidcMetadataInvalid
}

type HumanQrLoginErrorOtherDeviceNotSignedIn struct {
}

func NewHumanQrLoginErrorOtherDeviceNotSignedIn() *HumanQrLoginError {
	return &HumanQrLoginError{err: &HumanQrLoginErrorOtherDeviceNotSignedIn{}}
}

func (e HumanQrLoginErrorOtherDeviceNotSignedIn) destroy() {
}

func (err HumanQrLoginErrorOtherDeviceNotSignedIn) Error() string {
	return fmt.Sprint("OtherDeviceNotSignedIn")
}

func (self HumanQrLoginErrorOtherDeviceNotSignedIn) Is(target error) bool {
	return target == ErrHumanQrLoginErrorOtherDeviceNotSignedIn
}

type FfiConverterHumanQrLoginError struct{}

var FfiConverterHumanQrLoginErrorINSTANCE = FfiConverterHumanQrLoginError{}

func (c FfiConverterHumanQrLoginError) Lift(eb RustBufferI) *HumanQrLoginError {
	return LiftFromRustBuffer[*HumanQrLoginError](c, eb)
}

func (c FfiConverterHumanQrLoginError) Lower(value *HumanQrLoginError) C.RustBuffer {
	return LowerIntoRustBuffer[*HumanQrLoginError](c, value)
}

func (c FfiConverterHumanQrLoginError) Read(reader io.Reader) *HumanQrLoginError {
	errorID := readUint32(reader)

	switch errorID {
	case 1:
		return &HumanQrLoginError{&HumanQrLoginErrorLinkingNotSupported{}}
	case 2:
		return &HumanQrLoginError{&HumanQrLoginErrorCancelled{}}
	case 3:
		return &HumanQrLoginError{&HumanQrLoginErrorExpired{}}
	case 4:
		return &HumanQrLoginError{&HumanQrLoginErrorConnectionInsecure{}}
	case 5:
		return &HumanQrLoginError{&HumanQrLoginErrorDeclined{}}
	case 6:
		return &HumanQrLoginError{&HumanQrLoginErrorUnknown{}}
	case 7:
		return &HumanQrLoginError{&HumanQrLoginErrorSlidingSyncNotAvailable{}}
	case 8:
		return &HumanQrLoginError{&HumanQrLoginErrorOidcMetadataInvalid{}}
	case 9:
		return &HumanQrLoginError{&HumanQrLoginErrorOtherDeviceNotSignedIn{}}
	default:
		panic(fmt.Sprintf("Unknown error code %d in FfiConverterHumanQrLoginError.Read()", errorID))
	}
}

func (c FfiConverterHumanQrLoginError) Write(writer io.Writer, value *HumanQrLoginError) {
	switch variantValue := value.err.(type) {
	case *HumanQrLoginErrorLinkingNotSupported:
		writeInt32(writer, 1)
	case *HumanQrLoginErrorCancelled:
		writeInt32(writer, 2)
	case *HumanQrLoginErrorExpired:
		writeInt32(writer, 3)
	case *HumanQrLoginErrorConnectionInsecure:
		writeInt32(writer, 4)
	case *HumanQrLoginErrorDeclined:
		writeInt32(writer, 5)
	case *HumanQrLoginErrorUnknown:
		writeInt32(writer, 6)
	case *HumanQrLoginErrorSlidingSyncNotAvailable:
		writeInt32(writer, 7)
	case *HumanQrLoginErrorOidcMetadataInvalid:
		writeInt32(writer, 8)
	case *HumanQrLoginErrorOtherDeviceNotSignedIn:
		writeInt32(writer, 9)
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiConverterHumanQrLoginError.Write", value))
	}
}

type FfiDestroyerHumanQrLoginError struct{}

func (_ FfiDestroyerHumanQrLoginError) Destroy(value *HumanQrLoginError) {
	switch variantValue := value.err.(type) {
	case HumanQrLoginErrorLinkingNotSupported:
		variantValue.destroy()
	case HumanQrLoginErrorCancelled:
		variantValue.destroy()
	case HumanQrLoginErrorExpired:
		variantValue.destroy()
	case HumanQrLoginErrorConnectionInsecure:
		variantValue.destroy()
	case HumanQrLoginErrorDeclined:
		variantValue.destroy()
	case HumanQrLoginErrorUnknown:
		variantValue.destroy()
	case HumanQrLoginErrorSlidingSyncNotAvailable:
		variantValue.destroy()
	case HumanQrLoginErrorOidcMetadataInvalid:
		variantValue.destroy()
	case HumanQrLoginErrorOtherDeviceNotSignedIn:
		variantValue.destroy()
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiDestroyerHumanQrLoginError.Destroy", value))
	}
}

// Defines the intent of showing the call.
//
// This controls whether to show or skip the lobby.
type Intent uint

const (
	// The user wants to start a call.
	IntentStartCall Intent = 1
	// The user wants to join an existing call.
	IntentJoinExisting Intent = 2
)

type FfiConverterIntent struct{}

var FfiConverterIntentINSTANCE = FfiConverterIntent{}

func (c FfiConverterIntent) Lift(rb RustBufferI) Intent {
	return LiftFromRustBuffer[Intent](c, rb)
}

func (c FfiConverterIntent) Lower(value Intent) C.RustBuffer {
	return LowerIntoRustBuffer[Intent](c, value)
}
func (FfiConverterIntent) Read(reader io.Reader) Intent {
	id := readInt32(reader)
	return Intent(id)
}

func (FfiConverterIntent) Write(writer io.Writer, value Intent) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerIntent struct{}

func (_ FfiDestroyerIntent) Destroy(value Intent) {
}

// The policy that decides if avatars should be shown in invite requests.
type InviteAvatars uint

const (
	// Always show avatars in invite requests.
	InviteAvatarsOn InviteAvatars = 1
	// Never show avatars in invite requests.
	InviteAvatarsOff InviteAvatars = 2
)

type FfiConverterInviteAvatars struct{}

var FfiConverterInviteAvatarsINSTANCE = FfiConverterInviteAvatars{}

func (c FfiConverterInviteAvatars) Lift(rb RustBufferI) InviteAvatars {
	return LiftFromRustBuffer[InviteAvatars](c, rb)
}

func (c FfiConverterInviteAvatars) Lower(value InviteAvatars) C.RustBuffer {
	return LowerIntoRustBuffer[InviteAvatars](c, value)
}
func (FfiConverterInviteAvatars) Read(reader io.Reader) InviteAvatars {
	id := readInt32(reader)
	return InviteAvatars(id)
}

func (FfiConverterInviteAvatars) Write(writer io.Writer, value InviteAvatars) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerInviteAvatars struct{}

func (_ FfiDestroyerInviteAvatars) Destroy(value InviteAvatars) {
}

// The rule used for users wishing to join this room.
type JoinRule interface {
	Destroy()
}

// Anyone can join the room without any prior action.
type JoinRulePublic struct {
}

func (e JoinRulePublic) Destroy() {
}

// A user who wishes to join the room must first receive an invite to the
// room from someone already inside of the room.
type JoinRuleInvite struct {
}

func (e JoinRuleInvite) Destroy() {
}

// Users can join the room if they are invited, or they can request an
// invite to the room.
//
// They can be allowed (invited) or denied (kicked/banned) access.
type JoinRuleKnock struct {
}

func (e JoinRuleKnock) Destroy() {
}

// Reserved but not yet implemented by the Matrix specification.
type JoinRulePrivate struct {
}

func (e JoinRulePrivate) Destroy() {
}

// Users can join the room if they are invited, or if they meet any of the
// conditions described in a set of [`AllowRule`]s.
type JoinRuleRestricted struct {
	Rules []AllowRule
}

func (e JoinRuleRestricted) Destroy() {
	FfiDestroyerSequenceAllowRule{}.Destroy(e.Rules)
}

// Users can join the room if they are invited, or if they meet any of the
// conditions described in a set of [`AllowRule`]s, or they can request
// an invite to the room.
type JoinRuleKnockRestricted struct {
	Rules []AllowRule
}

func (e JoinRuleKnockRestricted) Destroy() {
	FfiDestroyerSequenceAllowRule{}.Destroy(e.Rules)
}

// A custom join rule, up for interpretation by the consumer.
type JoinRuleCustom struct {
	Repr string
}

func (e JoinRuleCustom) Destroy() {
	FfiDestroyerString{}.Destroy(e.Repr)
}

type FfiConverterJoinRule struct{}

var FfiConverterJoinRuleINSTANCE = FfiConverterJoinRule{}

func (c FfiConverterJoinRule) Lift(rb RustBufferI) JoinRule {
	return LiftFromRustBuffer[JoinRule](c, rb)
}

func (c FfiConverterJoinRule) Lower(value JoinRule) C.RustBuffer {
	return LowerIntoRustBuffer[JoinRule](c, value)
}
func (FfiConverterJoinRule) Read(reader io.Reader) JoinRule {
	id := readInt32(reader)
	switch id {
	case 1:
		return JoinRulePublic{}
	case 2:
		return JoinRuleInvite{}
	case 3:
		return JoinRuleKnock{}
	case 4:
		return JoinRulePrivate{}
	case 5:
		return JoinRuleRestricted{
			FfiConverterSequenceAllowRuleINSTANCE.Read(reader),
		}
	case 6:
		return JoinRuleKnockRestricted{
			FfiConverterSequenceAllowRuleINSTANCE.Read(reader),
		}
	case 7:
		return JoinRuleCustom{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterJoinRule.Read()", id))
	}
}

func (FfiConverterJoinRule) Write(writer io.Writer, value JoinRule) {
	switch variant_value := value.(type) {
	case JoinRulePublic:
		writeInt32(writer, 1)
	case JoinRuleInvite:
		writeInt32(writer, 2)
	case JoinRuleKnock:
		writeInt32(writer, 3)
	case JoinRulePrivate:
		writeInt32(writer, 4)
	case JoinRuleRestricted:
		writeInt32(writer, 5)
		FfiConverterSequenceAllowRuleINSTANCE.Write(writer, variant_value.Rules)
	case JoinRuleKnockRestricted:
		writeInt32(writer, 6)
		FfiConverterSequenceAllowRuleINSTANCE.Write(writer, variant_value.Rules)
	case JoinRuleCustom:
		writeInt32(writer, 7)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Repr)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterJoinRule.Write", value))
	}
}

type FfiDestroyerJoinRule struct{}

func (_ FfiDestroyerJoinRule) Destroy(value JoinRule) {
	value.Destroy()
}

type JsonValue interface {
	Destroy()
}

// Represents a `null` value.
type JsonValueNull struct {
}

func (e JsonValueNull) Destroy() {
}

// Represents a boolean.
type JsonValueBool struct {
	Value bool
}

func (e JsonValueBool) Destroy() {
	FfiDestroyerBool{}.Destroy(e.Value)
}

// Represents an integer.
type JsonValueInteger struct {
	Value int64
}

func (e JsonValueInteger) Destroy() {
	FfiDestroyerInt64{}.Destroy(e.Value)
}

// Represents a string.
type JsonValueString struct {
	Value string
}

func (e JsonValueString) Destroy() {
	FfiDestroyerString{}.Destroy(e.Value)
}

type FfiConverterJsonValue struct{}

var FfiConverterJsonValueINSTANCE = FfiConverterJsonValue{}

func (c FfiConverterJsonValue) Lift(rb RustBufferI) JsonValue {
	return LiftFromRustBuffer[JsonValue](c, rb)
}

func (c FfiConverterJsonValue) Lower(value JsonValue) C.RustBuffer {
	return LowerIntoRustBuffer[JsonValue](c, value)
}
func (FfiConverterJsonValue) Read(reader io.Reader) JsonValue {
	id := readInt32(reader)
	switch id {
	case 1:
		return JsonValueNull{}
	case 2:
		return JsonValueBool{
			FfiConverterBoolINSTANCE.Read(reader),
		}
	case 3:
		return JsonValueInteger{
			FfiConverterInt64INSTANCE.Read(reader),
		}
	case 4:
		return JsonValueString{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterJsonValue.Read()", id))
	}
}

func (FfiConverterJsonValue) Write(writer io.Writer, value JsonValue) {
	switch variant_value := value.(type) {
	case JsonValueNull:
		writeInt32(writer, 1)
	case JsonValueBool:
		writeInt32(writer, 2)
		FfiConverterBoolINSTANCE.Write(writer, variant_value.Value)
	case JsonValueInteger:
		writeInt32(writer, 3)
		FfiConverterInt64INSTANCE.Write(writer, variant_value.Value)
	case JsonValueString:
		writeInt32(writer, 4)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Value)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterJsonValue.Write", value))
	}
}

type FfiDestroyerJsonValue struct{}

func (_ FfiDestroyerJsonValue) Destroy(value JsonValue) {
	value.Destroy()
}

// A key algorithm to be used to generate a key from a passphrase.
type KeyDerivationAlgorithm uint

const (
	// PBKDF2
	KeyDerivationAlgorithmPbkfd2 KeyDerivationAlgorithm = 1
)

type FfiConverterKeyDerivationAlgorithm struct{}

var FfiConverterKeyDerivationAlgorithmINSTANCE = FfiConverterKeyDerivationAlgorithm{}

func (c FfiConverterKeyDerivationAlgorithm) Lift(rb RustBufferI) KeyDerivationAlgorithm {
	return LiftFromRustBuffer[KeyDerivationAlgorithm](c, rb)
}

func (c FfiConverterKeyDerivationAlgorithm) Lower(value KeyDerivationAlgorithm) C.RustBuffer {
	return LowerIntoRustBuffer[KeyDerivationAlgorithm](c, value)
}
func (FfiConverterKeyDerivationAlgorithm) Read(reader io.Reader) KeyDerivationAlgorithm {
	id := readInt32(reader)
	return KeyDerivationAlgorithm(id)
}

func (FfiConverterKeyDerivationAlgorithm) Write(writer io.Writer, value KeyDerivationAlgorithm) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerKeyDerivationAlgorithm struct{}

func (_ FfiDestroyerKeyDerivationAlgorithm) Destroy(value KeyDerivationAlgorithm) {
}

type LogLevel uint

const (
	LogLevelError LogLevel = 1
	LogLevelWarn  LogLevel = 2
	LogLevelInfo  LogLevel = 3
	LogLevelDebug LogLevel = 4
	LogLevelTrace LogLevel = 5
)

type FfiConverterLogLevel struct{}

var FfiConverterLogLevelINSTANCE = FfiConverterLogLevel{}

func (c FfiConverterLogLevel) Lift(rb RustBufferI) LogLevel {
	return LiftFromRustBuffer[LogLevel](c, rb)
}

func (c FfiConverterLogLevel) Lower(value LogLevel) C.RustBuffer {
	return LowerIntoRustBuffer[LogLevel](c, value)
}
func (FfiConverterLogLevel) Read(reader io.Reader) LogLevel {
	id := readInt32(reader)
	return LogLevel(id)
}

func (FfiConverterLogLevel) Write(writer io.Writer, value LogLevel) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerLogLevel struct{}

func (_ FfiDestroyerLogLevel) Destroy(value LogLevel) {
}

// A Matrix ID that can be a room, room alias, user, or event.
type MatrixId interface {
	Destroy()
}
type MatrixIdRoom struct {
	Id string
}

func (e MatrixIdRoom) Destroy() {
	FfiDestroyerString{}.Destroy(e.Id)
}

type MatrixIdRoomAlias struct {
	Alias string
}

func (e MatrixIdRoomAlias) Destroy() {
	FfiDestroyerString{}.Destroy(e.Alias)
}

type MatrixIdUser struct {
	Id string
}

func (e MatrixIdUser) Destroy() {
	FfiDestroyerString{}.Destroy(e.Id)
}

type MatrixIdEventOnRoomId struct {
	RoomId  string
	EventId string
}

func (e MatrixIdEventOnRoomId) Destroy() {
	FfiDestroyerString{}.Destroy(e.RoomId)
	FfiDestroyerString{}.Destroy(e.EventId)
}

type MatrixIdEventOnRoomAlias struct {
	Alias   string
	EventId string
}

func (e MatrixIdEventOnRoomAlias) Destroy() {
	FfiDestroyerString{}.Destroy(e.Alias)
	FfiDestroyerString{}.Destroy(e.EventId)
}

type FfiConverterMatrixId struct{}

var FfiConverterMatrixIdINSTANCE = FfiConverterMatrixId{}

func (c FfiConverterMatrixId) Lift(rb RustBufferI) MatrixId {
	return LiftFromRustBuffer[MatrixId](c, rb)
}

func (c FfiConverterMatrixId) Lower(value MatrixId) C.RustBuffer {
	return LowerIntoRustBuffer[MatrixId](c, value)
}
func (FfiConverterMatrixId) Read(reader io.Reader) MatrixId {
	id := readInt32(reader)
	switch id {
	case 1:
		return MatrixIdRoom{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 2:
		return MatrixIdRoomAlias{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 3:
		return MatrixIdUser{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 4:
		return MatrixIdEventOnRoomId{
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 5:
		return MatrixIdEventOnRoomAlias{
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterMatrixId.Read()", id))
	}
}

func (FfiConverterMatrixId) Write(writer io.Writer, value MatrixId) {
	switch variant_value := value.(type) {
	case MatrixIdRoom:
		writeInt32(writer, 1)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Id)
	case MatrixIdRoomAlias:
		writeInt32(writer, 2)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Alias)
	case MatrixIdUser:
		writeInt32(writer, 3)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Id)
	case MatrixIdEventOnRoomId:
		writeInt32(writer, 4)
		FfiConverterStringINSTANCE.Write(writer, variant_value.RoomId)
		FfiConverterStringINSTANCE.Write(writer, variant_value.EventId)
	case MatrixIdEventOnRoomAlias:
		writeInt32(writer, 5)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Alias)
		FfiConverterStringINSTANCE.Write(writer, variant_value.EventId)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterMatrixId.Write", value))
	}
}

type FfiDestroyerMatrixId struct{}

func (_ FfiDestroyerMatrixId) Destroy(value MatrixId) {
	value.Destroy()
}

type MediaInfoError struct {
	err error
}

// Convience method to turn *MediaInfoError into error
// Avoiding treating nil pointer as non nil error interface
func (err *MediaInfoError) AsError() error {
	if err == nil {
		return nil
	} else {
		return err
	}
}

func (err MediaInfoError) Error() string {
	return fmt.Sprintf("MediaInfoError: %s", err.err.Error())
}

func (err MediaInfoError) Unwrap() error {
	return err.err
}

// Err* are used for checking error type with `errors.Is`
var ErrMediaInfoErrorMissingField = fmt.Errorf("MediaInfoErrorMissingField")
var ErrMediaInfoErrorInvalidField = fmt.Errorf("MediaInfoErrorInvalidField")

// Variant structs
type MediaInfoErrorMissingField struct {
	message string
}

func NewMediaInfoErrorMissingField() *MediaInfoError {
	return &MediaInfoError{err: &MediaInfoErrorMissingField{}}
}

func (e MediaInfoErrorMissingField) destroy() {
}

func (err MediaInfoErrorMissingField) Error() string {
	return fmt.Sprintf("MissingField: %s", err.message)
}

func (self MediaInfoErrorMissingField) Is(target error) bool {
	return target == ErrMediaInfoErrorMissingField
}

type MediaInfoErrorInvalidField struct {
	message string
}

func NewMediaInfoErrorInvalidField() *MediaInfoError {
	return &MediaInfoError{err: &MediaInfoErrorInvalidField{}}
}

func (e MediaInfoErrorInvalidField) destroy() {
}

func (err MediaInfoErrorInvalidField) Error() string {
	return fmt.Sprintf("InvalidField: %s", err.message)
}

func (self MediaInfoErrorInvalidField) Is(target error) bool {
	return target == ErrMediaInfoErrorInvalidField
}

type FfiConverterMediaInfoError struct{}

var FfiConverterMediaInfoErrorINSTANCE = FfiConverterMediaInfoError{}

func (c FfiConverterMediaInfoError) Lift(eb RustBufferI) *MediaInfoError {
	return LiftFromRustBuffer[*MediaInfoError](c, eb)
}

func (c FfiConverterMediaInfoError) Lower(value *MediaInfoError) C.RustBuffer {
	return LowerIntoRustBuffer[*MediaInfoError](c, value)
}

func (c FfiConverterMediaInfoError) Read(reader io.Reader) *MediaInfoError {
	errorID := readUint32(reader)

	message := FfiConverterStringINSTANCE.Read(reader)
	switch errorID {
	case 1:
		return &MediaInfoError{&MediaInfoErrorMissingField{message}}
	case 2:
		return &MediaInfoError{&MediaInfoErrorInvalidField{message}}
	default:
		panic(fmt.Sprintf("Unknown error code %d in FfiConverterMediaInfoError.Read()", errorID))
	}

}

func (c FfiConverterMediaInfoError) Write(writer io.Writer, value *MediaInfoError) {
	switch variantValue := value.err.(type) {
	case *MediaInfoErrorMissingField:
		writeInt32(writer, 1)
	case *MediaInfoErrorInvalidField:
		writeInt32(writer, 2)
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiConverterMediaInfoError.Write", value))
	}
}

type FfiDestroyerMediaInfoError struct{}

func (_ FfiDestroyerMediaInfoError) Destroy(value *MediaInfoError) {
	switch variantValue := value.err.(type) {
	case MediaInfoErrorMissingField:
		variantValue.destroy()
	case MediaInfoErrorInvalidField:
		variantValue.destroy()
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiDestroyerMediaInfoError.Destroy", value))
	}
}

// The policy that decides if media previews should be shown in the timeline.
type MediaPreviews uint

const (
	// Always show media previews in the timeline.
	MediaPreviewsOn MediaPreviews = 1
	// Show media previews in the timeline only if the room is private.
	MediaPreviewsPrivate MediaPreviews = 2
	// Never show media previews in the timeline.
	MediaPreviewsOff MediaPreviews = 3
)

type FfiConverterMediaPreviews struct{}

var FfiConverterMediaPreviewsINSTANCE = FfiConverterMediaPreviews{}

func (c FfiConverterMediaPreviews) Lift(rb RustBufferI) MediaPreviews {
	return LiftFromRustBuffer[MediaPreviews](c, rb)
}

func (c FfiConverterMediaPreviews) Lower(value MediaPreviews) C.RustBuffer {
	return LowerIntoRustBuffer[MediaPreviews](c, value)
}
func (FfiConverterMediaPreviews) Read(reader io.Reader) MediaPreviews {
	id := readInt32(reader)
	return MediaPreviews(id)
}

func (FfiConverterMediaPreviews) Write(writer io.Writer, value MediaPreviews) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerMediaPreviews struct{}

func (_ FfiDestroyerMediaPreviews) Destroy(value MediaPreviews) {
}

type Membership uint

const (
	MembershipInvited Membership = 1
	MembershipJoined  Membership = 2
	MembershipLeft    Membership = 3
	MembershipKnocked Membership = 4
	MembershipBanned  Membership = 5
)

type FfiConverterMembership struct{}

var FfiConverterMembershipINSTANCE = FfiConverterMembership{}

func (c FfiConverterMembership) Lift(rb RustBufferI) Membership {
	return LiftFromRustBuffer[Membership](c, rb)
}

func (c FfiConverterMembership) Lower(value Membership) C.RustBuffer {
	return LowerIntoRustBuffer[Membership](c, value)
}
func (FfiConverterMembership) Read(reader io.Reader) Membership {
	id := readInt32(reader)
	return Membership(id)
}

func (FfiConverterMembership) Write(writer io.Writer, value Membership) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerMembership struct{}

func (_ FfiDestroyerMembership) Destroy(value Membership) {
}

type MembershipChange uint

const (
	MembershipChangeNone               MembershipChange = 1
	MembershipChangeError              MembershipChange = 2
	MembershipChangeJoined             MembershipChange = 3
	MembershipChangeLeft               MembershipChange = 4
	MembershipChangeBanned             MembershipChange = 5
	MembershipChangeUnbanned           MembershipChange = 6
	MembershipChangeKicked             MembershipChange = 7
	MembershipChangeInvited            MembershipChange = 8
	MembershipChangeKickedAndBanned    MembershipChange = 9
	MembershipChangeInvitationAccepted MembershipChange = 10
	MembershipChangeInvitationRejected MembershipChange = 11
	MembershipChangeInvitationRevoked  MembershipChange = 12
	MembershipChangeKnocked            MembershipChange = 13
	MembershipChangeKnockAccepted      MembershipChange = 14
	MembershipChangeKnockRetracted     MembershipChange = 15
	MembershipChangeKnockDenied        MembershipChange = 16
	MembershipChangeNotImplemented     MembershipChange = 17
)

type FfiConverterMembershipChange struct{}

var FfiConverterMembershipChangeINSTANCE = FfiConverterMembershipChange{}

func (c FfiConverterMembershipChange) Lift(rb RustBufferI) MembershipChange {
	return LiftFromRustBuffer[MembershipChange](c, rb)
}

func (c FfiConverterMembershipChange) Lower(value MembershipChange) C.RustBuffer {
	return LowerIntoRustBuffer[MembershipChange](c, value)
}
func (FfiConverterMembershipChange) Read(reader io.Reader) MembershipChange {
	id := readInt32(reader)
	return MembershipChange(id)
}

func (FfiConverterMembershipChange) Write(writer io.Writer, value MembershipChange) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerMembershipChange struct{}

func (_ FfiDestroyerMembershipChange) Destroy(value MembershipChange) {
}

type MembershipState interface {
	Destroy()
}

// The user is banned.
type MembershipStateBan struct {
}

func (e MembershipStateBan) Destroy() {
}

// The user has been invited.
type MembershipStateInvite struct {
}

func (e MembershipStateInvite) Destroy() {
}

// The user has joined.
type MembershipStateJoin struct {
}

func (e MembershipStateJoin) Destroy() {
}

// The user has requested to join.
type MembershipStateKnock struct {
}

func (e MembershipStateKnock) Destroy() {
}

// The user has left.
type MembershipStateLeave struct {
}

func (e MembershipStateLeave) Destroy() {
}

// A custom membership state value.
type MembershipStateCustom struct {
	Value string
}

func (e MembershipStateCustom) Destroy() {
	FfiDestroyerString{}.Destroy(e.Value)
}

type FfiConverterMembershipState struct{}

var FfiConverterMembershipStateINSTANCE = FfiConverterMembershipState{}

func (c FfiConverterMembershipState) Lift(rb RustBufferI) MembershipState {
	return LiftFromRustBuffer[MembershipState](c, rb)
}

func (c FfiConverterMembershipState) Lower(value MembershipState) C.RustBuffer {
	return LowerIntoRustBuffer[MembershipState](c, value)
}
func (FfiConverterMembershipState) Read(reader io.Reader) MembershipState {
	id := readInt32(reader)
	switch id {
	case 1:
		return MembershipStateBan{}
	case 2:
		return MembershipStateInvite{}
	case 3:
		return MembershipStateJoin{}
	case 4:
		return MembershipStateKnock{}
	case 5:
		return MembershipStateLeave{}
	case 6:
		return MembershipStateCustom{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterMembershipState.Read()", id))
	}
}

func (FfiConverterMembershipState) Write(writer io.Writer, value MembershipState) {
	switch variant_value := value.(type) {
	case MembershipStateBan:
		writeInt32(writer, 1)
	case MembershipStateInvite:
		writeInt32(writer, 2)
	case MembershipStateJoin:
		writeInt32(writer, 3)
	case MembershipStateKnock:
		writeInt32(writer, 4)
	case MembershipStateLeave:
		writeInt32(writer, 5)
	case MembershipStateCustom:
		writeInt32(writer, 6)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Value)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterMembershipState.Write", value))
	}
}

type FfiDestroyerMembershipState struct{}

func (_ FfiDestroyerMembershipState) Destroy(value MembershipState) {
	value.Destroy()
}

type MessageFormat interface {
	Destroy()
}
type MessageFormatHtml struct {
}

func (e MessageFormatHtml) Destroy() {
}

type MessageFormatUnknown struct {
	Format string
}

func (e MessageFormatUnknown) Destroy() {
	FfiDestroyerString{}.Destroy(e.Format)
}

type FfiConverterMessageFormat struct{}

var FfiConverterMessageFormatINSTANCE = FfiConverterMessageFormat{}

func (c FfiConverterMessageFormat) Lift(rb RustBufferI) MessageFormat {
	return LiftFromRustBuffer[MessageFormat](c, rb)
}

func (c FfiConverterMessageFormat) Lower(value MessageFormat) C.RustBuffer {
	return LowerIntoRustBuffer[MessageFormat](c, value)
}
func (FfiConverterMessageFormat) Read(reader io.Reader) MessageFormat {
	id := readInt32(reader)
	switch id {
	case 1:
		return MessageFormatHtml{}
	case 2:
		return MessageFormatUnknown{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterMessageFormat.Read()", id))
	}
}

func (FfiConverterMessageFormat) Write(writer io.Writer, value MessageFormat) {
	switch variant_value := value.(type) {
	case MessageFormatHtml:
		writeInt32(writer, 1)
	case MessageFormatUnknown:
		writeInt32(writer, 2)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Format)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterMessageFormat.Write", value))
	}
}

type FfiDestroyerMessageFormat struct{}

func (_ FfiDestroyerMessageFormat) Destroy(value MessageFormat) {
	value.Destroy()
}

type MessageLikeEventContent interface {
	Destroy()
}
type MessageLikeEventContentCallAnswer struct {
}

func (e MessageLikeEventContentCallAnswer) Destroy() {
}

type MessageLikeEventContentCallInvite struct {
}

func (e MessageLikeEventContentCallInvite) Destroy() {
}

type MessageLikeEventContentCallNotify struct {
	NotifyType NotifyType
}

func (e MessageLikeEventContentCallNotify) Destroy() {
	FfiDestroyerNotifyType{}.Destroy(e.NotifyType)
}

type MessageLikeEventContentCallHangup struct {
}

func (e MessageLikeEventContentCallHangup) Destroy() {
}

type MessageLikeEventContentCallCandidates struct {
}

func (e MessageLikeEventContentCallCandidates) Destroy() {
}

type MessageLikeEventContentKeyVerificationReady struct {
}

func (e MessageLikeEventContentKeyVerificationReady) Destroy() {
}

type MessageLikeEventContentKeyVerificationStart struct {
}

func (e MessageLikeEventContentKeyVerificationStart) Destroy() {
}

type MessageLikeEventContentKeyVerificationCancel struct {
}

func (e MessageLikeEventContentKeyVerificationCancel) Destroy() {
}

type MessageLikeEventContentKeyVerificationAccept struct {
}

func (e MessageLikeEventContentKeyVerificationAccept) Destroy() {
}

type MessageLikeEventContentKeyVerificationKey struct {
}

func (e MessageLikeEventContentKeyVerificationKey) Destroy() {
}

type MessageLikeEventContentKeyVerificationMac struct {
}

func (e MessageLikeEventContentKeyVerificationMac) Destroy() {
}

type MessageLikeEventContentKeyVerificationDone struct {
}

func (e MessageLikeEventContentKeyVerificationDone) Destroy() {
}

type MessageLikeEventContentPoll struct {
	Question string
}

func (e MessageLikeEventContentPoll) Destroy() {
	FfiDestroyerString{}.Destroy(e.Question)
}

type MessageLikeEventContentReactionContent struct {
	RelatedEventId string
}

func (e MessageLikeEventContentReactionContent) Destroy() {
	FfiDestroyerString{}.Destroy(e.RelatedEventId)
}

type MessageLikeEventContentRoomEncrypted struct {
}

func (e MessageLikeEventContentRoomEncrypted) Destroy() {
}

type MessageLikeEventContentRoomMessage struct {
	MessageType      MessageType
	InReplyToEventId *string
}

func (e MessageLikeEventContentRoomMessage) Destroy() {
	FfiDestroyerMessageType{}.Destroy(e.MessageType)
	FfiDestroyerOptionalString{}.Destroy(e.InReplyToEventId)
}

type MessageLikeEventContentRoomRedaction struct {
	RedactedEventId *string
	Reason          *string
}

func (e MessageLikeEventContentRoomRedaction) Destroy() {
	FfiDestroyerOptionalString{}.Destroy(e.RedactedEventId)
	FfiDestroyerOptionalString{}.Destroy(e.Reason)
}

type MessageLikeEventContentSticker struct {
}

func (e MessageLikeEventContentSticker) Destroy() {
}

type FfiConverterMessageLikeEventContent struct{}

var FfiConverterMessageLikeEventContentINSTANCE = FfiConverterMessageLikeEventContent{}

func (c FfiConverterMessageLikeEventContent) Lift(rb RustBufferI) MessageLikeEventContent {
	return LiftFromRustBuffer[MessageLikeEventContent](c, rb)
}

func (c FfiConverterMessageLikeEventContent) Lower(value MessageLikeEventContent) C.RustBuffer {
	return LowerIntoRustBuffer[MessageLikeEventContent](c, value)
}
func (FfiConverterMessageLikeEventContent) Read(reader io.Reader) MessageLikeEventContent {
	id := readInt32(reader)
	switch id {
	case 1:
		return MessageLikeEventContentCallAnswer{}
	case 2:
		return MessageLikeEventContentCallInvite{}
	case 3:
		return MessageLikeEventContentCallNotify{
			FfiConverterNotifyTypeINSTANCE.Read(reader),
		}
	case 4:
		return MessageLikeEventContentCallHangup{}
	case 5:
		return MessageLikeEventContentCallCandidates{}
	case 6:
		return MessageLikeEventContentKeyVerificationReady{}
	case 7:
		return MessageLikeEventContentKeyVerificationStart{}
	case 8:
		return MessageLikeEventContentKeyVerificationCancel{}
	case 9:
		return MessageLikeEventContentKeyVerificationAccept{}
	case 10:
		return MessageLikeEventContentKeyVerificationKey{}
	case 11:
		return MessageLikeEventContentKeyVerificationMac{}
	case 12:
		return MessageLikeEventContentKeyVerificationDone{}
	case 13:
		return MessageLikeEventContentPoll{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 14:
		return MessageLikeEventContentReactionContent{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 15:
		return MessageLikeEventContentRoomEncrypted{}
	case 16:
		return MessageLikeEventContentRoomMessage{
			FfiConverterMessageTypeINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
		}
	case 17:
		return MessageLikeEventContentRoomRedaction{
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
		}
	case 18:
		return MessageLikeEventContentSticker{}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterMessageLikeEventContent.Read()", id))
	}
}

func (FfiConverterMessageLikeEventContent) Write(writer io.Writer, value MessageLikeEventContent) {
	switch variant_value := value.(type) {
	case MessageLikeEventContentCallAnswer:
		writeInt32(writer, 1)
	case MessageLikeEventContentCallInvite:
		writeInt32(writer, 2)
	case MessageLikeEventContentCallNotify:
		writeInt32(writer, 3)
		FfiConverterNotifyTypeINSTANCE.Write(writer, variant_value.NotifyType)
	case MessageLikeEventContentCallHangup:
		writeInt32(writer, 4)
	case MessageLikeEventContentCallCandidates:
		writeInt32(writer, 5)
	case MessageLikeEventContentKeyVerificationReady:
		writeInt32(writer, 6)
	case MessageLikeEventContentKeyVerificationStart:
		writeInt32(writer, 7)
	case MessageLikeEventContentKeyVerificationCancel:
		writeInt32(writer, 8)
	case MessageLikeEventContentKeyVerificationAccept:
		writeInt32(writer, 9)
	case MessageLikeEventContentKeyVerificationKey:
		writeInt32(writer, 10)
	case MessageLikeEventContentKeyVerificationMac:
		writeInt32(writer, 11)
	case MessageLikeEventContentKeyVerificationDone:
		writeInt32(writer, 12)
	case MessageLikeEventContentPoll:
		writeInt32(writer, 13)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Question)
	case MessageLikeEventContentReactionContent:
		writeInt32(writer, 14)
		FfiConverterStringINSTANCE.Write(writer, variant_value.RelatedEventId)
	case MessageLikeEventContentRoomEncrypted:
		writeInt32(writer, 15)
	case MessageLikeEventContentRoomMessage:
		writeInt32(writer, 16)
		FfiConverterMessageTypeINSTANCE.Write(writer, variant_value.MessageType)
		FfiConverterOptionalStringINSTANCE.Write(writer, variant_value.InReplyToEventId)
	case MessageLikeEventContentRoomRedaction:
		writeInt32(writer, 17)
		FfiConverterOptionalStringINSTANCE.Write(writer, variant_value.RedactedEventId)
		FfiConverterOptionalStringINSTANCE.Write(writer, variant_value.Reason)
	case MessageLikeEventContentSticker:
		writeInt32(writer, 18)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterMessageLikeEventContent.Write", value))
	}
}

type FfiDestroyerMessageLikeEventContent struct{}

func (_ FfiDestroyerMessageLikeEventContent) Destroy(value MessageLikeEventContent) {
	value.Destroy()
}

type MessageLikeEventType uint

const (
	MessageLikeEventTypeCallAnswer            MessageLikeEventType = 1
	MessageLikeEventTypeCallCandidates        MessageLikeEventType = 2
	MessageLikeEventTypeCallHangup            MessageLikeEventType = 3
	MessageLikeEventTypeCallInvite            MessageLikeEventType = 4
	MessageLikeEventTypeCallNotify            MessageLikeEventType = 5
	MessageLikeEventTypeKeyVerificationAccept MessageLikeEventType = 6
	MessageLikeEventTypeKeyVerificationCancel MessageLikeEventType = 7
	MessageLikeEventTypeKeyVerificationDone   MessageLikeEventType = 8
	MessageLikeEventTypeKeyVerificationKey    MessageLikeEventType = 9
	MessageLikeEventTypeKeyVerificationMac    MessageLikeEventType = 10
	MessageLikeEventTypeKeyVerificationReady  MessageLikeEventType = 11
	MessageLikeEventTypeKeyVerificationStart  MessageLikeEventType = 12
	MessageLikeEventTypePollEnd               MessageLikeEventType = 13
	MessageLikeEventTypePollResponse          MessageLikeEventType = 14
	MessageLikeEventTypePollStart             MessageLikeEventType = 15
	MessageLikeEventTypeReaction              MessageLikeEventType = 16
	MessageLikeEventTypeRoomEncrypted         MessageLikeEventType = 17
	MessageLikeEventTypeRoomMessage           MessageLikeEventType = 18
	MessageLikeEventTypeRoomRedaction         MessageLikeEventType = 19
	MessageLikeEventTypeSticker               MessageLikeEventType = 20
	MessageLikeEventTypeUnstablePollEnd       MessageLikeEventType = 21
	MessageLikeEventTypeUnstablePollResponse  MessageLikeEventType = 22
	MessageLikeEventTypeUnstablePollStart     MessageLikeEventType = 23
)

type FfiConverterMessageLikeEventType struct{}

var FfiConverterMessageLikeEventTypeINSTANCE = FfiConverterMessageLikeEventType{}

func (c FfiConverterMessageLikeEventType) Lift(rb RustBufferI) MessageLikeEventType {
	return LiftFromRustBuffer[MessageLikeEventType](c, rb)
}

func (c FfiConverterMessageLikeEventType) Lower(value MessageLikeEventType) C.RustBuffer {
	return LowerIntoRustBuffer[MessageLikeEventType](c, value)
}
func (FfiConverterMessageLikeEventType) Read(reader io.Reader) MessageLikeEventType {
	id := readInt32(reader)
	return MessageLikeEventType(id)
}

func (FfiConverterMessageLikeEventType) Write(writer io.Writer, value MessageLikeEventType) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerMessageLikeEventType struct{}

func (_ FfiDestroyerMessageLikeEventType) Destroy(value MessageLikeEventType) {
}

type MessageType interface {
	Destroy()
}
type MessageTypeEmote struct {
	Content EmoteMessageContent
}

func (e MessageTypeEmote) Destroy() {
	FfiDestroyerEmoteMessageContent{}.Destroy(e.Content)
}

type MessageTypeImage struct {
	Content ImageMessageContent
}

func (e MessageTypeImage) Destroy() {
	FfiDestroyerImageMessageContent{}.Destroy(e.Content)
}

type MessageTypeAudio struct {
	Content AudioMessageContent
}

func (e MessageTypeAudio) Destroy() {
	FfiDestroyerAudioMessageContent{}.Destroy(e.Content)
}

type MessageTypeVideo struct {
	Content VideoMessageContent
}

func (e MessageTypeVideo) Destroy() {
	FfiDestroyerVideoMessageContent{}.Destroy(e.Content)
}

type MessageTypeFile struct {
	Content FileMessageContent
}

func (e MessageTypeFile) Destroy() {
	FfiDestroyerFileMessageContent{}.Destroy(e.Content)
}

type MessageTypeNotice struct {
	Content NoticeMessageContent
}

func (e MessageTypeNotice) Destroy() {
	FfiDestroyerNoticeMessageContent{}.Destroy(e.Content)
}

type MessageTypeText struct {
	Content TextMessageContent
}

func (e MessageTypeText) Destroy() {
	FfiDestroyerTextMessageContent{}.Destroy(e.Content)
}

type MessageTypeLocation struct {
	Content LocationContent
}

func (e MessageTypeLocation) Destroy() {
	FfiDestroyerLocationContent{}.Destroy(e.Content)
}

type MessageTypeOther struct {
	Msgtype string
	Body    string
}

func (e MessageTypeOther) Destroy() {
	FfiDestroyerString{}.Destroy(e.Msgtype)
	FfiDestroyerString{}.Destroy(e.Body)
}

type FfiConverterMessageType struct{}

var FfiConverterMessageTypeINSTANCE = FfiConverterMessageType{}

func (c FfiConverterMessageType) Lift(rb RustBufferI) MessageType {
	return LiftFromRustBuffer[MessageType](c, rb)
}

func (c FfiConverterMessageType) Lower(value MessageType) C.RustBuffer {
	return LowerIntoRustBuffer[MessageType](c, value)
}
func (FfiConverterMessageType) Read(reader io.Reader) MessageType {
	id := readInt32(reader)
	switch id {
	case 1:
		return MessageTypeEmote{
			FfiConverterEmoteMessageContentINSTANCE.Read(reader),
		}
	case 2:
		return MessageTypeImage{
			FfiConverterImageMessageContentINSTANCE.Read(reader),
		}
	case 3:
		return MessageTypeAudio{
			FfiConverterAudioMessageContentINSTANCE.Read(reader),
		}
	case 4:
		return MessageTypeVideo{
			FfiConverterVideoMessageContentINSTANCE.Read(reader),
		}
	case 5:
		return MessageTypeFile{
			FfiConverterFileMessageContentINSTANCE.Read(reader),
		}
	case 6:
		return MessageTypeNotice{
			FfiConverterNoticeMessageContentINSTANCE.Read(reader),
		}
	case 7:
		return MessageTypeText{
			FfiConverterTextMessageContentINSTANCE.Read(reader),
		}
	case 8:
		return MessageTypeLocation{
			FfiConverterLocationContentINSTANCE.Read(reader),
		}
	case 9:
		return MessageTypeOther{
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterMessageType.Read()", id))
	}
}

func (FfiConverterMessageType) Write(writer io.Writer, value MessageType) {
	switch variant_value := value.(type) {
	case MessageTypeEmote:
		writeInt32(writer, 1)
		FfiConverterEmoteMessageContentINSTANCE.Write(writer, variant_value.Content)
	case MessageTypeImage:
		writeInt32(writer, 2)
		FfiConverterImageMessageContentINSTANCE.Write(writer, variant_value.Content)
	case MessageTypeAudio:
		writeInt32(writer, 3)
		FfiConverterAudioMessageContentINSTANCE.Write(writer, variant_value.Content)
	case MessageTypeVideo:
		writeInt32(writer, 4)
		FfiConverterVideoMessageContentINSTANCE.Write(writer, variant_value.Content)
	case MessageTypeFile:
		writeInt32(writer, 5)
		FfiConverterFileMessageContentINSTANCE.Write(writer, variant_value.Content)
	case MessageTypeNotice:
		writeInt32(writer, 6)
		FfiConverterNoticeMessageContentINSTANCE.Write(writer, variant_value.Content)
	case MessageTypeText:
		writeInt32(writer, 7)
		FfiConverterTextMessageContentINSTANCE.Write(writer, variant_value.Content)
	case MessageTypeLocation:
		writeInt32(writer, 8)
		FfiConverterLocationContentINSTANCE.Write(writer, variant_value.Content)
	case MessageTypeOther:
		writeInt32(writer, 9)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Msgtype)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Body)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterMessageType.Write", value))
	}
}

type FfiDestroyerMessageType struct{}

func (_ FfiDestroyerMessageType) Destroy(value MessageType) {
	value.Destroy()
}

type MsgLikeKind interface {
	Destroy()
}

// An `m.room.message` event or extensible event, including edits.
type MsgLikeKindMessage struct {
	Content MessageContent
}

func (e MsgLikeKindMessage) Destroy() {
	FfiDestroyerMessageContent{}.Destroy(e.Content)
}

// An `m.sticker` event.
type MsgLikeKindSticker struct {
	Body   string
	Info   ImageInfo
	Source *MediaSource
}

func (e MsgLikeKindSticker) Destroy() {
	FfiDestroyerString{}.Destroy(e.Body)
	FfiDestroyerImageInfo{}.Destroy(e.Info)
	FfiDestroyerMediaSource{}.Destroy(e.Source)
}

// An `m.poll.start` event.
type MsgLikeKindPoll struct {
	Question      string
	Kind          PollKind
	MaxSelections uint64
	Answers       []PollAnswer
	Votes         map[string][]string
	EndTime       *Timestamp
	HasBeenEdited bool
}

func (e MsgLikeKindPoll) Destroy() {
	FfiDestroyerString{}.Destroy(e.Question)
	FfiDestroyerPollKind{}.Destroy(e.Kind)
	FfiDestroyerUint64{}.Destroy(e.MaxSelections)
	FfiDestroyerSequencePollAnswer{}.Destroy(e.Answers)
	FfiDestroyerMapStringSequenceString{}.Destroy(e.Votes)
	FfiDestroyerOptionalTypeTimestamp{}.Destroy(e.EndTime)
	FfiDestroyerBool{}.Destroy(e.HasBeenEdited)
}

// A redacted message.
type MsgLikeKindRedacted struct {
}

func (e MsgLikeKindRedacted) Destroy() {
}

// An `m.room.encrypted` event that could not be decrypted.
type MsgLikeKindUnableToDecrypt struct {
	Msg EncryptedMessage
}

func (e MsgLikeKindUnableToDecrypt) Destroy() {
	FfiDestroyerEncryptedMessage{}.Destroy(e.Msg)
}

type FfiConverterMsgLikeKind struct{}

var FfiConverterMsgLikeKindINSTANCE = FfiConverterMsgLikeKind{}

func (c FfiConverterMsgLikeKind) Lift(rb RustBufferI) MsgLikeKind {
	return LiftFromRustBuffer[MsgLikeKind](c, rb)
}

func (c FfiConverterMsgLikeKind) Lower(value MsgLikeKind) C.RustBuffer {
	return LowerIntoRustBuffer[MsgLikeKind](c, value)
}
func (FfiConverterMsgLikeKind) Read(reader io.Reader) MsgLikeKind {
	id := readInt32(reader)
	switch id {
	case 1:
		return MsgLikeKindMessage{
			FfiConverterMessageContentINSTANCE.Read(reader),
		}
	case 2:
		return MsgLikeKindSticker{
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterImageInfoINSTANCE.Read(reader),
			FfiConverterMediaSourceINSTANCE.Read(reader),
		}
	case 3:
		return MsgLikeKindPoll{
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterPollKindINSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
			FfiConverterSequencePollAnswerINSTANCE.Read(reader),
			FfiConverterMapStringSequenceStringINSTANCE.Read(reader),
			FfiConverterOptionalTypeTimestampINSTANCE.Read(reader),
			FfiConverterBoolINSTANCE.Read(reader),
		}
	case 4:
		return MsgLikeKindRedacted{}
	case 5:
		return MsgLikeKindUnableToDecrypt{
			FfiConverterEncryptedMessageINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterMsgLikeKind.Read()", id))
	}
}

func (FfiConverterMsgLikeKind) Write(writer io.Writer, value MsgLikeKind) {
	switch variant_value := value.(type) {
	case MsgLikeKindMessage:
		writeInt32(writer, 1)
		FfiConverterMessageContentINSTANCE.Write(writer, variant_value.Content)
	case MsgLikeKindSticker:
		writeInt32(writer, 2)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Body)
		FfiConverterImageInfoINSTANCE.Write(writer, variant_value.Info)
		FfiConverterMediaSourceINSTANCE.Write(writer, variant_value.Source)
	case MsgLikeKindPoll:
		writeInt32(writer, 3)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Question)
		FfiConverterPollKindINSTANCE.Write(writer, variant_value.Kind)
		FfiConverterUint64INSTANCE.Write(writer, variant_value.MaxSelections)
		FfiConverterSequencePollAnswerINSTANCE.Write(writer, variant_value.Answers)
		FfiConverterMapStringSequenceStringINSTANCE.Write(writer, variant_value.Votes)
		FfiConverterOptionalTypeTimestampINSTANCE.Write(writer, variant_value.EndTime)
		FfiConverterBoolINSTANCE.Write(writer, variant_value.HasBeenEdited)
	case MsgLikeKindRedacted:
		writeInt32(writer, 4)
	case MsgLikeKindUnableToDecrypt:
		writeInt32(writer, 5)
		FfiConverterEncryptedMessageINSTANCE.Write(writer, variant_value.Msg)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterMsgLikeKind.Write", value))
	}
}

type FfiDestroyerMsgLikeKind struct{}

func (_ FfiDestroyerMsgLikeKind) Destroy(value MsgLikeKind) {
	value.Destroy()
}

type NotificationEvent interface {
	Destroy()
}
type NotificationEventTimeline struct {
	Event *TimelineEvent
}

func (e NotificationEventTimeline) Destroy() {
	FfiDestroyerTimelineEvent{}.Destroy(e.Event)
}

type NotificationEventInvite struct {
	Sender string
}

func (e NotificationEventInvite) Destroy() {
	FfiDestroyerString{}.Destroy(e.Sender)
}

type FfiConverterNotificationEvent struct{}

var FfiConverterNotificationEventINSTANCE = FfiConverterNotificationEvent{}

func (c FfiConverterNotificationEvent) Lift(rb RustBufferI) NotificationEvent {
	return LiftFromRustBuffer[NotificationEvent](c, rb)
}

func (c FfiConverterNotificationEvent) Lower(value NotificationEvent) C.RustBuffer {
	return LowerIntoRustBuffer[NotificationEvent](c, value)
}
func (FfiConverterNotificationEvent) Read(reader io.Reader) NotificationEvent {
	id := readInt32(reader)
	switch id {
	case 1:
		return NotificationEventTimeline{
			FfiConverterTimelineEventINSTANCE.Read(reader),
		}
	case 2:
		return NotificationEventInvite{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterNotificationEvent.Read()", id))
	}
}

func (FfiConverterNotificationEvent) Write(writer io.Writer, value NotificationEvent) {
	switch variant_value := value.(type) {
	case NotificationEventTimeline:
		writeInt32(writer, 1)
		FfiConverterTimelineEventINSTANCE.Write(writer, variant_value.Event)
	case NotificationEventInvite:
		writeInt32(writer, 2)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Sender)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterNotificationEvent.Write", value))
	}
}

type FfiDestroyerNotificationEvent struct{}

func (_ FfiDestroyerNotificationEvent) Destroy(value NotificationEvent) {
	value.Destroy()
}

type NotificationProcessSetup interface {
	Destroy()
}
type NotificationProcessSetupMultipleProcesses struct {
}

func (e NotificationProcessSetupMultipleProcesses) Destroy() {
}

type NotificationProcessSetupSingleProcess struct {
	SyncService *SyncService
}

func (e NotificationProcessSetupSingleProcess) Destroy() {
	FfiDestroyerSyncService{}.Destroy(e.SyncService)
}

type FfiConverterNotificationProcessSetup struct{}

var FfiConverterNotificationProcessSetupINSTANCE = FfiConverterNotificationProcessSetup{}

func (c FfiConverterNotificationProcessSetup) Lift(rb RustBufferI) NotificationProcessSetup {
	return LiftFromRustBuffer[NotificationProcessSetup](c, rb)
}

func (c FfiConverterNotificationProcessSetup) Lower(value NotificationProcessSetup) C.RustBuffer {
	return LowerIntoRustBuffer[NotificationProcessSetup](c, value)
}
func (FfiConverterNotificationProcessSetup) Read(reader io.Reader) NotificationProcessSetup {
	id := readInt32(reader)
	switch id {
	case 1:
		return NotificationProcessSetupMultipleProcesses{}
	case 2:
		return NotificationProcessSetupSingleProcess{
			FfiConverterSyncServiceINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterNotificationProcessSetup.Read()", id))
	}
}

func (FfiConverterNotificationProcessSetup) Write(writer io.Writer, value NotificationProcessSetup) {
	switch variant_value := value.(type) {
	case NotificationProcessSetupMultipleProcesses:
		writeInt32(writer, 1)
	case NotificationProcessSetupSingleProcess:
		writeInt32(writer, 2)
		FfiConverterSyncServiceINSTANCE.Write(writer, variant_value.SyncService)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterNotificationProcessSetup.Write", value))
	}
}

type FfiDestroyerNotificationProcessSetup struct{}

func (_ FfiDestroyerNotificationProcessSetup) Destroy(value NotificationProcessSetup) {
	value.Destroy()
}

type NotificationSettingsError struct {
	err error
}

// Convience method to turn *NotificationSettingsError into error
// Avoiding treating nil pointer as non nil error interface
func (err *NotificationSettingsError) AsError() error {
	if err == nil {
		return nil
	} else {
		return err
	}
}

func (err NotificationSettingsError) Error() string {
	return fmt.Sprintf("NotificationSettingsError: %s", err.err.Error())
}

func (err NotificationSettingsError) Unwrap() error {
	return err.err
}

// Err* are used for checking error type with `errors.Is`
var ErrNotificationSettingsErrorGeneric = fmt.Errorf("NotificationSettingsErrorGeneric")
var ErrNotificationSettingsErrorInvalidParameter = fmt.Errorf("NotificationSettingsErrorInvalidParameter")
var ErrNotificationSettingsErrorInvalidRoomId = fmt.Errorf("NotificationSettingsErrorInvalidRoomId")
var ErrNotificationSettingsErrorRuleNotFound = fmt.Errorf("NotificationSettingsErrorRuleNotFound")
var ErrNotificationSettingsErrorUnableToAddPushRule = fmt.Errorf("NotificationSettingsErrorUnableToAddPushRule")
var ErrNotificationSettingsErrorUnableToRemovePushRule = fmt.Errorf("NotificationSettingsErrorUnableToRemovePushRule")
var ErrNotificationSettingsErrorUnableToSavePushRules = fmt.Errorf("NotificationSettingsErrorUnableToSavePushRules")
var ErrNotificationSettingsErrorUnableToUpdatePushRule = fmt.Errorf("NotificationSettingsErrorUnableToUpdatePushRule")

// Variant structs
type NotificationSettingsErrorGeneric struct {
	Msg string
}

func NewNotificationSettingsErrorGeneric(
	msg string,
) *NotificationSettingsError {
	return &NotificationSettingsError{err: &NotificationSettingsErrorGeneric{
		Msg: msg}}
}

func (e NotificationSettingsErrorGeneric) destroy() {
	FfiDestroyerString{}.Destroy(e.Msg)
}

func (err NotificationSettingsErrorGeneric) Error() string {
	return fmt.Sprint("Generic",
		": ",

		"Msg=",
		err.Msg,
	)
}

func (self NotificationSettingsErrorGeneric) Is(target error) bool {
	return target == ErrNotificationSettingsErrorGeneric
}

// Invalid parameter.
type NotificationSettingsErrorInvalidParameter struct {
	Msg string
}

// Invalid parameter.
func NewNotificationSettingsErrorInvalidParameter(
	msg string,
) *NotificationSettingsError {
	return &NotificationSettingsError{err: &NotificationSettingsErrorInvalidParameter{
		Msg: msg}}
}

func (e NotificationSettingsErrorInvalidParameter) destroy() {
	FfiDestroyerString{}.Destroy(e.Msg)
}

func (err NotificationSettingsErrorInvalidParameter) Error() string {
	return fmt.Sprint("InvalidParameter",
		": ",

		"Msg=",
		err.Msg,
	)
}

func (self NotificationSettingsErrorInvalidParameter) Is(target error) bool {
	return target == ErrNotificationSettingsErrorInvalidParameter
}

// Invalid room id.
type NotificationSettingsErrorInvalidRoomId struct {
	RoomId string
}

// Invalid room id.
func NewNotificationSettingsErrorInvalidRoomId(
	roomId string,
) *NotificationSettingsError {
	return &NotificationSettingsError{err: &NotificationSettingsErrorInvalidRoomId{
		RoomId: roomId}}
}

func (e NotificationSettingsErrorInvalidRoomId) destroy() {
	FfiDestroyerString{}.Destroy(e.RoomId)
}

func (err NotificationSettingsErrorInvalidRoomId) Error() string {
	return fmt.Sprint("InvalidRoomId",
		": ",

		"RoomId=",
		err.RoomId,
	)
}

func (self NotificationSettingsErrorInvalidRoomId) Is(target error) bool {
	return target == ErrNotificationSettingsErrorInvalidRoomId
}

// Rule not found
type NotificationSettingsErrorRuleNotFound struct {
	RuleId string
}

// Rule not found
func NewNotificationSettingsErrorRuleNotFound(
	ruleId string,
) *NotificationSettingsError {
	return &NotificationSettingsError{err: &NotificationSettingsErrorRuleNotFound{
		RuleId: ruleId}}
}

func (e NotificationSettingsErrorRuleNotFound) destroy() {
	FfiDestroyerString{}.Destroy(e.RuleId)
}

func (err NotificationSettingsErrorRuleNotFound) Error() string {
	return fmt.Sprint("RuleNotFound",
		": ",

		"RuleId=",
		err.RuleId,
	)
}

func (self NotificationSettingsErrorRuleNotFound) Is(target error) bool {
	return target == ErrNotificationSettingsErrorRuleNotFound
}

// Unable to add push rule.
type NotificationSettingsErrorUnableToAddPushRule struct {
}

// Unable to add push rule.
func NewNotificationSettingsErrorUnableToAddPushRule() *NotificationSettingsError {
	return &NotificationSettingsError{err: &NotificationSettingsErrorUnableToAddPushRule{}}
}

func (e NotificationSettingsErrorUnableToAddPushRule) destroy() {
}

func (err NotificationSettingsErrorUnableToAddPushRule) Error() string {
	return fmt.Sprint("UnableToAddPushRule")
}

func (self NotificationSettingsErrorUnableToAddPushRule) Is(target error) bool {
	return target == ErrNotificationSettingsErrorUnableToAddPushRule
}

// Unable to remove push rule.
type NotificationSettingsErrorUnableToRemovePushRule struct {
}

// Unable to remove push rule.
func NewNotificationSettingsErrorUnableToRemovePushRule() *NotificationSettingsError {
	return &NotificationSettingsError{err: &NotificationSettingsErrorUnableToRemovePushRule{}}
}

func (e NotificationSettingsErrorUnableToRemovePushRule) destroy() {
}

func (err NotificationSettingsErrorUnableToRemovePushRule) Error() string {
	return fmt.Sprint("UnableToRemovePushRule")
}

func (self NotificationSettingsErrorUnableToRemovePushRule) Is(target error) bool {
	return target == ErrNotificationSettingsErrorUnableToRemovePushRule
}

// Unable to save the push rules
type NotificationSettingsErrorUnableToSavePushRules struct {
}

// Unable to save the push rules
func NewNotificationSettingsErrorUnableToSavePushRules() *NotificationSettingsError {
	return &NotificationSettingsError{err: &NotificationSettingsErrorUnableToSavePushRules{}}
}

func (e NotificationSettingsErrorUnableToSavePushRules) destroy() {
}

func (err NotificationSettingsErrorUnableToSavePushRules) Error() string {
	return fmt.Sprint("UnableToSavePushRules")
}

func (self NotificationSettingsErrorUnableToSavePushRules) Is(target error) bool {
	return target == ErrNotificationSettingsErrorUnableToSavePushRules
}

// Unable to update push rule.
type NotificationSettingsErrorUnableToUpdatePushRule struct {
}

// Unable to update push rule.
func NewNotificationSettingsErrorUnableToUpdatePushRule() *NotificationSettingsError {
	return &NotificationSettingsError{err: &NotificationSettingsErrorUnableToUpdatePushRule{}}
}

func (e NotificationSettingsErrorUnableToUpdatePushRule) destroy() {
}

func (err NotificationSettingsErrorUnableToUpdatePushRule) Error() string {
	return fmt.Sprint("UnableToUpdatePushRule")
}

func (self NotificationSettingsErrorUnableToUpdatePushRule) Is(target error) bool {
	return target == ErrNotificationSettingsErrorUnableToUpdatePushRule
}

type FfiConverterNotificationSettingsError struct{}

var FfiConverterNotificationSettingsErrorINSTANCE = FfiConverterNotificationSettingsError{}

func (c FfiConverterNotificationSettingsError) Lift(eb RustBufferI) *NotificationSettingsError {
	return LiftFromRustBuffer[*NotificationSettingsError](c, eb)
}

func (c FfiConverterNotificationSettingsError) Lower(value *NotificationSettingsError) C.RustBuffer {
	return LowerIntoRustBuffer[*NotificationSettingsError](c, value)
}

func (c FfiConverterNotificationSettingsError) Read(reader io.Reader) *NotificationSettingsError {
	errorID := readUint32(reader)

	switch errorID {
	case 1:
		return &NotificationSettingsError{&NotificationSettingsErrorGeneric{
			Msg: FfiConverterStringINSTANCE.Read(reader),
		}}
	case 2:
		return &NotificationSettingsError{&NotificationSettingsErrorInvalidParameter{
			Msg: FfiConverterStringINSTANCE.Read(reader),
		}}
	case 3:
		return &NotificationSettingsError{&NotificationSettingsErrorInvalidRoomId{
			RoomId: FfiConverterStringINSTANCE.Read(reader),
		}}
	case 4:
		return &NotificationSettingsError{&NotificationSettingsErrorRuleNotFound{
			RuleId: FfiConverterStringINSTANCE.Read(reader),
		}}
	case 5:
		return &NotificationSettingsError{&NotificationSettingsErrorUnableToAddPushRule{}}
	case 6:
		return &NotificationSettingsError{&NotificationSettingsErrorUnableToRemovePushRule{}}
	case 7:
		return &NotificationSettingsError{&NotificationSettingsErrorUnableToSavePushRules{}}
	case 8:
		return &NotificationSettingsError{&NotificationSettingsErrorUnableToUpdatePushRule{}}
	default:
		panic(fmt.Sprintf("Unknown error code %d in FfiConverterNotificationSettingsError.Read()", errorID))
	}
}

func (c FfiConverterNotificationSettingsError) Write(writer io.Writer, value *NotificationSettingsError) {
	switch variantValue := value.err.(type) {
	case *NotificationSettingsErrorGeneric:
		writeInt32(writer, 1)
		FfiConverterStringINSTANCE.Write(writer, variantValue.Msg)
	case *NotificationSettingsErrorInvalidParameter:
		writeInt32(writer, 2)
		FfiConverterStringINSTANCE.Write(writer, variantValue.Msg)
	case *NotificationSettingsErrorInvalidRoomId:
		writeInt32(writer, 3)
		FfiConverterStringINSTANCE.Write(writer, variantValue.RoomId)
	case *NotificationSettingsErrorRuleNotFound:
		writeInt32(writer, 4)
		FfiConverterStringINSTANCE.Write(writer, variantValue.RuleId)
	case *NotificationSettingsErrorUnableToAddPushRule:
		writeInt32(writer, 5)
	case *NotificationSettingsErrorUnableToRemovePushRule:
		writeInt32(writer, 6)
	case *NotificationSettingsErrorUnableToSavePushRules:
		writeInt32(writer, 7)
	case *NotificationSettingsErrorUnableToUpdatePushRule:
		writeInt32(writer, 8)
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiConverterNotificationSettingsError.Write", value))
	}
}

type FfiDestroyerNotificationSettingsError struct{}

func (_ FfiDestroyerNotificationSettingsError) Destroy(value *NotificationSettingsError) {
	switch variantValue := value.err.(type) {
	case NotificationSettingsErrorGeneric:
		variantValue.destroy()
	case NotificationSettingsErrorInvalidParameter:
		variantValue.destroy()
	case NotificationSettingsErrorInvalidRoomId:
		variantValue.destroy()
	case NotificationSettingsErrorRuleNotFound:
		variantValue.destroy()
	case NotificationSettingsErrorUnableToAddPushRule:
		variantValue.destroy()
	case NotificationSettingsErrorUnableToRemovePushRule:
		variantValue.destroy()
	case NotificationSettingsErrorUnableToSavePushRules:
		variantValue.destroy()
	case NotificationSettingsErrorUnableToUpdatePushRule:
		variantValue.destroy()
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiDestroyerNotificationSettingsError.Destroy", value))
	}
}

type NotifyType uint

const (
	NotifyTypeRing   NotifyType = 1
	NotifyTypeNotify NotifyType = 2
)

type FfiConverterNotifyType struct{}

var FfiConverterNotifyTypeINSTANCE = FfiConverterNotifyType{}

func (c FfiConverterNotifyType) Lift(rb RustBufferI) NotifyType {
	return LiftFromRustBuffer[NotifyType](c, rb)
}

func (c FfiConverterNotifyType) Lower(value NotifyType) C.RustBuffer {
	return LowerIntoRustBuffer[NotifyType](c, value)
}
func (FfiConverterNotifyType) Read(reader io.Reader) NotifyType {
	id := readInt32(reader)
	return NotifyType(id)
}

func (FfiConverterNotifyType) Write(writer io.Writer, value NotifyType) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerNotifyType struct{}

func (_ FfiDestroyerNotifyType) Destroy(value NotifyType) {
}

type OidcError struct {
	err error
}

// Convience method to turn *OidcError into error
// Avoiding treating nil pointer as non nil error interface
func (err *OidcError) AsError() error {
	if err == nil {
		return nil
	} else {
		return err
	}
}

func (err OidcError) Error() string {
	return fmt.Sprintf("OidcError: %s", err.err.Error())
}

func (err OidcError) Unwrap() error {
	return err.err
}

// Err* are used for checking error type with `errors.Is`
var ErrOidcErrorNotSupported = fmt.Errorf("OidcErrorNotSupported")
var ErrOidcErrorMetadataInvalid = fmt.Errorf("OidcErrorMetadataInvalid")
var ErrOidcErrorCallbackUrlInvalid = fmt.Errorf("OidcErrorCallbackUrlInvalid")
var ErrOidcErrorCancelled = fmt.Errorf("OidcErrorCancelled")
var ErrOidcErrorGeneric = fmt.Errorf("OidcErrorGeneric")

// Variant structs
type OidcErrorNotSupported struct {
	message string
}

func NewOidcErrorNotSupported() *OidcError {
	return &OidcError{err: &OidcErrorNotSupported{}}
}

func (e OidcErrorNotSupported) destroy() {
}

func (err OidcErrorNotSupported) Error() string {
	return fmt.Sprintf("NotSupported: %s", err.message)
}

func (self OidcErrorNotSupported) Is(target error) bool {
	return target == ErrOidcErrorNotSupported
}

type OidcErrorMetadataInvalid struct {
	message string
}

func NewOidcErrorMetadataInvalid() *OidcError {
	return &OidcError{err: &OidcErrorMetadataInvalid{}}
}

func (e OidcErrorMetadataInvalid) destroy() {
}

func (err OidcErrorMetadataInvalid) Error() string {
	return fmt.Sprintf("MetadataInvalid: %s", err.message)
}

func (self OidcErrorMetadataInvalid) Is(target error) bool {
	return target == ErrOidcErrorMetadataInvalid
}

type OidcErrorCallbackUrlInvalid struct {
	message string
}

func NewOidcErrorCallbackUrlInvalid() *OidcError {
	return &OidcError{err: &OidcErrorCallbackUrlInvalid{}}
}

func (e OidcErrorCallbackUrlInvalid) destroy() {
}

func (err OidcErrorCallbackUrlInvalid) Error() string {
	return fmt.Sprintf("CallbackUrlInvalid: %s", err.message)
}

func (self OidcErrorCallbackUrlInvalid) Is(target error) bool {
	return target == ErrOidcErrorCallbackUrlInvalid
}

type OidcErrorCancelled struct {
	message string
}

func NewOidcErrorCancelled() *OidcError {
	return &OidcError{err: &OidcErrorCancelled{}}
}

func (e OidcErrorCancelled) destroy() {
}

func (err OidcErrorCancelled) Error() string {
	return fmt.Sprintf("Cancelled: %s", err.message)
}

func (self OidcErrorCancelled) Is(target error) bool {
	return target == ErrOidcErrorCancelled
}

type OidcErrorGeneric struct {
	message string
}

func NewOidcErrorGeneric() *OidcError {
	return &OidcError{err: &OidcErrorGeneric{}}
}

func (e OidcErrorGeneric) destroy() {
}

func (err OidcErrorGeneric) Error() string {
	return fmt.Sprintf("Generic: %s", err.message)
}

func (self OidcErrorGeneric) Is(target error) bool {
	return target == ErrOidcErrorGeneric
}

type FfiConverterOidcError struct{}

var FfiConverterOidcErrorINSTANCE = FfiConverterOidcError{}

func (c FfiConverterOidcError) Lift(eb RustBufferI) *OidcError {
	return LiftFromRustBuffer[*OidcError](c, eb)
}

func (c FfiConverterOidcError) Lower(value *OidcError) C.RustBuffer {
	return LowerIntoRustBuffer[*OidcError](c, value)
}

func (c FfiConverterOidcError) Read(reader io.Reader) *OidcError {
	errorID := readUint32(reader)

	message := FfiConverterStringINSTANCE.Read(reader)
	switch errorID {
	case 1:
		return &OidcError{&OidcErrorNotSupported{message}}
	case 2:
		return &OidcError{&OidcErrorMetadataInvalid{message}}
	case 3:
		return &OidcError{&OidcErrorCallbackUrlInvalid{message}}
	case 4:
		return &OidcError{&OidcErrorCancelled{message}}
	case 5:
		return &OidcError{&OidcErrorGeneric{message}}
	default:
		panic(fmt.Sprintf("Unknown error code %d in FfiConverterOidcError.Read()", errorID))
	}

}

func (c FfiConverterOidcError) Write(writer io.Writer, value *OidcError) {
	switch variantValue := value.err.(type) {
	case *OidcErrorNotSupported:
		writeInt32(writer, 1)
	case *OidcErrorMetadataInvalid:
		writeInt32(writer, 2)
	case *OidcErrorCallbackUrlInvalid:
		writeInt32(writer, 3)
	case *OidcErrorCancelled:
		writeInt32(writer, 4)
	case *OidcErrorGeneric:
		writeInt32(writer, 5)
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiConverterOidcError.Write", value))
	}
}

type FfiDestroyerOidcError struct{}

func (_ FfiDestroyerOidcError) Destroy(value *OidcError) {
	switch variantValue := value.err.(type) {
	case OidcErrorNotSupported:
		variantValue.destroy()
	case OidcErrorMetadataInvalid:
		variantValue.destroy()
	case OidcErrorCallbackUrlInvalid:
		variantValue.destroy()
	case OidcErrorCancelled:
		variantValue.destroy()
	case OidcErrorGeneric:
		variantValue.destroy()
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiDestroyerOidcError.Destroy", value))
	}
}

type OidcPrompt interface {
	Destroy()
}

// The Authorization Server should prompt the End-User to create a user
// account.
//
// Defined in [Initiating User Registration via OpenID Connect](https://openid.net/specs/openid-connect-prompt-create-1_0.html).
type OidcPromptCreate struct {
}

func (e OidcPromptCreate) Destroy() {
}

// The Authorization Server should prompt the End-User for
// reauthentication.
type OidcPromptLogin struct {
}

func (e OidcPromptLogin) Destroy() {
}

// The Authorization Server should prompt the End-User for consent before
// returning information to the Client.
type OidcPromptConsent struct {
}

func (e OidcPromptConsent) Destroy() {
}

// An unknown value.
type OidcPromptUnknown struct {
	Value string
}

func (e OidcPromptUnknown) Destroy() {
	FfiDestroyerString{}.Destroy(e.Value)
}

type FfiConverterOidcPrompt struct{}

var FfiConverterOidcPromptINSTANCE = FfiConverterOidcPrompt{}

func (c FfiConverterOidcPrompt) Lift(rb RustBufferI) OidcPrompt {
	return LiftFromRustBuffer[OidcPrompt](c, rb)
}

func (c FfiConverterOidcPrompt) Lower(value OidcPrompt) C.RustBuffer {
	return LowerIntoRustBuffer[OidcPrompt](c, value)
}
func (FfiConverterOidcPrompt) Read(reader io.Reader) OidcPrompt {
	id := readInt32(reader)
	switch id {
	case 1:
		return OidcPromptCreate{}
	case 2:
		return OidcPromptLogin{}
	case 3:
		return OidcPromptConsent{}
	case 4:
		return OidcPromptUnknown{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterOidcPrompt.Read()", id))
	}
}

func (FfiConverterOidcPrompt) Write(writer io.Writer, value OidcPrompt) {
	switch variant_value := value.(type) {
	case OidcPromptCreate:
		writeInt32(writer, 1)
	case OidcPromptLogin:
		writeInt32(writer, 2)
	case OidcPromptConsent:
		writeInt32(writer, 3)
	case OidcPromptUnknown:
		writeInt32(writer, 4)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Value)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterOidcPrompt.Write", value))
	}
}

type FfiDestroyerOidcPrompt struct{}

func (_ FfiDestroyerOidcPrompt) Destroy(value OidcPrompt) {
	value.Destroy()
}

type OtherState interface {
	Destroy()
}
type OtherStatePolicyRuleRoom struct {
}

func (e OtherStatePolicyRuleRoom) Destroy() {
}

type OtherStatePolicyRuleServer struct {
}

func (e OtherStatePolicyRuleServer) Destroy() {
}

type OtherStatePolicyRuleUser struct {
}

func (e OtherStatePolicyRuleUser) Destroy() {
}

type OtherStateRoomAliases struct {
}

func (e OtherStateRoomAliases) Destroy() {
}

type OtherStateRoomAvatar struct {
	Url *string
}

func (e OtherStateRoomAvatar) Destroy() {
	FfiDestroyerOptionalString{}.Destroy(e.Url)
}

type OtherStateRoomCanonicalAlias struct {
}

func (e OtherStateRoomCanonicalAlias) Destroy() {
}

type OtherStateRoomCreate struct {
}

func (e OtherStateRoomCreate) Destroy() {
}

type OtherStateRoomEncryption struct {
}

func (e OtherStateRoomEncryption) Destroy() {
}

type OtherStateRoomGuestAccess struct {
}

func (e OtherStateRoomGuestAccess) Destroy() {
}

type OtherStateRoomHistoryVisibility struct {
}

func (e OtherStateRoomHistoryVisibility) Destroy() {
}

type OtherStateRoomJoinRules struct {
}

func (e OtherStateRoomJoinRules) Destroy() {
}

type OtherStateRoomName struct {
	Name *string
}

func (e OtherStateRoomName) Destroy() {
	FfiDestroyerOptionalString{}.Destroy(e.Name)
}

type OtherStateRoomPinnedEvents struct {
	Change matrix_sdk_ui.RoomPinnedEventsChange
}

func (e OtherStateRoomPinnedEvents) Destroy() {
	matrix_sdk_ui.FfiDestroyerRoomPinnedEventsChange{}.Destroy(e.Change)
}

type OtherStateRoomPowerLevels struct {
	Users    map[string]int64
	Previous *map[string]int64
}

func (e OtherStateRoomPowerLevels) Destroy() {
	FfiDestroyerMapStringInt64{}.Destroy(e.Users)
	FfiDestroyerOptionalMapStringInt64{}.Destroy(e.Previous)
}

type OtherStateRoomServerAcl struct {
}

func (e OtherStateRoomServerAcl) Destroy() {
}

type OtherStateRoomThirdPartyInvite struct {
	DisplayName *string
}

func (e OtherStateRoomThirdPartyInvite) Destroy() {
	FfiDestroyerOptionalString{}.Destroy(e.DisplayName)
}

type OtherStateRoomTombstone struct {
}

func (e OtherStateRoomTombstone) Destroy() {
}

type OtherStateRoomTopic struct {
	Topic *string
}

func (e OtherStateRoomTopic) Destroy() {
	FfiDestroyerOptionalString{}.Destroy(e.Topic)
}

type OtherStateSpaceChild struct {
}

func (e OtherStateSpaceChild) Destroy() {
}

type OtherStateSpaceParent struct {
}

func (e OtherStateSpaceParent) Destroy() {
}

type OtherStateCustom struct {
	EventType string
}

func (e OtherStateCustom) Destroy() {
	FfiDestroyerString{}.Destroy(e.EventType)
}

type FfiConverterOtherState struct{}

var FfiConverterOtherStateINSTANCE = FfiConverterOtherState{}

func (c FfiConverterOtherState) Lift(rb RustBufferI) OtherState {
	return LiftFromRustBuffer[OtherState](c, rb)
}

func (c FfiConverterOtherState) Lower(value OtherState) C.RustBuffer {
	return LowerIntoRustBuffer[OtherState](c, value)
}
func (FfiConverterOtherState) Read(reader io.Reader) OtherState {
	id := readInt32(reader)
	switch id {
	case 1:
		return OtherStatePolicyRuleRoom{}
	case 2:
		return OtherStatePolicyRuleServer{}
	case 3:
		return OtherStatePolicyRuleUser{}
	case 4:
		return OtherStateRoomAliases{}
	case 5:
		return OtherStateRoomAvatar{
			FfiConverterOptionalStringINSTANCE.Read(reader),
		}
	case 6:
		return OtherStateRoomCanonicalAlias{}
	case 7:
		return OtherStateRoomCreate{}
	case 8:
		return OtherStateRoomEncryption{}
	case 9:
		return OtherStateRoomGuestAccess{}
	case 10:
		return OtherStateRoomHistoryVisibility{}
	case 11:
		return OtherStateRoomJoinRules{}
	case 12:
		return OtherStateRoomName{
			FfiConverterOptionalStringINSTANCE.Read(reader),
		}
	case 13:
		return OtherStateRoomPinnedEvents{
			matrix_sdk_ui.FfiConverterRoomPinnedEventsChangeINSTANCE.Read(reader),
		}
	case 14:
		return OtherStateRoomPowerLevels{
			FfiConverterMapStringInt64INSTANCE.Read(reader),
			FfiConverterOptionalMapStringInt64INSTANCE.Read(reader),
		}
	case 15:
		return OtherStateRoomServerAcl{}
	case 16:
		return OtherStateRoomThirdPartyInvite{
			FfiConverterOptionalStringINSTANCE.Read(reader),
		}
	case 17:
		return OtherStateRoomTombstone{}
	case 18:
		return OtherStateRoomTopic{
			FfiConverterOptionalStringINSTANCE.Read(reader),
		}
	case 19:
		return OtherStateSpaceChild{}
	case 20:
		return OtherStateSpaceParent{}
	case 21:
		return OtherStateCustom{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterOtherState.Read()", id))
	}
}

func (FfiConverterOtherState) Write(writer io.Writer, value OtherState) {
	switch variant_value := value.(type) {
	case OtherStatePolicyRuleRoom:
		writeInt32(writer, 1)
	case OtherStatePolicyRuleServer:
		writeInt32(writer, 2)
	case OtherStatePolicyRuleUser:
		writeInt32(writer, 3)
	case OtherStateRoomAliases:
		writeInt32(writer, 4)
	case OtherStateRoomAvatar:
		writeInt32(writer, 5)
		FfiConverterOptionalStringINSTANCE.Write(writer, variant_value.Url)
	case OtherStateRoomCanonicalAlias:
		writeInt32(writer, 6)
	case OtherStateRoomCreate:
		writeInt32(writer, 7)
	case OtherStateRoomEncryption:
		writeInt32(writer, 8)
	case OtherStateRoomGuestAccess:
		writeInt32(writer, 9)
	case OtherStateRoomHistoryVisibility:
		writeInt32(writer, 10)
	case OtherStateRoomJoinRules:
		writeInt32(writer, 11)
	case OtherStateRoomName:
		writeInt32(writer, 12)
		FfiConverterOptionalStringINSTANCE.Write(writer, variant_value.Name)
	case OtherStateRoomPinnedEvents:
		writeInt32(writer, 13)
		matrix_sdk_ui.FfiConverterRoomPinnedEventsChangeINSTANCE.Write(writer, variant_value.Change)
	case OtherStateRoomPowerLevels:
		writeInt32(writer, 14)
		FfiConverterMapStringInt64INSTANCE.Write(writer, variant_value.Users)
		FfiConverterOptionalMapStringInt64INSTANCE.Write(writer, variant_value.Previous)
	case OtherStateRoomServerAcl:
		writeInt32(writer, 15)
	case OtherStateRoomThirdPartyInvite:
		writeInt32(writer, 16)
		FfiConverterOptionalStringINSTANCE.Write(writer, variant_value.DisplayName)
	case OtherStateRoomTombstone:
		writeInt32(writer, 17)
	case OtherStateRoomTopic:
		writeInt32(writer, 18)
		FfiConverterOptionalStringINSTANCE.Write(writer, variant_value.Topic)
	case OtherStateSpaceChild:
		writeInt32(writer, 19)
	case OtherStateSpaceParent:
		writeInt32(writer, 20)
	case OtherStateCustom:
		writeInt32(writer, 21)
		FfiConverterStringINSTANCE.Write(writer, variant_value.EventType)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterOtherState.Write", value))
	}
}

type FfiDestroyerOtherState struct{}

func (_ FfiDestroyerOtherState) Destroy(value OtherState) {
	value.Destroy()
}

type ParseError struct {
	err error
}

// Convience method to turn *ParseError into error
// Avoiding treating nil pointer as non nil error interface
func (err *ParseError) AsError() error {
	if err == nil {
		return nil
	} else {
		return err
	}
}

func (err ParseError) Error() string {
	return fmt.Sprintf("ParseError: %s", err.err.Error())
}

func (err ParseError) Unwrap() error {
	return err.err
}

// Err* are used for checking error type with `errors.Is`
var ErrParseErrorEmptyHost = fmt.Errorf("ParseErrorEmptyHost")
var ErrParseErrorIdnaError = fmt.Errorf("ParseErrorIdnaError")
var ErrParseErrorInvalidPort = fmt.Errorf("ParseErrorInvalidPort")
var ErrParseErrorInvalidIpv4Address = fmt.Errorf("ParseErrorInvalidIpv4Address")
var ErrParseErrorInvalidIpv6Address = fmt.Errorf("ParseErrorInvalidIpv6Address")
var ErrParseErrorInvalidDomainCharacter = fmt.Errorf("ParseErrorInvalidDomainCharacter")
var ErrParseErrorRelativeUrlWithoutBase = fmt.Errorf("ParseErrorRelativeUrlWithoutBase")
var ErrParseErrorRelativeUrlWithCannotBeABaseBase = fmt.Errorf("ParseErrorRelativeUrlWithCannotBeABaseBase")
var ErrParseErrorSetHostOnCannotBeABaseUrl = fmt.Errorf("ParseErrorSetHostOnCannotBeABaseUrl")
var ErrParseErrorOverflow = fmt.Errorf("ParseErrorOverflow")
var ErrParseErrorOther = fmt.Errorf("ParseErrorOther")

// Variant structs
type ParseErrorEmptyHost struct {
	message string
}

func NewParseErrorEmptyHost() *ParseError {
	return &ParseError{err: &ParseErrorEmptyHost{}}
}

func (e ParseErrorEmptyHost) destroy() {
}

func (err ParseErrorEmptyHost) Error() string {
	return fmt.Sprintf("EmptyHost: %s", err.message)
}

func (self ParseErrorEmptyHost) Is(target error) bool {
	return target == ErrParseErrorEmptyHost
}

type ParseErrorIdnaError struct {
	message string
}

func NewParseErrorIdnaError() *ParseError {
	return &ParseError{err: &ParseErrorIdnaError{}}
}

func (e ParseErrorIdnaError) destroy() {
}

func (err ParseErrorIdnaError) Error() string {
	return fmt.Sprintf("IdnaError: %s", err.message)
}

func (self ParseErrorIdnaError) Is(target error) bool {
	return target == ErrParseErrorIdnaError
}

type ParseErrorInvalidPort struct {
	message string
}

func NewParseErrorInvalidPort() *ParseError {
	return &ParseError{err: &ParseErrorInvalidPort{}}
}

func (e ParseErrorInvalidPort) destroy() {
}

func (err ParseErrorInvalidPort) Error() string {
	return fmt.Sprintf("InvalidPort: %s", err.message)
}

func (self ParseErrorInvalidPort) Is(target error) bool {
	return target == ErrParseErrorInvalidPort
}

type ParseErrorInvalidIpv4Address struct {
	message string
}

func NewParseErrorInvalidIpv4Address() *ParseError {
	return &ParseError{err: &ParseErrorInvalidIpv4Address{}}
}

func (e ParseErrorInvalidIpv4Address) destroy() {
}

func (err ParseErrorInvalidIpv4Address) Error() string {
	return fmt.Sprintf("InvalidIpv4Address: %s", err.message)
}

func (self ParseErrorInvalidIpv4Address) Is(target error) bool {
	return target == ErrParseErrorInvalidIpv4Address
}

type ParseErrorInvalidIpv6Address struct {
	message string
}

func NewParseErrorInvalidIpv6Address() *ParseError {
	return &ParseError{err: &ParseErrorInvalidIpv6Address{}}
}

func (e ParseErrorInvalidIpv6Address) destroy() {
}

func (err ParseErrorInvalidIpv6Address) Error() string {
	return fmt.Sprintf("InvalidIpv6Address: %s", err.message)
}

func (self ParseErrorInvalidIpv6Address) Is(target error) bool {
	return target == ErrParseErrorInvalidIpv6Address
}

type ParseErrorInvalidDomainCharacter struct {
	message string
}

func NewParseErrorInvalidDomainCharacter() *ParseError {
	return &ParseError{err: &ParseErrorInvalidDomainCharacter{}}
}

func (e ParseErrorInvalidDomainCharacter) destroy() {
}

func (err ParseErrorInvalidDomainCharacter) Error() string {
	return fmt.Sprintf("InvalidDomainCharacter: %s", err.message)
}

func (self ParseErrorInvalidDomainCharacter) Is(target error) bool {
	return target == ErrParseErrorInvalidDomainCharacter
}

type ParseErrorRelativeUrlWithoutBase struct {
	message string
}

func NewParseErrorRelativeUrlWithoutBase() *ParseError {
	return &ParseError{err: &ParseErrorRelativeUrlWithoutBase{}}
}

func (e ParseErrorRelativeUrlWithoutBase) destroy() {
}

func (err ParseErrorRelativeUrlWithoutBase) Error() string {
	return fmt.Sprintf("RelativeUrlWithoutBase: %s", err.message)
}

func (self ParseErrorRelativeUrlWithoutBase) Is(target error) bool {
	return target == ErrParseErrorRelativeUrlWithoutBase
}

type ParseErrorRelativeUrlWithCannotBeABaseBase struct {
	message string
}

func NewParseErrorRelativeUrlWithCannotBeABaseBase() *ParseError {
	return &ParseError{err: &ParseErrorRelativeUrlWithCannotBeABaseBase{}}
}

func (e ParseErrorRelativeUrlWithCannotBeABaseBase) destroy() {
}

func (err ParseErrorRelativeUrlWithCannotBeABaseBase) Error() string {
	return fmt.Sprintf("RelativeUrlWithCannotBeABaseBase: %s", err.message)
}

func (self ParseErrorRelativeUrlWithCannotBeABaseBase) Is(target error) bool {
	return target == ErrParseErrorRelativeUrlWithCannotBeABaseBase
}

type ParseErrorSetHostOnCannotBeABaseUrl struct {
	message string
}

func NewParseErrorSetHostOnCannotBeABaseUrl() *ParseError {
	return &ParseError{err: &ParseErrorSetHostOnCannotBeABaseUrl{}}
}

func (e ParseErrorSetHostOnCannotBeABaseUrl) destroy() {
}

func (err ParseErrorSetHostOnCannotBeABaseUrl) Error() string {
	return fmt.Sprintf("SetHostOnCannotBeABaseUrl: %s", err.message)
}

func (self ParseErrorSetHostOnCannotBeABaseUrl) Is(target error) bool {
	return target == ErrParseErrorSetHostOnCannotBeABaseUrl
}

type ParseErrorOverflow struct {
	message string
}

func NewParseErrorOverflow() *ParseError {
	return &ParseError{err: &ParseErrorOverflow{}}
}

func (e ParseErrorOverflow) destroy() {
}

func (err ParseErrorOverflow) Error() string {
	return fmt.Sprintf("Overflow: %s", err.message)
}

func (self ParseErrorOverflow) Is(target error) bool {
	return target == ErrParseErrorOverflow
}

type ParseErrorOther struct {
	message string
}

func NewParseErrorOther() *ParseError {
	return &ParseError{err: &ParseErrorOther{}}
}

func (e ParseErrorOther) destroy() {
}

func (err ParseErrorOther) Error() string {
	return fmt.Sprintf("Other: %s", err.message)
}

func (self ParseErrorOther) Is(target error) bool {
	return target == ErrParseErrorOther
}

type FfiConverterParseError struct{}

var FfiConverterParseErrorINSTANCE = FfiConverterParseError{}

func (c FfiConverterParseError) Lift(eb RustBufferI) *ParseError {
	return LiftFromRustBuffer[*ParseError](c, eb)
}

func (c FfiConverterParseError) Lower(value *ParseError) C.RustBuffer {
	return LowerIntoRustBuffer[*ParseError](c, value)
}

func (c FfiConverterParseError) Read(reader io.Reader) *ParseError {
	errorID := readUint32(reader)

	message := FfiConverterStringINSTANCE.Read(reader)
	switch errorID {
	case 1:
		return &ParseError{&ParseErrorEmptyHost{message}}
	case 2:
		return &ParseError{&ParseErrorIdnaError{message}}
	case 3:
		return &ParseError{&ParseErrorInvalidPort{message}}
	case 4:
		return &ParseError{&ParseErrorInvalidIpv4Address{message}}
	case 5:
		return &ParseError{&ParseErrorInvalidIpv6Address{message}}
	case 6:
		return &ParseError{&ParseErrorInvalidDomainCharacter{message}}
	case 7:
		return &ParseError{&ParseErrorRelativeUrlWithoutBase{message}}
	case 8:
		return &ParseError{&ParseErrorRelativeUrlWithCannotBeABaseBase{message}}
	case 9:
		return &ParseError{&ParseErrorSetHostOnCannotBeABaseUrl{message}}
	case 10:
		return &ParseError{&ParseErrorOverflow{message}}
	case 11:
		return &ParseError{&ParseErrorOther{message}}
	default:
		panic(fmt.Sprintf("Unknown error code %d in FfiConverterParseError.Read()", errorID))
	}

}

func (c FfiConverterParseError) Write(writer io.Writer, value *ParseError) {
	switch variantValue := value.err.(type) {
	case *ParseErrorEmptyHost:
		writeInt32(writer, 1)
	case *ParseErrorIdnaError:
		writeInt32(writer, 2)
	case *ParseErrorInvalidPort:
		writeInt32(writer, 3)
	case *ParseErrorInvalidIpv4Address:
		writeInt32(writer, 4)
	case *ParseErrorInvalidIpv6Address:
		writeInt32(writer, 5)
	case *ParseErrorInvalidDomainCharacter:
		writeInt32(writer, 6)
	case *ParseErrorRelativeUrlWithoutBase:
		writeInt32(writer, 7)
	case *ParseErrorRelativeUrlWithCannotBeABaseBase:
		writeInt32(writer, 8)
	case *ParseErrorSetHostOnCannotBeABaseUrl:
		writeInt32(writer, 9)
	case *ParseErrorOverflow:
		writeInt32(writer, 10)
	case *ParseErrorOther:
		writeInt32(writer, 11)
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiConverterParseError.Write", value))
	}
}

type FfiDestroyerParseError struct{}

func (_ FfiDestroyerParseError) Destroy(value *ParseError) {
	switch variantValue := value.err.(type) {
	case ParseErrorEmptyHost:
		variantValue.destroy()
	case ParseErrorIdnaError:
		variantValue.destroy()
	case ParseErrorInvalidPort:
		variantValue.destroy()
	case ParseErrorInvalidIpv4Address:
		variantValue.destroy()
	case ParseErrorInvalidIpv6Address:
		variantValue.destroy()
	case ParseErrorInvalidDomainCharacter:
		variantValue.destroy()
	case ParseErrorRelativeUrlWithoutBase:
		variantValue.destroy()
	case ParseErrorRelativeUrlWithCannotBeABaseBase:
		variantValue.destroy()
	case ParseErrorSetHostOnCannotBeABaseUrl:
		variantValue.destroy()
	case ParseErrorOverflow:
		variantValue.destroy()
	case ParseErrorOther:
		variantValue.destroy()
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiDestroyerParseError.Destroy", value))
	}
}

type PollKind uint

const (
	PollKindDisclosed   PollKind = 1
	PollKindUndisclosed PollKind = 2
)

type FfiConverterPollKind struct{}

var FfiConverterPollKindINSTANCE = FfiConverterPollKind{}

func (c FfiConverterPollKind) Lift(rb RustBufferI) PollKind {
	return LiftFromRustBuffer[PollKind](c, rb)
}

func (c FfiConverterPollKind) Lower(value PollKind) C.RustBuffer {
	return LowerIntoRustBuffer[PollKind](c, value)
}
func (FfiConverterPollKind) Read(reader io.Reader) PollKind {
	id := readInt32(reader)
	return PollKind(id)
}

func (FfiConverterPollKind) Write(writer io.Writer, value PollKind) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerPollKind struct{}

func (_ FfiDestroyerPollKind) Destroy(value PollKind) {
}

type ProfileDetails interface {
	Destroy()
}
type ProfileDetailsUnavailable struct {
}

func (e ProfileDetailsUnavailable) Destroy() {
}

type ProfileDetailsPending struct {
}

func (e ProfileDetailsPending) Destroy() {
}

type ProfileDetailsReady struct {
	DisplayName          *string
	DisplayNameAmbiguous bool
	AvatarUrl            *string
}

func (e ProfileDetailsReady) Destroy() {
	FfiDestroyerOptionalString{}.Destroy(e.DisplayName)
	FfiDestroyerBool{}.Destroy(e.DisplayNameAmbiguous)
	FfiDestroyerOptionalString{}.Destroy(e.AvatarUrl)
}

type ProfileDetailsError struct {
	Message string
}

func (e ProfileDetailsError) Destroy() {
	FfiDestroyerString{}.Destroy(e.Message)
}

type FfiConverterProfileDetails struct{}

var FfiConverterProfileDetailsINSTANCE = FfiConverterProfileDetails{}

func (c FfiConverterProfileDetails) Lift(rb RustBufferI) ProfileDetails {
	return LiftFromRustBuffer[ProfileDetails](c, rb)
}

func (c FfiConverterProfileDetails) Lower(value ProfileDetails) C.RustBuffer {
	return LowerIntoRustBuffer[ProfileDetails](c, value)
}
func (FfiConverterProfileDetails) Read(reader io.Reader) ProfileDetails {
	id := readInt32(reader)
	switch id {
	case 1:
		return ProfileDetailsUnavailable{}
	case 2:
		return ProfileDetailsPending{}
	case 3:
		return ProfileDetailsReady{
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterBoolINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
		}
	case 4:
		return ProfileDetailsError{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterProfileDetails.Read()", id))
	}
}

func (FfiConverterProfileDetails) Write(writer io.Writer, value ProfileDetails) {
	switch variant_value := value.(type) {
	case ProfileDetailsUnavailable:
		writeInt32(writer, 1)
	case ProfileDetailsPending:
		writeInt32(writer, 2)
	case ProfileDetailsReady:
		writeInt32(writer, 3)
		FfiConverterOptionalStringINSTANCE.Write(writer, variant_value.DisplayName)
		FfiConverterBoolINSTANCE.Write(writer, variant_value.DisplayNameAmbiguous)
		FfiConverterOptionalStringINSTANCE.Write(writer, variant_value.AvatarUrl)
	case ProfileDetailsError:
		writeInt32(writer, 4)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Message)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterProfileDetails.Write", value))
	}
}

type FfiDestroyerProfileDetails struct{}

func (_ FfiDestroyerProfileDetails) Destroy(value ProfileDetails) {
	value.Destroy()
}

type PublicRoomJoinRule uint

const (
	PublicRoomJoinRulePublic PublicRoomJoinRule = 1
	PublicRoomJoinRuleKnock  PublicRoomJoinRule = 2
)

type FfiConverterPublicRoomJoinRule struct{}

var FfiConverterPublicRoomJoinRuleINSTANCE = FfiConverterPublicRoomJoinRule{}

func (c FfiConverterPublicRoomJoinRule) Lift(rb RustBufferI) PublicRoomJoinRule {
	return LiftFromRustBuffer[PublicRoomJoinRule](c, rb)
}

func (c FfiConverterPublicRoomJoinRule) Lower(value PublicRoomJoinRule) C.RustBuffer {
	return LowerIntoRustBuffer[PublicRoomJoinRule](c, value)
}
func (FfiConverterPublicRoomJoinRule) Read(reader io.Reader) PublicRoomJoinRule {
	id := readInt32(reader)
	return PublicRoomJoinRule(id)
}

func (FfiConverterPublicRoomJoinRule) Write(writer io.Writer, value PublicRoomJoinRule) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerPublicRoomJoinRule struct{}

func (_ FfiDestroyerPublicRoomJoinRule) Destroy(value PublicRoomJoinRule) {
}

type PushCondition interface {
	Destroy()
}

// A glob pattern match on a field of the event.
type PushConditionEventMatch struct {
	Key     string
	Pattern string
}

func (e PushConditionEventMatch) Destroy() {
	FfiDestroyerString{}.Destroy(e.Key)
	FfiDestroyerString{}.Destroy(e.Pattern)
}

// Matches unencrypted messages where `content.body` contains the owner's
// display name in that room.
type PushConditionContainsDisplayName struct {
}

func (e PushConditionContainsDisplayName) Destroy() {
}

// Matches the current number of members in the room.
type PushConditionRoomMemberCount struct {
	Prefix ComparisonOperator
	Count  uint64
}

func (e PushConditionRoomMemberCount) Destroy() {
	FfiDestroyerComparisonOperator{}.Destroy(e.Prefix)
	FfiDestroyerUint64{}.Destroy(e.Count)
}

// Takes into account the current power levels in the room, ensuring the
// sender of the event has high enough power to trigger the
// notification.
type PushConditionSenderNotificationPermission struct {
	Key string
}

func (e PushConditionSenderNotificationPermission) Destroy() {
	FfiDestroyerString{}.Destroy(e.Key)
}

// Exact value match on a property of the event.
type PushConditionEventPropertyIs struct {
	Key   string
	Value JsonValue
}

func (e PushConditionEventPropertyIs) Destroy() {
	FfiDestroyerString{}.Destroy(e.Key)
	FfiDestroyerJsonValue{}.Destroy(e.Value)
}

// Exact value match on a value in an array property of the event.
type PushConditionEventPropertyContains struct {
	Key   string
	Value JsonValue
}

func (e PushConditionEventPropertyContains) Destroy() {
	FfiDestroyerString{}.Destroy(e.Key)
	FfiDestroyerJsonValue{}.Destroy(e.Value)
}

type FfiConverterPushCondition struct{}

var FfiConverterPushConditionINSTANCE = FfiConverterPushCondition{}

func (c FfiConverterPushCondition) Lift(rb RustBufferI) PushCondition {
	return LiftFromRustBuffer[PushCondition](c, rb)
}

func (c FfiConverterPushCondition) Lower(value PushCondition) C.RustBuffer {
	return LowerIntoRustBuffer[PushCondition](c, value)
}
func (FfiConverterPushCondition) Read(reader io.Reader) PushCondition {
	id := readInt32(reader)
	switch id {
	case 1:
		return PushConditionEventMatch{
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 2:
		return PushConditionContainsDisplayName{}
	case 3:
		return PushConditionRoomMemberCount{
			FfiConverterComparisonOperatorINSTANCE.Read(reader),
			FfiConverterUint64INSTANCE.Read(reader),
		}
	case 4:
		return PushConditionSenderNotificationPermission{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 5:
		return PushConditionEventPropertyIs{
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterJsonValueINSTANCE.Read(reader),
		}
	case 6:
		return PushConditionEventPropertyContains{
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterJsonValueINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterPushCondition.Read()", id))
	}
}

func (FfiConverterPushCondition) Write(writer io.Writer, value PushCondition) {
	switch variant_value := value.(type) {
	case PushConditionEventMatch:
		writeInt32(writer, 1)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Key)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Pattern)
	case PushConditionContainsDisplayName:
		writeInt32(writer, 2)
	case PushConditionRoomMemberCount:
		writeInt32(writer, 3)
		FfiConverterComparisonOperatorINSTANCE.Write(writer, variant_value.Prefix)
		FfiConverterUint64INSTANCE.Write(writer, variant_value.Count)
	case PushConditionSenderNotificationPermission:
		writeInt32(writer, 4)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Key)
	case PushConditionEventPropertyIs:
		writeInt32(writer, 5)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Key)
		FfiConverterJsonValueINSTANCE.Write(writer, variant_value.Value)
	case PushConditionEventPropertyContains:
		writeInt32(writer, 6)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Key)
		FfiConverterJsonValueINSTANCE.Write(writer, variant_value.Value)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterPushCondition.Write", value))
	}
}

type FfiDestroyerPushCondition struct{}

func (_ FfiDestroyerPushCondition) Destroy(value PushCondition) {
	value.Destroy()
}

type PushFormat uint

const (
	PushFormatEventIdOnly PushFormat = 1
)

type FfiConverterPushFormat struct{}

var FfiConverterPushFormatINSTANCE = FfiConverterPushFormat{}

func (c FfiConverterPushFormat) Lift(rb RustBufferI) PushFormat {
	return LiftFromRustBuffer[PushFormat](c, rb)
}

func (c FfiConverterPushFormat) Lower(value PushFormat) C.RustBuffer {
	return LowerIntoRustBuffer[PushFormat](c, value)
}
func (FfiConverterPushFormat) Read(reader io.Reader) PushFormat {
	id := readInt32(reader)
	return PushFormat(id)
}

func (FfiConverterPushFormat) Write(writer io.Writer, value PushFormat) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerPushFormat struct{}

func (_ FfiDestroyerPushFormat) Destroy(value PushFormat) {
}

type PusherKind interface {
	Destroy()
}
type PusherKindHttp struct {
	Data HttpPusherData
}

func (e PusherKindHttp) Destroy() {
	FfiDestroyerHttpPusherData{}.Destroy(e.Data)
}

type PusherKindEmail struct {
}

func (e PusherKindEmail) Destroy() {
}

type FfiConverterPusherKind struct{}

var FfiConverterPusherKindINSTANCE = FfiConverterPusherKind{}

func (c FfiConverterPusherKind) Lift(rb RustBufferI) PusherKind {
	return LiftFromRustBuffer[PusherKind](c, rb)
}

func (c FfiConverterPusherKind) Lower(value PusherKind) C.RustBuffer {
	return LowerIntoRustBuffer[PusherKind](c, value)
}
func (FfiConverterPusherKind) Read(reader io.Reader) PusherKind {
	id := readInt32(reader)
	switch id {
	case 1:
		return PusherKindHttp{
			FfiConverterHttpPusherDataINSTANCE.Read(reader),
		}
	case 2:
		return PusherKindEmail{}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterPusherKind.Read()", id))
	}
}

func (FfiConverterPusherKind) Write(writer io.Writer, value PusherKind) {
	switch variant_value := value.(type) {
	case PusherKindHttp:
		writeInt32(writer, 1)
		FfiConverterHttpPusherDataINSTANCE.Write(writer, variant_value.Data)
	case PusherKindEmail:
		writeInt32(writer, 2)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterPusherKind.Write", value))
	}
}

type FfiDestroyerPusherKind struct{}

func (_ FfiDestroyerPusherKind) Destroy(value PusherKind) {
	value.Destroy()
}

// Error type for the decoding of the [`QrCodeData`].
type QrCodeDecodeError struct {
	err error
}

// Convience method to turn *QrCodeDecodeError into error
// Avoiding treating nil pointer as non nil error interface
func (err *QrCodeDecodeError) AsError() error {
	if err == nil {
		return nil
	} else {
		return err
	}
}

func (err QrCodeDecodeError) Error() string {
	return fmt.Sprintf("QrCodeDecodeError: %s", err.err.Error())
}

func (err QrCodeDecodeError) Unwrap() error {
	return err.err
}

// Err* are used for checking error type with `errors.Is`
var ErrQrCodeDecodeErrorCrypto = fmt.Errorf("QrCodeDecodeErrorCrypto")

// Variant structs
type QrCodeDecodeErrorCrypto struct {
	message string
}

func NewQrCodeDecodeErrorCrypto() *QrCodeDecodeError {
	return &QrCodeDecodeError{err: &QrCodeDecodeErrorCrypto{}}
}

func (e QrCodeDecodeErrorCrypto) destroy() {
}

func (err QrCodeDecodeErrorCrypto) Error() string {
	return fmt.Sprintf("Crypto: %s", err.message)
}

func (self QrCodeDecodeErrorCrypto) Is(target error) bool {
	return target == ErrQrCodeDecodeErrorCrypto
}

type FfiConverterQrCodeDecodeError struct{}

var FfiConverterQrCodeDecodeErrorINSTANCE = FfiConverterQrCodeDecodeError{}

func (c FfiConverterQrCodeDecodeError) Lift(eb RustBufferI) *QrCodeDecodeError {
	return LiftFromRustBuffer[*QrCodeDecodeError](c, eb)
}

func (c FfiConverterQrCodeDecodeError) Lower(value *QrCodeDecodeError) C.RustBuffer {
	return LowerIntoRustBuffer[*QrCodeDecodeError](c, value)
}

func (c FfiConverterQrCodeDecodeError) Read(reader io.Reader) *QrCodeDecodeError {
	errorID := readUint32(reader)

	message := FfiConverterStringINSTANCE.Read(reader)
	switch errorID {
	case 1:
		return &QrCodeDecodeError{&QrCodeDecodeErrorCrypto{message}}
	default:
		panic(fmt.Sprintf("Unknown error code %d in FfiConverterQrCodeDecodeError.Read()", errorID))
	}

}

func (c FfiConverterQrCodeDecodeError) Write(writer io.Writer, value *QrCodeDecodeError) {
	switch variantValue := value.err.(type) {
	case *QrCodeDecodeErrorCrypto:
		writeInt32(writer, 1)
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiConverterQrCodeDecodeError.Write", value))
	}
}

type FfiDestroyerQrCodeDecodeError struct{}

func (_ FfiDestroyerQrCodeDecodeError) Destroy(value *QrCodeDecodeError) {
	switch variantValue := value.err.(type) {
	case QrCodeDecodeErrorCrypto:
		variantValue.destroy()
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiDestroyerQrCodeDecodeError.Destroy", value))
	}
}

// Enum describing the progress of the QR-code login.
type QrLoginProgress interface {
	Destroy()
}

// The login process is starting.
type QrLoginProgressStarting struct {
}

func (e QrLoginProgressStarting) Destroy() {
}

// We established a secure channel with the other device.
type QrLoginProgressEstablishingSecureChannel struct {
	CheckCode       uint8
	CheckCodeString string
}

func (e QrLoginProgressEstablishingSecureChannel) Destroy() {
	FfiDestroyerUint8{}.Destroy(e.CheckCode)
	FfiDestroyerString{}.Destroy(e.CheckCodeString)
}

// We are waiting for the login and for the OAuth 2.0 authorization server
// to give us an access token.
type QrLoginProgressWaitingForToken struct {
	UserCode string
}

func (e QrLoginProgressWaitingForToken) Destroy() {
	FfiDestroyerString{}.Destroy(e.UserCode)
}

// The login has successfully finished.
type QrLoginProgressDone struct {
}

func (e QrLoginProgressDone) Destroy() {
}

type FfiConverterQrLoginProgress struct{}

var FfiConverterQrLoginProgressINSTANCE = FfiConverterQrLoginProgress{}

func (c FfiConverterQrLoginProgress) Lift(rb RustBufferI) QrLoginProgress {
	return LiftFromRustBuffer[QrLoginProgress](c, rb)
}

func (c FfiConverterQrLoginProgress) Lower(value QrLoginProgress) C.RustBuffer {
	return LowerIntoRustBuffer[QrLoginProgress](c, value)
}
func (FfiConverterQrLoginProgress) Read(reader io.Reader) QrLoginProgress {
	id := readInt32(reader)
	switch id {
	case 1:
		return QrLoginProgressStarting{}
	case 2:
		return QrLoginProgressEstablishingSecureChannel{
			FfiConverterUint8INSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 3:
		return QrLoginProgressWaitingForToken{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 4:
		return QrLoginProgressDone{}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterQrLoginProgress.Read()", id))
	}
}

func (FfiConverterQrLoginProgress) Write(writer io.Writer, value QrLoginProgress) {
	switch variant_value := value.(type) {
	case QrLoginProgressStarting:
		writeInt32(writer, 1)
	case QrLoginProgressEstablishingSecureChannel:
		writeInt32(writer, 2)
		FfiConverterUint8INSTANCE.Write(writer, variant_value.CheckCode)
		FfiConverterStringINSTANCE.Write(writer, variant_value.CheckCodeString)
	case QrLoginProgressWaitingForToken:
		writeInt32(writer, 3)
		FfiConverterStringINSTANCE.Write(writer, variant_value.UserCode)
	case QrLoginProgressDone:
		writeInt32(writer, 4)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterQrLoginProgress.Write", value))
	}
}

type FfiDestroyerQrLoginProgress struct{}

func (_ FfiDestroyerQrLoginProgress) Destroy(value QrLoginProgress) {
	value.Destroy()
}

// Bindings version of the sdk type replacing OwnedUserId/DeviceIds with simple
// String.
//
// Represent a failed to send unrecoverable error of an event sent via the
// send_queue. It is a serializable representation of a client error, see
// `From` implementation for more details. These errors can not be
// automatically retried, but yet some manual action can be taken before retry
// sending. If not the only solution is to delete the local event.
type QueueWedgeError interface {
	Destroy()
}

// This error occurs when there are some insecure devices in the room, and
// the current encryption setting prohibit sharing with them.
type QueueWedgeErrorInsecureDevices struct {
	UserDeviceMap map[string][]string
}

func (e QueueWedgeErrorInsecureDevices) Destroy() {
	FfiDestroyerMapStringSequenceString{}.Destroy(e.UserDeviceMap)
}

// This error occurs when a previously verified user is not anymore, and
// the current encryption setting prohibit sharing when it happens.
type QueueWedgeErrorIdentityViolations struct {
	Users []string
}

func (e QueueWedgeErrorIdentityViolations) Destroy() {
	FfiDestroyerSequenceString{}.Destroy(e.Users)
}

// It is required to set up cross-signing and properly erify the current
// session before sending.
type QueueWedgeErrorCrossVerificationRequired struct {
}

func (e QueueWedgeErrorCrossVerificationRequired) Destroy() {
}

// Some media content to be sent has disappeared from the cache.
type QueueWedgeErrorMissingMediaContent struct {
}

func (e QueueWedgeErrorMissingMediaContent) Destroy() {
}

// Some mime type couldn't be parsed.
type QueueWedgeErrorInvalidMimeType struct {
	MimeType string
}

func (e QueueWedgeErrorInvalidMimeType) Destroy() {
	FfiDestroyerString{}.Destroy(e.MimeType)
}

// Other errors.
type QueueWedgeErrorGenericApiError struct {
	Msg string
}

func (e QueueWedgeErrorGenericApiError) Destroy() {
	FfiDestroyerString{}.Destroy(e.Msg)
}

type FfiConverterQueueWedgeError struct{}

var FfiConverterQueueWedgeErrorINSTANCE = FfiConverterQueueWedgeError{}

func (c FfiConverterQueueWedgeError) Lift(rb RustBufferI) QueueWedgeError {
	return LiftFromRustBuffer[QueueWedgeError](c, rb)
}

func (c FfiConverterQueueWedgeError) Lower(value QueueWedgeError) C.RustBuffer {
	return LowerIntoRustBuffer[QueueWedgeError](c, value)
}
func (FfiConverterQueueWedgeError) Read(reader io.Reader) QueueWedgeError {
	id := readInt32(reader)
	switch id {
	case 1:
		return QueueWedgeErrorInsecureDevices{
			FfiConverterMapStringSequenceStringINSTANCE.Read(reader),
		}
	case 2:
		return QueueWedgeErrorIdentityViolations{
			FfiConverterSequenceStringINSTANCE.Read(reader),
		}
	case 3:
		return QueueWedgeErrorCrossVerificationRequired{}
	case 4:
		return QueueWedgeErrorMissingMediaContent{}
	case 5:
		return QueueWedgeErrorInvalidMimeType{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 6:
		return QueueWedgeErrorGenericApiError{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterQueueWedgeError.Read()", id))
	}
}

func (FfiConverterQueueWedgeError) Write(writer io.Writer, value QueueWedgeError) {
	switch variant_value := value.(type) {
	case QueueWedgeErrorInsecureDevices:
		writeInt32(writer, 1)
		FfiConverterMapStringSequenceStringINSTANCE.Write(writer, variant_value.UserDeviceMap)
	case QueueWedgeErrorIdentityViolations:
		writeInt32(writer, 2)
		FfiConverterSequenceStringINSTANCE.Write(writer, variant_value.Users)
	case QueueWedgeErrorCrossVerificationRequired:
		writeInt32(writer, 3)
	case QueueWedgeErrorMissingMediaContent:
		writeInt32(writer, 4)
	case QueueWedgeErrorInvalidMimeType:
		writeInt32(writer, 5)
		FfiConverterStringINSTANCE.Write(writer, variant_value.MimeType)
	case QueueWedgeErrorGenericApiError:
		writeInt32(writer, 6)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Msg)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterQueueWedgeError.Write", value))
	}
}

type FfiDestroyerQueueWedgeError struct{}

func (_ FfiDestroyerQueueWedgeError) Destroy(value QueueWedgeError) {
	value.Destroy()
}

// A [`TimelineItem`](super::TimelineItem) that doesn't correspond to an event.
type ReceiptType uint

const (
	ReceiptTypeRead        ReceiptType = 1
	ReceiptTypeReadPrivate ReceiptType = 2
	ReceiptTypeFullyRead   ReceiptType = 3
)

type FfiConverterReceiptType struct{}

var FfiConverterReceiptTypeINSTANCE = FfiConverterReceiptType{}

func (c FfiConverterReceiptType) Lift(rb RustBufferI) ReceiptType {
	return LiftFromRustBuffer[ReceiptType](c, rb)
}

func (c FfiConverterReceiptType) Lower(value ReceiptType) C.RustBuffer {
	return LowerIntoRustBuffer[ReceiptType](c, value)
}
func (FfiConverterReceiptType) Read(reader io.Reader) ReceiptType {
	id := readInt32(reader)
	return ReceiptType(id)
}

func (FfiConverterReceiptType) Write(writer io.Writer, value ReceiptType) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerReceiptType struct{}

func (_ FfiDestroyerReceiptType) Destroy(value ReceiptType) {
}

type RecoveryError struct {
	err error
}

// Convience method to turn *RecoveryError into error
// Avoiding treating nil pointer as non nil error interface
func (err *RecoveryError) AsError() error {
	if err == nil {
		return nil
	} else {
		return err
	}
}

func (err RecoveryError) Error() string {
	return fmt.Sprintf("RecoveryError: %s", err.err.Error())
}

func (err RecoveryError) Unwrap() error {
	return err.err
}

// Err* are used for checking error type with `errors.Is`
var ErrRecoveryErrorBackupExistsOnServer = fmt.Errorf("RecoveryErrorBackupExistsOnServer")
var ErrRecoveryErrorClient = fmt.Errorf("RecoveryErrorClient")
var ErrRecoveryErrorSecretStorage = fmt.Errorf("RecoveryErrorSecretStorage")

// Variant structs
// A backup already exists on the homeserver, the recovery subsystem does
// not allow backups to be overwritten, disable recovery first.
type RecoveryErrorBackupExistsOnServer struct {
}

// A backup already exists on the homeserver, the recovery subsystem does
// not allow backups to be overwritten, disable recovery first.
func NewRecoveryErrorBackupExistsOnServer() *RecoveryError {
	return &RecoveryError{err: &RecoveryErrorBackupExistsOnServer{}}
}

func (e RecoveryErrorBackupExistsOnServer) destroy() {
}

func (err RecoveryErrorBackupExistsOnServer) Error() string {
	return fmt.Sprint("BackupExistsOnServer")
}

func (self RecoveryErrorBackupExistsOnServer) Is(target error) bool {
	return target == ErrRecoveryErrorBackupExistsOnServer
}

// A typical SDK error.
type RecoveryErrorClient struct {
	Source *ClientError
}

// A typical SDK error.
func NewRecoveryErrorClient(
	source *ClientError,
) *RecoveryError {
	return &RecoveryError{err: &RecoveryErrorClient{
		Source: source}}
}

func (e RecoveryErrorClient) destroy() {
	FfiDestroyerClientError{}.Destroy(e.Source)
}

func (err RecoveryErrorClient) Error() string {
	return fmt.Sprint("Client",
		": ",

		"Source=",
		err.Source,
	)
}

func (self RecoveryErrorClient) Is(target error) bool {
	return target == ErrRecoveryErrorClient
}

// Error in the secret storage subsystem.
type RecoveryErrorSecretStorage struct {
	ErrorMessage string
}

// Error in the secret storage subsystem.
func NewRecoveryErrorSecretStorage(
	errorMessage string,
) *RecoveryError {
	return &RecoveryError{err: &RecoveryErrorSecretStorage{
		ErrorMessage: errorMessage}}
}

func (e RecoveryErrorSecretStorage) destroy() {
	FfiDestroyerString{}.Destroy(e.ErrorMessage)
}

func (err RecoveryErrorSecretStorage) Error() string {
	return fmt.Sprint("SecretStorage",
		": ",

		"ErrorMessage=",
		err.ErrorMessage,
	)
}

func (self RecoveryErrorSecretStorage) Is(target error) bool {
	return target == ErrRecoveryErrorSecretStorage
}

type FfiConverterRecoveryError struct{}

var FfiConverterRecoveryErrorINSTANCE = FfiConverterRecoveryError{}

func (c FfiConverterRecoveryError) Lift(eb RustBufferI) *RecoveryError {
	return LiftFromRustBuffer[*RecoveryError](c, eb)
}

func (c FfiConverterRecoveryError) Lower(value *RecoveryError) C.RustBuffer {
	return LowerIntoRustBuffer[*RecoveryError](c, value)
}

func (c FfiConverterRecoveryError) Read(reader io.Reader) *RecoveryError {
	errorID := readUint32(reader)

	switch errorID {
	case 1:
		return &RecoveryError{&RecoveryErrorBackupExistsOnServer{}}
	case 2:
		return &RecoveryError{&RecoveryErrorClient{
			Source: FfiConverterClientErrorINSTANCE.Read(reader),
		}}
	case 3:
		return &RecoveryError{&RecoveryErrorSecretStorage{
			ErrorMessage: FfiConverterStringINSTANCE.Read(reader),
		}}
	default:
		panic(fmt.Sprintf("Unknown error code %d in FfiConverterRecoveryError.Read()", errorID))
	}
}

func (c FfiConverterRecoveryError) Write(writer io.Writer, value *RecoveryError) {
	switch variantValue := value.err.(type) {
	case *RecoveryErrorBackupExistsOnServer:
		writeInt32(writer, 1)
	case *RecoveryErrorClient:
		writeInt32(writer, 2)
		FfiConverterClientErrorINSTANCE.Write(writer, variantValue.Source)
	case *RecoveryErrorSecretStorage:
		writeInt32(writer, 3)
		FfiConverterStringINSTANCE.Write(writer, variantValue.ErrorMessage)
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiConverterRecoveryError.Write", value))
	}
}

type FfiDestroyerRecoveryError struct{}

func (_ FfiDestroyerRecoveryError) Destroy(value *RecoveryError) {
	switch variantValue := value.err.(type) {
	case RecoveryErrorBackupExistsOnServer:
		variantValue.destroy()
	case RecoveryErrorClient:
		variantValue.destroy()
	case RecoveryErrorSecretStorage:
		variantValue.destroy()
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiDestroyerRecoveryError.Destroy", value))
	}
}

type RecoveryState uint

const (
	RecoveryStateUnknown    RecoveryState = 1
	RecoveryStateEnabled    RecoveryState = 2
	RecoveryStateDisabled   RecoveryState = 3
	RecoveryStateIncomplete RecoveryState = 4
)

type FfiConverterRecoveryState struct{}

var FfiConverterRecoveryStateINSTANCE = FfiConverterRecoveryState{}

func (c FfiConverterRecoveryState) Lift(rb RustBufferI) RecoveryState {
	return LiftFromRustBuffer[RecoveryState](c, rb)
}

func (c FfiConverterRecoveryState) Lower(value RecoveryState) C.RustBuffer {
	return LowerIntoRustBuffer[RecoveryState](c, value)
}
func (FfiConverterRecoveryState) Read(reader io.Reader) RecoveryState {
	id := readInt32(reader)
	return RecoveryState(id)
}

func (FfiConverterRecoveryState) Write(writer io.Writer, value RecoveryState) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerRecoveryState struct{}

func (_ FfiDestroyerRecoveryState) Destroy(value RecoveryState) {
}

type RepliedToEventDetails interface {
	Destroy()
}
type RepliedToEventDetailsUnavailable struct {
}

func (e RepliedToEventDetailsUnavailable) Destroy() {
}

type RepliedToEventDetailsPending struct {
}

func (e RepliedToEventDetailsPending) Destroy() {
}

type RepliedToEventDetailsReady struct {
	Content       TimelineItemContent
	Sender        string
	SenderProfile ProfileDetails
}

func (e RepliedToEventDetailsReady) Destroy() {
	FfiDestroyerTimelineItemContent{}.Destroy(e.Content)
	FfiDestroyerString{}.Destroy(e.Sender)
	FfiDestroyerProfileDetails{}.Destroy(e.SenderProfile)
}

type RepliedToEventDetailsError struct {
	Message string
}

func (e RepliedToEventDetailsError) Destroy() {
	FfiDestroyerString{}.Destroy(e.Message)
}

type FfiConverterRepliedToEventDetails struct{}

var FfiConverterRepliedToEventDetailsINSTANCE = FfiConverterRepliedToEventDetails{}

func (c FfiConverterRepliedToEventDetails) Lift(rb RustBufferI) RepliedToEventDetails {
	return LiftFromRustBuffer[RepliedToEventDetails](c, rb)
}

func (c FfiConverterRepliedToEventDetails) Lower(value RepliedToEventDetails) C.RustBuffer {
	return LowerIntoRustBuffer[RepliedToEventDetails](c, value)
}
func (FfiConverterRepliedToEventDetails) Read(reader io.Reader) RepliedToEventDetails {
	id := readInt32(reader)
	switch id {
	case 1:
		return RepliedToEventDetailsUnavailable{}
	case 2:
		return RepliedToEventDetailsPending{}
	case 3:
		return RepliedToEventDetailsReady{
			FfiConverterTimelineItemContentINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterProfileDetailsINSTANCE.Read(reader),
		}
	case 4:
		return RepliedToEventDetailsError{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterRepliedToEventDetails.Read()", id))
	}
}

func (FfiConverterRepliedToEventDetails) Write(writer io.Writer, value RepliedToEventDetails) {
	switch variant_value := value.(type) {
	case RepliedToEventDetailsUnavailable:
		writeInt32(writer, 1)
	case RepliedToEventDetailsPending:
		writeInt32(writer, 2)
	case RepliedToEventDetailsReady:
		writeInt32(writer, 3)
		FfiConverterTimelineItemContentINSTANCE.Write(writer, variant_value.Content)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Sender)
		FfiConverterProfileDetailsINSTANCE.Write(writer, variant_value.SenderProfile)
	case RepliedToEventDetailsError:
		writeInt32(writer, 4)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Message)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterRepliedToEventDetails.Write", value))
	}
}

type FfiDestroyerRepliedToEventDetails struct{}

func (_ FfiDestroyerRepliedToEventDetails) Destroy(value RepliedToEventDetails) {
	value.Destroy()
}

// Room account data events.
type RoomAccountDataEvent interface {
	Destroy()
}

// m.fully_read
type RoomAccountDataEventFullyReadEvent struct {
	EventId string
}

func (e RoomAccountDataEventFullyReadEvent) Destroy() {
	FfiDestroyerString{}.Destroy(e.EventId)
}

// m.marked_unread
type RoomAccountDataEventMarkedUnread struct {
	Unread bool
}

func (e RoomAccountDataEventMarkedUnread) Destroy() {
	FfiDestroyerBool{}.Destroy(e.Unread)
}

// m.tag
type RoomAccountDataEventTag struct {
	Tags map[TagName]TagInfo
}

func (e RoomAccountDataEventTag) Destroy() {
	FfiDestroyerMapTagNameTagInfo{}.Destroy(e.Tags)
}

// com.famedly.marked_unread
type RoomAccountDataEventUnstableMarkedUnread struct {
	Unread bool
}

func (e RoomAccountDataEventUnstableMarkedUnread) Destroy() {
	FfiDestroyerBool{}.Destroy(e.Unread)
}

type FfiConverterRoomAccountDataEvent struct{}

var FfiConverterRoomAccountDataEventINSTANCE = FfiConverterRoomAccountDataEvent{}

func (c FfiConverterRoomAccountDataEvent) Lift(rb RustBufferI) RoomAccountDataEvent {
	return LiftFromRustBuffer[RoomAccountDataEvent](c, rb)
}

func (c FfiConverterRoomAccountDataEvent) Lower(value RoomAccountDataEvent) C.RustBuffer {
	return LowerIntoRustBuffer[RoomAccountDataEvent](c, value)
}
func (FfiConverterRoomAccountDataEvent) Read(reader io.Reader) RoomAccountDataEvent {
	id := readInt32(reader)
	switch id {
	case 1:
		return RoomAccountDataEventFullyReadEvent{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 2:
		return RoomAccountDataEventMarkedUnread{
			FfiConverterBoolINSTANCE.Read(reader),
		}
	case 3:
		return RoomAccountDataEventTag{
			FfiConverterMapTagNameTagInfoINSTANCE.Read(reader),
		}
	case 4:
		return RoomAccountDataEventUnstableMarkedUnread{
			FfiConverterBoolINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterRoomAccountDataEvent.Read()", id))
	}
}

func (FfiConverterRoomAccountDataEvent) Write(writer io.Writer, value RoomAccountDataEvent) {
	switch variant_value := value.(type) {
	case RoomAccountDataEventFullyReadEvent:
		writeInt32(writer, 1)
		FfiConverterStringINSTANCE.Write(writer, variant_value.EventId)
	case RoomAccountDataEventMarkedUnread:
		writeInt32(writer, 2)
		FfiConverterBoolINSTANCE.Write(writer, variant_value.Unread)
	case RoomAccountDataEventTag:
		writeInt32(writer, 3)
		FfiConverterMapTagNameTagInfoINSTANCE.Write(writer, variant_value.Tags)
	case RoomAccountDataEventUnstableMarkedUnread:
		writeInt32(writer, 4)
		FfiConverterBoolINSTANCE.Write(writer, variant_value.Unread)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterRoomAccountDataEvent.Write", value))
	}
}

type FfiDestroyerRoomAccountDataEvent struct{}

func (_ FfiDestroyerRoomAccountDataEvent) Destroy(value RoomAccountDataEvent) {
	value.Destroy()
}

// Types of room account data events.
type RoomAccountDataEventType uint

const (
	// m.fully_read
	RoomAccountDataEventTypeFullyRead RoomAccountDataEventType = 1
	// m.marked_unread
	RoomAccountDataEventTypeMarkedUnread RoomAccountDataEventType = 2
	// m.tag
	RoomAccountDataEventTypeTag RoomAccountDataEventType = 3
	// com.famedly.marked_unread
	RoomAccountDataEventTypeUnstableMarkedUnread RoomAccountDataEventType = 4
)

type FfiConverterRoomAccountDataEventType struct{}

var FfiConverterRoomAccountDataEventTypeINSTANCE = FfiConverterRoomAccountDataEventType{}

func (c FfiConverterRoomAccountDataEventType) Lift(rb RustBufferI) RoomAccountDataEventType {
	return LiftFromRustBuffer[RoomAccountDataEventType](c, rb)
}

func (c FfiConverterRoomAccountDataEventType) Lower(value RoomAccountDataEventType) C.RustBuffer {
	return LowerIntoRustBuffer[RoomAccountDataEventType](c, value)
}
func (FfiConverterRoomAccountDataEventType) Read(reader io.Reader) RoomAccountDataEventType {
	id := readInt32(reader)
	return RoomAccountDataEventType(id)
}

func (FfiConverterRoomAccountDataEventType) Write(writer io.Writer, value RoomAccountDataEventType) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerRoomAccountDataEventType struct{}

func (_ FfiDestroyerRoomAccountDataEventType) Destroy(value RoomAccountDataEventType) {
}

type RoomDirectorySearchEntryUpdate interface {
	Destroy()
}
type RoomDirectorySearchEntryUpdateAppend struct {
	Values []RoomDescription
}

func (e RoomDirectorySearchEntryUpdateAppend) Destroy() {
	FfiDestroyerSequenceRoomDescription{}.Destroy(e.Values)
}

type RoomDirectorySearchEntryUpdateClear struct {
}

func (e RoomDirectorySearchEntryUpdateClear) Destroy() {
}

type RoomDirectorySearchEntryUpdatePushFront struct {
	Value RoomDescription
}

func (e RoomDirectorySearchEntryUpdatePushFront) Destroy() {
	FfiDestroyerRoomDescription{}.Destroy(e.Value)
}

type RoomDirectorySearchEntryUpdatePushBack struct {
	Value RoomDescription
}

func (e RoomDirectorySearchEntryUpdatePushBack) Destroy() {
	FfiDestroyerRoomDescription{}.Destroy(e.Value)
}

type RoomDirectorySearchEntryUpdatePopFront struct {
}

func (e RoomDirectorySearchEntryUpdatePopFront) Destroy() {
}

type RoomDirectorySearchEntryUpdatePopBack struct {
}

func (e RoomDirectorySearchEntryUpdatePopBack) Destroy() {
}

type RoomDirectorySearchEntryUpdateInsert struct {
	Index uint32
	Value RoomDescription
}

func (e RoomDirectorySearchEntryUpdateInsert) Destroy() {
	FfiDestroyerUint32{}.Destroy(e.Index)
	FfiDestroyerRoomDescription{}.Destroy(e.Value)
}

type RoomDirectorySearchEntryUpdateSet struct {
	Index uint32
	Value RoomDescription
}

func (e RoomDirectorySearchEntryUpdateSet) Destroy() {
	FfiDestroyerUint32{}.Destroy(e.Index)
	FfiDestroyerRoomDescription{}.Destroy(e.Value)
}

type RoomDirectorySearchEntryUpdateRemove struct {
	Index uint32
}

func (e RoomDirectorySearchEntryUpdateRemove) Destroy() {
	FfiDestroyerUint32{}.Destroy(e.Index)
}

type RoomDirectorySearchEntryUpdateTruncate struct {
	Length uint32
}

func (e RoomDirectorySearchEntryUpdateTruncate) Destroy() {
	FfiDestroyerUint32{}.Destroy(e.Length)
}

type RoomDirectorySearchEntryUpdateReset struct {
	Values []RoomDescription
}

func (e RoomDirectorySearchEntryUpdateReset) Destroy() {
	FfiDestroyerSequenceRoomDescription{}.Destroy(e.Values)
}

type FfiConverterRoomDirectorySearchEntryUpdate struct{}

var FfiConverterRoomDirectorySearchEntryUpdateINSTANCE = FfiConverterRoomDirectorySearchEntryUpdate{}

func (c FfiConverterRoomDirectorySearchEntryUpdate) Lift(rb RustBufferI) RoomDirectorySearchEntryUpdate {
	return LiftFromRustBuffer[RoomDirectorySearchEntryUpdate](c, rb)
}

func (c FfiConverterRoomDirectorySearchEntryUpdate) Lower(value RoomDirectorySearchEntryUpdate) C.RustBuffer {
	return LowerIntoRustBuffer[RoomDirectorySearchEntryUpdate](c, value)
}
func (FfiConverterRoomDirectorySearchEntryUpdate) Read(reader io.Reader) RoomDirectorySearchEntryUpdate {
	id := readInt32(reader)
	switch id {
	case 1:
		return RoomDirectorySearchEntryUpdateAppend{
			FfiConverterSequenceRoomDescriptionINSTANCE.Read(reader),
		}
	case 2:
		return RoomDirectorySearchEntryUpdateClear{}
	case 3:
		return RoomDirectorySearchEntryUpdatePushFront{
			FfiConverterRoomDescriptionINSTANCE.Read(reader),
		}
	case 4:
		return RoomDirectorySearchEntryUpdatePushBack{
			FfiConverterRoomDescriptionINSTANCE.Read(reader),
		}
	case 5:
		return RoomDirectorySearchEntryUpdatePopFront{}
	case 6:
		return RoomDirectorySearchEntryUpdatePopBack{}
	case 7:
		return RoomDirectorySearchEntryUpdateInsert{
			FfiConverterUint32INSTANCE.Read(reader),
			FfiConverterRoomDescriptionINSTANCE.Read(reader),
		}
	case 8:
		return RoomDirectorySearchEntryUpdateSet{
			FfiConverterUint32INSTANCE.Read(reader),
			FfiConverterRoomDescriptionINSTANCE.Read(reader),
		}
	case 9:
		return RoomDirectorySearchEntryUpdateRemove{
			FfiConverterUint32INSTANCE.Read(reader),
		}
	case 10:
		return RoomDirectorySearchEntryUpdateTruncate{
			FfiConverterUint32INSTANCE.Read(reader),
		}
	case 11:
		return RoomDirectorySearchEntryUpdateReset{
			FfiConverterSequenceRoomDescriptionINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterRoomDirectorySearchEntryUpdate.Read()", id))
	}
}

func (FfiConverterRoomDirectorySearchEntryUpdate) Write(writer io.Writer, value RoomDirectorySearchEntryUpdate) {
	switch variant_value := value.(type) {
	case RoomDirectorySearchEntryUpdateAppend:
		writeInt32(writer, 1)
		FfiConverterSequenceRoomDescriptionINSTANCE.Write(writer, variant_value.Values)
	case RoomDirectorySearchEntryUpdateClear:
		writeInt32(writer, 2)
	case RoomDirectorySearchEntryUpdatePushFront:
		writeInt32(writer, 3)
		FfiConverterRoomDescriptionINSTANCE.Write(writer, variant_value.Value)
	case RoomDirectorySearchEntryUpdatePushBack:
		writeInt32(writer, 4)
		FfiConverterRoomDescriptionINSTANCE.Write(writer, variant_value.Value)
	case RoomDirectorySearchEntryUpdatePopFront:
		writeInt32(writer, 5)
	case RoomDirectorySearchEntryUpdatePopBack:
		writeInt32(writer, 6)
	case RoomDirectorySearchEntryUpdateInsert:
		writeInt32(writer, 7)
		FfiConverterUint32INSTANCE.Write(writer, variant_value.Index)
		FfiConverterRoomDescriptionINSTANCE.Write(writer, variant_value.Value)
	case RoomDirectorySearchEntryUpdateSet:
		writeInt32(writer, 8)
		FfiConverterUint32INSTANCE.Write(writer, variant_value.Index)
		FfiConverterRoomDescriptionINSTANCE.Write(writer, variant_value.Value)
	case RoomDirectorySearchEntryUpdateRemove:
		writeInt32(writer, 9)
		FfiConverterUint32INSTANCE.Write(writer, variant_value.Index)
	case RoomDirectorySearchEntryUpdateTruncate:
		writeInt32(writer, 10)
		FfiConverterUint32INSTANCE.Write(writer, variant_value.Length)
	case RoomDirectorySearchEntryUpdateReset:
		writeInt32(writer, 11)
		FfiConverterSequenceRoomDescriptionINSTANCE.Write(writer, variant_value.Values)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterRoomDirectorySearchEntryUpdate.Write", value))
	}
}

type FfiDestroyerRoomDirectorySearchEntryUpdate struct{}

func (_ FfiDestroyerRoomDirectorySearchEntryUpdate) Destroy(value RoomDirectorySearchEntryUpdate) {
	value.Destroy()
}

type RoomError struct {
	err error
}

// Convience method to turn *RoomError into error
// Avoiding treating nil pointer as non nil error interface
func (err *RoomError) AsError() error {
	if err == nil {
		return nil
	} else {
		return err
	}
}

func (err RoomError) Error() string {
	return fmt.Sprintf("RoomError: %s", err.err.Error())
}

func (err RoomError) Unwrap() error {
	return err.err
}

// Err* are used for checking error type with `errors.Is`
var ErrRoomErrorInvalidAttachmentData = fmt.Errorf("RoomErrorInvalidAttachmentData")
var ErrRoomErrorInvalidAttachmentMimeType = fmt.Errorf("RoomErrorInvalidAttachmentMimeType")
var ErrRoomErrorInvalidMediaInfo = fmt.Errorf("RoomErrorInvalidMediaInfo")
var ErrRoomErrorTimelineUnavailable = fmt.Errorf("RoomErrorTimelineUnavailable")
var ErrRoomErrorInvalidThumbnailData = fmt.Errorf("RoomErrorInvalidThumbnailData")
var ErrRoomErrorInvalidRepliedToEventId = fmt.Errorf("RoomErrorInvalidRepliedToEventId")
var ErrRoomErrorFailedSendingAttachment = fmt.Errorf("RoomErrorFailedSendingAttachment")

// Variant structs
type RoomErrorInvalidAttachmentData struct {
	message string
}

func NewRoomErrorInvalidAttachmentData() *RoomError {
	return &RoomError{err: &RoomErrorInvalidAttachmentData{}}
}

func (e RoomErrorInvalidAttachmentData) destroy() {
}

func (err RoomErrorInvalidAttachmentData) Error() string {
	return fmt.Sprintf("InvalidAttachmentData: %s", err.message)
}

func (self RoomErrorInvalidAttachmentData) Is(target error) bool {
	return target == ErrRoomErrorInvalidAttachmentData
}

type RoomErrorInvalidAttachmentMimeType struct {
	message string
}

func NewRoomErrorInvalidAttachmentMimeType() *RoomError {
	return &RoomError{err: &RoomErrorInvalidAttachmentMimeType{}}
}

func (e RoomErrorInvalidAttachmentMimeType) destroy() {
}

func (err RoomErrorInvalidAttachmentMimeType) Error() string {
	return fmt.Sprintf("InvalidAttachmentMimeType: %s", err.message)
}

func (self RoomErrorInvalidAttachmentMimeType) Is(target error) bool {
	return target == ErrRoomErrorInvalidAttachmentMimeType
}

type RoomErrorInvalidMediaInfo struct {
	message string
}

func NewRoomErrorInvalidMediaInfo() *RoomError {
	return &RoomError{err: &RoomErrorInvalidMediaInfo{}}
}

func (e RoomErrorInvalidMediaInfo) destroy() {
}

func (err RoomErrorInvalidMediaInfo) Error() string {
	return fmt.Sprintf("InvalidMediaInfo: %s", err.message)
}

func (self RoomErrorInvalidMediaInfo) Is(target error) bool {
	return target == ErrRoomErrorInvalidMediaInfo
}

type RoomErrorTimelineUnavailable struct {
	message string
}

func NewRoomErrorTimelineUnavailable() *RoomError {
	return &RoomError{err: &RoomErrorTimelineUnavailable{}}
}

func (e RoomErrorTimelineUnavailable) destroy() {
}

func (err RoomErrorTimelineUnavailable) Error() string {
	return fmt.Sprintf("TimelineUnavailable: %s", err.message)
}

func (self RoomErrorTimelineUnavailable) Is(target error) bool {
	return target == ErrRoomErrorTimelineUnavailable
}

type RoomErrorInvalidThumbnailData struct {
	message string
}

func NewRoomErrorInvalidThumbnailData() *RoomError {
	return &RoomError{err: &RoomErrorInvalidThumbnailData{}}
}

func (e RoomErrorInvalidThumbnailData) destroy() {
}

func (err RoomErrorInvalidThumbnailData) Error() string {
	return fmt.Sprintf("InvalidThumbnailData: %s", err.message)
}

func (self RoomErrorInvalidThumbnailData) Is(target error) bool {
	return target == ErrRoomErrorInvalidThumbnailData
}

type RoomErrorInvalidRepliedToEventId struct {
	message string
}

func NewRoomErrorInvalidRepliedToEventId() *RoomError {
	return &RoomError{err: &RoomErrorInvalidRepliedToEventId{}}
}

func (e RoomErrorInvalidRepliedToEventId) destroy() {
}

func (err RoomErrorInvalidRepliedToEventId) Error() string {
	return fmt.Sprintf("InvalidRepliedToEventId: %s", err.message)
}

func (self RoomErrorInvalidRepliedToEventId) Is(target error) bool {
	return target == ErrRoomErrorInvalidRepliedToEventId
}

type RoomErrorFailedSendingAttachment struct {
	message string
}

func NewRoomErrorFailedSendingAttachment() *RoomError {
	return &RoomError{err: &RoomErrorFailedSendingAttachment{}}
}

func (e RoomErrorFailedSendingAttachment) destroy() {
}

func (err RoomErrorFailedSendingAttachment) Error() string {
	return fmt.Sprintf("FailedSendingAttachment: %s", err.message)
}

func (self RoomErrorFailedSendingAttachment) Is(target error) bool {
	return target == ErrRoomErrorFailedSendingAttachment
}

type FfiConverterRoomError struct{}

var FfiConverterRoomErrorINSTANCE = FfiConverterRoomError{}

func (c FfiConverterRoomError) Lift(eb RustBufferI) *RoomError {
	return LiftFromRustBuffer[*RoomError](c, eb)
}

func (c FfiConverterRoomError) Lower(value *RoomError) C.RustBuffer {
	return LowerIntoRustBuffer[*RoomError](c, value)
}

func (c FfiConverterRoomError) Read(reader io.Reader) *RoomError {
	errorID := readUint32(reader)

	message := FfiConverterStringINSTANCE.Read(reader)
	switch errorID {
	case 1:
		return &RoomError{&RoomErrorInvalidAttachmentData{message}}
	case 2:
		return &RoomError{&RoomErrorInvalidAttachmentMimeType{message}}
	case 3:
		return &RoomError{&RoomErrorInvalidMediaInfo{message}}
	case 4:
		return &RoomError{&RoomErrorTimelineUnavailable{message}}
	case 5:
		return &RoomError{&RoomErrorInvalidThumbnailData{message}}
	case 6:
		return &RoomError{&RoomErrorInvalidRepliedToEventId{message}}
	case 7:
		return &RoomError{&RoomErrorFailedSendingAttachment{message}}
	default:
		panic(fmt.Sprintf("Unknown error code %d in FfiConverterRoomError.Read()", errorID))
	}

}

func (c FfiConverterRoomError) Write(writer io.Writer, value *RoomError) {
	switch variantValue := value.err.(type) {
	case *RoomErrorInvalidAttachmentData:
		writeInt32(writer, 1)
	case *RoomErrorInvalidAttachmentMimeType:
		writeInt32(writer, 2)
	case *RoomErrorInvalidMediaInfo:
		writeInt32(writer, 3)
	case *RoomErrorTimelineUnavailable:
		writeInt32(writer, 4)
	case *RoomErrorInvalidThumbnailData:
		writeInt32(writer, 5)
	case *RoomErrorInvalidRepliedToEventId:
		writeInt32(writer, 6)
	case *RoomErrorFailedSendingAttachment:
		writeInt32(writer, 7)
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiConverterRoomError.Write", value))
	}
}

type FfiDestroyerRoomError struct{}

func (_ FfiDestroyerRoomError) Destroy(value *RoomError) {
	switch variantValue := value.err.(type) {
	case RoomErrorInvalidAttachmentData:
		variantValue.destroy()
	case RoomErrorInvalidAttachmentMimeType:
		variantValue.destroy()
	case RoomErrorInvalidMediaInfo:
		variantValue.destroy()
	case RoomErrorTimelineUnavailable:
		variantValue.destroy()
	case RoomErrorInvalidThumbnailData:
		variantValue.destroy()
	case RoomErrorInvalidRepliedToEventId:
		variantValue.destroy()
	case RoomErrorFailedSendingAttachment:
		variantValue.destroy()
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiDestroyerRoomError.Destroy", value))
	}
}

type RoomHistoryVisibility interface {
	Destroy()
}

// Previous events are accessible to newly joined members from the point
// they were invited onwards.
//
// Events stop being accessible when the member's state changes to
// something other than *invite* or *join*.
type RoomHistoryVisibilityInvited struct {
}

func (e RoomHistoryVisibilityInvited) Destroy() {
}

// Previous events are accessible to newly joined members from the point
// they joined the room onwards.
// Events stop being accessible when the member's state changes to
// something other than *join*.
type RoomHistoryVisibilityJoined struct {
}

func (e RoomHistoryVisibilityJoined) Destroy() {
}

// Previous events are always accessible to newly joined members.
//
// All events in the room are accessible, even those sent when the member
// was not a part of the room.
type RoomHistoryVisibilityShared struct {
}

func (e RoomHistoryVisibilityShared) Destroy() {
}

// All events while this is the `HistoryVisibility` value may be shared by
// any participating homeserver with anyone, regardless of whether they
// have ever joined the room.
type RoomHistoryVisibilityWorldReadable struct {
}

func (e RoomHistoryVisibilityWorldReadable) Destroy() {
}

// A custom visibility value.
type RoomHistoryVisibilityCustom struct {
	Value string
}

func (e RoomHistoryVisibilityCustom) Destroy() {
	FfiDestroyerString{}.Destroy(e.Value)
}

type FfiConverterRoomHistoryVisibility struct{}

var FfiConverterRoomHistoryVisibilityINSTANCE = FfiConverterRoomHistoryVisibility{}

func (c FfiConverterRoomHistoryVisibility) Lift(rb RustBufferI) RoomHistoryVisibility {
	return LiftFromRustBuffer[RoomHistoryVisibility](c, rb)
}

func (c FfiConverterRoomHistoryVisibility) Lower(value RoomHistoryVisibility) C.RustBuffer {
	return LowerIntoRustBuffer[RoomHistoryVisibility](c, value)
}
func (FfiConverterRoomHistoryVisibility) Read(reader io.Reader) RoomHistoryVisibility {
	id := readInt32(reader)
	switch id {
	case 1:
		return RoomHistoryVisibilityInvited{}
	case 2:
		return RoomHistoryVisibilityJoined{}
	case 3:
		return RoomHistoryVisibilityShared{}
	case 4:
		return RoomHistoryVisibilityWorldReadable{}
	case 5:
		return RoomHistoryVisibilityCustom{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterRoomHistoryVisibility.Read()", id))
	}
}

func (FfiConverterRoomHistoryVisibility) Write(writer io.Writer, value RoomHistoryVisibility) {
	switch variant_value := value.(type) {
	case RoomHistoryVisibilityInvited:
		writeInt32(writer, 1)
	case RoomHistoryVisibilityJoined:
		writeInt32(writer, 2)
	case RoomHistoryVisibilityShared:
		writeInt32(writer, 3)
	case RoomHistoryVisibilityWorldReadable:
		writeInt32(writer, 4)
	case RoomHistoryVisibilityCustom:
		writeInt32(writer, 5)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Value)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterRoomHistoryVisibility.Write", value))
	}
}

type FfiDestroyerRoomHistoryVisibility struct{}

func (_ FfiDestroyerRoomHistoryVisibility) Destroy(value RoomHistoryVisibility) {
	value.Destroy()
}

type RoomListEntriesDynamicFilterKind interface {
	Destroy()
}
type RoomListEntriesDynamicFilterKindAll struct {
	Filters []RoomListEntriesDynamicFilterKind
}

func (e RoomListEntriesDynamicFilterKindAll) Destroy() {
	FfiDestroyerSequenceRoomListEntriesDynamicFilterKind{}.Destroy(e.Filters)
}

type RoomListEntriesDynamicFilterKindAny struct {
	Filters []RoomListEntriesDynamicFilterKind
}

func (e RoomListEntriesDynamicFilterKindAny) Destroy() {
	FfiDestroyerSequenceRoomListEntriesDynamicFilterKind{}.Destroy(e.Filters)
}

type RoomListEntriesDynamicFilterKindNonLeft struct {
}

func (e RoomListEntriesDynamicFilterKindNonLeft) Destroy() {
}

type RoomListEntriesDynamicFilterKindJoined struct {
}

func (e RoomListEntriesDynamicFilterKindJoined) Destroy() {
}

type RoomListEntriesDynamicFilterKindUnread struct {
}

func (e RoomListEntriesDynamicFilterKindUnread) Destroy() {
}

type RoomListEntriesDynamicFilterKindFavourite struct {
}

func (e RoomListEntriesDynamicFilterKindFavourite) Destroy() {
}

type RoomListEntriesDynamicFilterKindInvite struct {
}

func (e RoomListEntriesDynamicFilterKindInvite) Destroy() {
}

type RoomListEntriesDynamicFilterKindCategory struct {
	Expect RoomListFilterCategory
}

func (e RoomListEntriesDynamicFilterKindCategory) Destroy() {
	FfiDestroyerRoomListFilterCategory{}.Destroy(e.Expect)
}

type RoomListEntriesDynamicFilterKindNone struct {
}

func (e RoomListEntriesDynamicFilterKindNone) Destroy() {
}

type RoomListEntriesDynamicFilterKindNormalizedMatchRoomName struct {
	Pattern string
}

func (e RoomListEntriesDynamicFilterKindNormalizedMatchRoomName) Destroy() {
	FfiDestroyerString{}.Destroy(e.Pattern)
}

type RoomListEntriesDynamicFilterKindFuzzyMatchRoomName struct {
	Pattern string
}

func (e RoomListEntriesDynamicFilterKindFuzzyMatchRoomName) Destroy() {
	FfiDestroyerString{}.Destroy(e.Pattern)
}

type FfiConverterRoomListEntriesDynamicFilterKind struct{}

var FfiConverterRoomListEntriesDynamicFilterKindINSTANCE = FfiConverterRoomListEntriesDynamicFilterKind{}

func (c FfiConverterRoomListEntriesDynamicFilterKind) Lift(rb RustBufferI) RoomListEntriesDynamicFilterKind {
	return LiftFromRustBuffer[RoomListEntriesDynamicFilterKind](c, rb)
}

func (c FfiConverterRoomListEntriesDynamicFilterKind) Lower(value RoomListEntriesDynamicFilterKind) C.RustBuffer {
	return LowerIntoRustBuffer[RoomListEntriesDynamicFilterKind](c, value)
}
func (FfiConverterRoomListEntriesDynamicFilterKind) Read(reader io.Reader) RoomListEntriesDynamicFilterKind {
	id := readInt32(reader)
	switch id {
	case 1:
		return RoomListEntriesDynamicFilterKindAll{
			FfiConverterSequenceRoomListEntriesDynamicFilterKindINSTANCE.Read(reader),
		}
	case 2:
		return RoomListEntriesDynamicFilterKindAny{
			FfiConverterSequenceRoomListEntriesDynamicFilterKindINSTANCE.Read(reader),
		}
	case 3:
		return RoomListEntriesDynamicFilterKindNonLeft{}
	case 4:
		return RoomListEntriesDynamicFilterKindJoined{}
	case 5:
		return RoomListEntriesDynamicFilterKindUnread{}
	case 6:
		return RoomListEntriesDynamicFilterKindFavourite{}
	case 7:
		return RoomListEntriesDynamicFilterKindInvite{}
	case 8:
		return RoomListEntriesDynamicFilterKindCategory{
			FfiConverterRoomListFilterCategoryINSTANCE.Read(reader),
		}
	case 9:
		return RoomListEntriesDynamicFilterKindNone{}
	case 10:
		return RoomListEntriesDynamicFilterKindNormalizedMatchRoomName{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 11:
		return RoomListEntriesDynamicFilterKindFuzzyMatchRoomName{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterRoomListEntriesDynamicFilterKind.Read()", id))
	}
}

func (FfiConverterRoomListEntriesDynamicFilterKind) Write(writer io.Writer, value RoomListEntriesDynamicFilterKind) {
	switch variant_value := value.(type) {
	case RoomListEntriesDynamicFilterKindAll:
		writeInt32(writer, 1)
		FfiConverterSequenceRoomListEntriesDynamicFilterKindINSTANCE.Write(writer, variant_value.Filters)
	case RoomListEntriesDynamicFilterKindAny:
		writeInt32(writer, 2)
		FfiConverterSequenceRoomListEntriesDynamicFilterKindINSTANCE.Write(writer, variant_value.Filters)
	case RoomListEntriesDynamicFilterKindNonLeft:
		writeInt32(writer, 3)
	case RoomListEntriesDynamicFilterKindJoined:
		writeInt32(writer, 4)
	case RoomListEntriesDynamicFilterKindUnread:
		writeInt32(writer, 5)
	case RoomListEntriesDynamicFilterKindFavourite:
		writeInt32(writer, 6)
	case RoomListEntriesDynamicFilterKindInvite:
		writeInt32(writer, 7)
	case RoomListEntriesDynamicFilterKindCategory:
		writeInt32(writer, 8)
		FfiConverterRoomListFilterCategoryINSTANCE.Write(writer, variant_value.Expect)
	case RoomListEntriesDynamicFilterKindNone:
		writeInt32(writer, 9)
	case RoomListEntriesDynamicFilterKindNormalizedMatchRoomName:
		writeInt32(writer, 10)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Pattern)
	case RoomListEntriesDynamicFilterKindFuzzyMatchRoomName:
		writeInt32(writer, 11)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Pattern)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterRoomListEntriesDynamicFilterKind.Write", value))
	}
}

type FfiDestroyerRoomListEntriesDynamicFilterKind struct{}

func (_ FfiDestroyerRoomListEntriesDynamicFilterKind) Destroy(value RoomListEntriesDynamicFilterKind) {
	value.Destroy()
}

type RoomListEntriesUpdate interface {
	Destroy()
}
type RoomListEntriesUpdateAppend struct {
	Values []*Room
}

func (e RoomListEntriesUpdateAppend) Destroy() {
	FfiDestroyerSequenceRoom{}.Destroy(e.Values)
}

type RoomListEntriesUpdateClear struct {
}

func (e RoomListEntriesUpdateClear) Destroy() {
}

type RoomListEntriesUpdatePushFront struct {
	Value *Room
}

func (e RoomListEntriesUpdatePushFront) Destroy() {
	FfiDestroyerRoom{}.Destroy(e.Value)
}

type RoomListEntriesUpdatePushBack struct {
	Value *Room
}

func (e RoomListEntriesUpdatePushBack) Destroy() {
	FfiDestroyerRoom{}.Destroy(e.Value)
}

type RoomListEntriesUpdatePopFront struct {
}

func (e RoomListEntriesUpdatePopFront) Destroy() {
}

type RoomListEntriesUpdatePopBack struct {
}

func (e RoomListEntriesUpdatePopBack) Destroy() {
}

type RoomListEntriesUpdateInsert struct {
	Index uint32
	Value *Room
}

func (e RoomListEntriesUpdateInsert) Destroy() {
	FfiDestroyerUint32{}.Destroy(e.Index)
	FfiDestroyerRoom{}.Destroy(e.Value)
}

type RoomListEntriesUpdateSet struct {
	Index uint32
	Value *Room
}

func (e RoomListEntriesUpdateSet) Destroy() {
	FfiDestroyerUint32{}.Destroy(e.Index)
	FfiDestroyerRoom{}.Destroy(e.Value)
}

type RoomListEntriesUpdateRemove struct {
	Index uint32
}

func (e RoomListEntriesUpdateRemove) Destroy() {
	FfiDestroyerUint32{}.Destroy(e.Index)
}

type RoomListEntriesUpdateTruncate struct {
	Length uint32
}

func (e RoomListEntriesUpdateTruncate) Destroy() {
	FfiDestroyerUint32{}.Destroy(e.Length)
}

type RoomListEntriesUpdateReset struct {
	Values []*Room
}

func (e RoomListEntriesUpdateReset) Destroy() {
	FfiDestroyerSequenceRoom{}.Destroy(e.Values)
}

type FfiConverterRoomListEntriesUpdate struct{}

var FfiConverterRoomListEntriesUpdateINSTANCE = FfiConverterRoomListEntriesUpdate{}

func (c FfiConverterRoomListEntriesUpdate) Lift(rb RustBufferI) RoomListEntriesUpdate {
	return LiftFromRustBuffer[RoomListEntriesUpdate](c, rb)
}

func (c FfiConverterRoomListEntriesUpdate) Lower(value RoomListEntriesUpdate) C.RustBuffer {
	return LowerIntoRustBuffer[RoomListEntriesUpdate](c, value)
}
func (FfiConverterRoomListEntriesUpdate) Read(reader io.Reader) RoomListEntriesUpdate {
	id := readInt32(reader)
	switch id {
	case 1:
		return RoomListEntriesUpdateAppend{
			FfiConverterSequenceRoomINSTANCE.Read(reader),
		}
	case 2:
		return RoomListEntriesUpdateClear{}
	case 3:
		return RoomListEntriesUpdatePushFront{
			FfiConverterRoomINSTANCE.Read(reader),
		}
	case 4:
		return RoomListEntriesUpdatePushBack{
			FfiConverterRoomINSTANCE.Read(reader),
		}
	case 5:
		return RoomListEntriesUpdatePopFront{}
	case 6:
		return RoomListEntriesUpdatePopBack{}
	case 7:
		return RoomListEntriesUpdateInsert{
			FfiConverterUint32INSTANCE.Read(reader),
			FfiConverterRoomINSTANCE.Read(reader),
		}
	case 8:
		return RoomListEntriesUpdateSet{
			FfiConverterUint32INSTANCE.Read(reader),
			FfiConverterRoomINSTANCE.Read(reader),
		}
	case 9:
		return RoomListEntriesUpdateRemove{
			FfiConverterUint32INSTANCE.Read(reader),
		}
	case 10:
		return RoomListEntriesUpdateTruncate{
			FfiConverterUint32INSTANCE.Read(reader),
		}
	case 11:
		return RoomListEntriesUpdateReset{
			FfiConverterSequenceRoomINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterRoomListEntriesUpdate.Read()", id))
	}
}

func (FfiConverterRoomListEntriesUpdate) Write(writer io.Writer, value RoomListEntriesUpdate) {
	switch variant_value := value.(type) {
	case RoomListEntriesUpdateAppend:
		writeInt32(writer, 1)
		FfiConverterSequenceRoomINSTANCE.Write(writer, variant_value.Values)
	case RoomListEntriesUpdateClear:
		writeInt32(writer, 2)
	case RoomListEntriesUpdatePushFront:
		writeInt32(writer, 3)
		FfiConverterRoomINSTANCE.Write(writer, variant_value.Value)
	case RoomListEntriesUpdatePushBack:
		writeInt32(writer, 4)
		FfiConverterRoomINSTANCE.Write(writer, variant_value.Value)
	case RoomListEntriesUpdatePopFront:
		writeInt32(writer, 5)
	case RoomListEntriesUpdatePopBack:
		writeInt32(writer, 6)
	case RoomListEntriesUpdateInsert:
		writeInt32(writer, 7)
		FfiConverterUint32INSTANCE.Write(writer, variant_value.Index)
		FfiConverterRoomINSTANCE.Write(writer, variant_value.Value)
	case RoomListEntriesUpdateSet:
		writeInt32(writer, 8)
		FfiConverterUint32INSTANCE.Write(writer, variant_value.Index)
		FfiConverterRoomINSTANCE.Write(writer, variant_value.Value)
	case RoomListEntriesUpdateRemove:
		writeInt32(writer, 9)
		FfiConverterUint32INSTANCE.Write(writer, variant_value.Index)
	case RoomListEntriesUpdateTruncate:
		writeInt32(writer, 10)
		FfiConverterUint32INSTANCE.Write(writer, variant_value.Length)
	case RoomListEntriesUpdateReset:
		writeInt32(writer, 11)
		FfiConverterSequenceRoomINSTANCE.Write(writer, variant_value.Values)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterRoomListEntriesUpdate.Write", value))
	}
}

type FfiDestroyerRoomListEntriesUpdate struct{}

func (_ FfiDestroyerRoomListEntriesUpdate) Destroy(value RoomListEntriesUpdate) {
	value.Destroy()
}

type RoomListError struct {
	err error
}

// Convience method to turn *RoomListError into error
// Avoiding treating nil pointer as non nil error interface
func (err *RoomListError) AsError() error {
	if err == nil {
		return nil
	} else {
		return err
	}
}

func (err RoomListError) Error() string {
	return fmt.Sprintf("RoomListError: %s", err.err.Error())
}

func (err RoomListError) Unwrap() error {
	return err.err
}

// Err* are used for checking error type with `errors.Is`
var ErrRoomListErrorSlidingSync = fmt.Errorf("RoomListErrorSlidingSync")
var ErrRoomListErrorUnknownList = fmt.Errorf("RoomListErrorUnknownList")
var ErrRoomListErrorInputCannotBeApplied = fmt.Errorf("RoomListErrorInputCannotBeApplied")
var ErrRoomListErrorRoomNotFound = fmt.Errorf("RoomListErrorRoomNotFound")
var ErrRoomListErrorInvalidRoomId = fmt.Errorf("RoomListErrorInvalidRoomId")
var ErrRoomListErrorEventCache = fmt.Errorf("RoomListErrorEventCache")
var ErrRoomListErrorIncorrectRoomMembership = fmt.Errorf("RoomListErrorIncorrectRoomMembership")

// Variant structs
type RoomListErrorSlidingSync struct {
	Error_ string
}

func NewRoomListErrorSlidingSync(
	error string,
) *RoomListError {
	return &RoomListError{err: &RoomListErrorSlidingSync{
		Error_: error}}
}

func (e RoomListErrorSlidingSync) destroy() {
	FfiDestroyerString{}.Destroy(e.Error_)
}

func (err RoomListErrorSlidingSync) Error() string {
	return fmt.Sprint("SlidingSync",
		": ",

		"Error_=",
		err.Error_,
	)
}

func (self RoomListErrorSlidingSync) Is(target error) bool {
	return target == ErrRoomListErrorSlidingSync
}

type RoomListErrorUnknownList struct {
	ListName string
}

func NewRoomListErrorUnknownList(
	listName string,
) *RoomListError {
	return &RoomListError{err: &RoomListErrorUnknownList{
		ListName: listName}}
}

func (e RoomListErrorUnknownList) destroy() {
	FfiDestroyerString{}.Destroy(e.ListName)
}

func (err RoomListErrorUnknownList) Error() string {
	return fmt.Sprint("UnknownList",
		": ",

		"ListName=",
		err.ListName,
	)
}

func (self RoomListErrorUnknownList) Is(target error) bool {
	return target == ErrRoomListErrorUnknownList
}

type RoomListErrorInputCannotBeApplied struct {
}

func NewRoomListErrorInputCannotBeApplied() *RoomListError {
	return &RoomListError{err: &RoomListErrorInputCannotBeApplied{}}
}

func (e RoomListErrorInputCannotBeApplied) destroy() {
}

func (err RoomListErrorInputCannotBeApplied) Error() string {
	return fmt.Sprint("InputCannotBeApplied")
}

func (self RoomListErrorInputCannotBeApplied) Is(target error) bool {
	return target == ErrRoomListErrorInputCannotBeApplied
}

type RoomListErrorRoomNotFound struct {
	RoomName string
}

func NewRoomListErrorRoomNotFound(
	roomName string,
) *RoomListError {
	return &RoomListError{err: &RoomListErrorRoomNotFound{
		RoomName: roomName}}
}

func (e RoomListErrorRoomNotFound) destroy() {
	FfiDestroyerString{}.Destroy(e.RoomName)
}

func (err RoomListErrorRoomNotFound) Error() string {
	return fmt.Sprint("RoomNotFound",
		": ",

		"RoomName=",
		err.RoomName,
	)
}

func (self RoomListErrorRoomNotFound) Is(target error) bool {
	return target == ErrRoomListErrorRoomNotFound
}

type RoomListErrorInvalidRoomId struct {
	Error_ string
}

func NewRoomListErrorInvalidRoomId(
	error string,
) *RoomListError {
	return &RoomListError{err: &RoomListErrorInvalidRoomId{
		Error_: error}}
}

func (e RoomListErrorInvalidRoomId) destroy() {
	FfiDestroyerString{}.Destroy(e.Error_)
}

func (err RoomListErrorInvalidRoomId) Error() string {
	return fmt.Sprint("InvalidRoomId",
		": ",

		"Error_=",
		err.Error_,
	)
}

func (self RoomListErrorInvalidRoomId) Is(target error) bool {
	return target == ErrRoomListErrorInvalidRoomId
}

type RoomListErrorEventCache struct {
	Error_ string
}

func NewRoomListErrorEventCache(
	error string,
) *RoomListError {
	return &RoomListError{err: &RoomListErrorEventCache{
		Error_: error}}
}

func (e RoomListErrorEventCache) destroy() {
	FfiDestroyerString{}.Destroy(e.Error_)
}

func (err RoomListErrorEventCache) Error() string {
	return fmt.Sprint("EventCache",
		": ",

		"Error_=",
		err.Error_,
	)
}

func (self RoomListErrorEventCache) Is(target error) bool {
	return target == ErrRoomListErrorEventCache
}

type RoomListErrorIncorrectRoomMembership struct {
	Expected []Membership
	Actual   Membership
}

func NewRoomListErrorIncorrectRoomMembership(
	expected []Membership,
	actual Membership,
) *RoomListError {
	return &RoomListError{err: &RoomListErrorIncorrectRoomMembership{
		Expected: expected,
		Actual:   actual}}
}

func (e RoomListErrorIncorrectRoomMembership) destroy() {
	FfiDestroyerSequenceMembership{}.Destroy(e.Expected)
	FfiDestroyerMembership{}.Destroy(e.Actual)
}

func (err RoomListErrorIncorrectRoomMembership) Error() string {
	return fmt.Sprint("IncorrectRoomMembership",
		": ",

		"Expected=",
		err.Expected,
		", ",
		"Actual=",
		err.Actual,
	)
}

func (self RoomListErrorIncorrectRoomMembership) Is(target error) bool {
	return target == ErrRoomListErrorIncorrectRoomMembership
}

type FfiConverterRoomListError struct{}

var FfiConverterRoomListErrorINSTANCE = FfiConverterRoomListError{}

func (c FfiConverterRoomListError) Lift(eb RustBufferI) *RoomListError {
	return LiftFromRustBuffer[*RoomListError](c, eb)
}

func (c FfiConverterRoomListError) Lower(value *RoomListError) C.RustBuffer {
	return LowerIntoRustBuffer[*RoomListError](c, value)
}

func (c FfiConverterRoomListError) Read(reader io.Reader) *RoomListError {
	errorID := readUint32(reader)

	switch errorID {
	case 1:
		return &RoomListError{&RoomListErrorSlidingSync{
			Error_: FfiConverterStringINSTANCE.Read(reader),
		}}
	case 2:
		return &RoomListError{&RoomListErrorUnknownList{
			ListName: FfiConverterStringINSTANCE.Read(reader),
		}}
	case 3:
		return &RoomListError{&RoomListErrorInputCannotBeApplied{}}
	case 4:
		return &RoomListError{&RoomListErrorRoomNotFound{
			RoomName: FfiConverterStringINSTANCE.Read(reader),
		}}
	case 5:
		return &RoomListError{&RoomListErrorInvalidRoomId{
			Error_: FfiConverterStringINSTANCE.Read(reader),
		}}
	case 6:
		return &RoomListError{&RoomListErrorEventCache{
			Error_: FfiConverterStringINSTANCE.Read(reader),
		}}
	case 7:
		return &RoomListError{&RoomListErrorIncorrectRoomMembership{
			Expected: FfiConverterSequenceMembershipINSTANCE.Read(reader),
			Actual:   FfiConverterMembershipINSTANCE.Read(reader),
		}}
	default:
		panic(fmt.Sprintf("Unknown error code %d in FfiConverterRoomListError.Read()", errorID))
	}
}

func (c FfiConverterRoomListError) Write(writer io.Writer, value *RoomListError) {
	switch variantValue := value.err.(type) {
	case *RoomListErrorSlidingSync:
		writeInt32(writer, 1)
		FfiConverterStringINSTANCE.Write(writer, variantValue.Error_)
	case *RoomListErrorUnknownList:
		writeInt32(writer, 2)
		FfiConverterStringINSTANCE.Write(writer, variantValue.ListName)
	case *RoomListErrorInputCannotBeApplied:
		writeInt32(writer, 3)
	case *RoomListErrorRoomNotFound:
		writeInt32(writer, 4)
		FfiConverterStringINSTANCE.Write(writer, variantValue.RoomName)
	case *RoomListErrorInvalidRoomId:
		writeInt32(writer, 5)
		FfiConverterStringINSTANCE.Write(writer, variantValue.Error_)
	case *RoomListErrorEventCache:
		writeInt32(writer, 6)
		FfiConverterStringINSTANCE.Write(writer, variantValue.Error_)
	case *RoomListErrorIncorrectRoomMembership:
		writeInt32(writer, 7)
		FfiConverterSequenceMembershipINSTANCE.Write(writer, variantValue.Expected)
		FfiConverterMembershipINSTANCE.Write(writer, variantValue.Actual)
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiConverterRoomListError.Write", value))
	}
}

type FfiDestroyerRoomListError struct{}

func (_ FfiDestroyerRoomListError) Destroy(value *RoomListError) {
	switch variantValue := value.err.(type) {
	case RoomListErrorSlidingSync:
		variantValue.destroy()
	case RoomListErrorUnknownList:
		variantValue.destroy()
	case RoomListErrorInputCannotBeApplied:
		variantValue.destroy()
	case RoomListErrorRoomNotFound:
		variantValue.destroy()
	case RoomListErrorInvalidRoomId:
		variantValue.destroy()
	case RoomListErrorEventCache:
		variantValue.destroy()
	case RoomListErrorIncorrectRoomMembership:
		variantValue.destroy()
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiDestroyerRoomListError.Destroy", value))
	}
}

type RoomListFilterCategory uint

const (
	RoomListFilterCategoryGroup  RoomListFilterCategory = 1
	RoomListFilterCategoryPeople RoomListFilterCategory = 2
)

type FfiConverterRoomListFilterCategory struct{}

var FfiConverterRoomListFilterCategoryINSTANCE = FfiConverterRoomListFilterCategory{}

func (c FfiConverterRoomListFilterCategory) Lift(rb RustBufferI) RoomListFilterCategory {
	return LiftFromRustBuffer[RoomListFilterCategory](c, rb)
}

func (c FfiConverterRoomListFilterCategory) Lower(value RoomListFilterCategory) C.RustBuffer {
	return LowerIntoRustBuffer[RoomListFilterCategory](c, value)
}
func (FfiConverterRoomListFilterCategory) Read(reader io.Reader) RoomListFilterCategory {
	id := readInt32(reader)
	return RoomListFilterCategory(id)
}

func (FfiConverterRoomListFilterCategory) Write(writer io.Writer, value RoomListFilterCategory) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerRoomListFilterCategory struct{}

func (_ FfiDestroyerRoomListFilterCategory) Destroy(value RoomListFilterCategory) {
}

type RoomListLoadingState interface {
	Destroy()
}
type RoomListLoadingStateNotLoaded struct {
}

func (e RoomListLoadingStateNotLoaded) Destroy() {
}

type RoomListLoadingStateLoaded struct {
	MaximumNumberOfRooms *uint32
}

func (e RoomListLoadingStateLoaded) Destroy() {
	FfiDestroyerOptionalUint32{}.Destroy(e.MaximumNumberOfRooms)
}

type FfiConverterRoomListLoadingState struct{}

var FfiConverterRoomListLoadingStateINSTANCE = FfiConverterRoomListLoadingState{}

func (c FfiConverterRoomListLoadingState) Lift(rb RustBufferI) RoomListLoadingState {
	return LiftFromRustBuffer[RoomListLoadingState](c, rb)
}

func (c FfiConverterRoomListLoadingState) Lower(value RoomListLoadingState) C.RustBuffer {
	return LowerIntoRustBuffer[RoomListLoadingState](c, value)
}
func (FfiConverterRoomListLoadingState) Read(reader io.Reader) RoomListLoadingState {
	id := readInt32(reader)
	switch id {
	case 1:
		return RoomListLoadingStateNotLoaded{}
	case 2:
		return RoomListLoadingStateLoaded{
			FfiConverterOptionalUint32INSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterRoomListLoadingState.Read()", id))
	}
}

func (FfiConverterRoomListLoadingState) Write(writer io.Writer, value RoomListLoadingState) {
	switch variant_value := value.(type) {
	case RoomListLoadingStateNotLoaded:
		writeInt32(writer, 1)
	case RoomListLoadingStateLoaded:
		writeInt32(writer, 2)
		FfiConverterOptionalUint32INSTANCE.Write(writer, variant_value.MaximumNumberOfRooms)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterRoomListLoadingState.Write", value))
	}
}

type FfiDestroyerRoomListLoadingState struct{}

func (_ FfiDestroyerRoomListLoadingState) Destroy(value RoomListLoadingState) {
	value.Destroy()
}

type RoomListServiceState uint

const (
	RoomListServiceStateInitial    RoomListServiceState = 1
	RoomListServiceStateSettingUp  RoomListServiceState = 2
	RoomListServiceStateRecovering RoomListServiceState = 3
	RoomListServiceStateRunning    RoomListServiceState = 4
	RoomListServiceStateError      RoomListServiceState = 5
	RoomListServiceStateTerminated RoomListServiceState = 6
)

type FfiConverterRoomListServiceState struct{}

var FfiConverterRoomListServiceStateINSTANCE = FfiConverterRoomListServiceState{}

func (c FfiConverterRoomListServiceState) Lift(rb RustBufferI) RoomListServiceState {
	return LiftFromRustBuffer[RoomListServiceState](c, rb)
}

func (c FfiConverterRoomListServiceState) Lower(value RoomListServiceState) C.RustBuffer {
	return LowerIntoRustBuffer[RoomListServiceState](c, value)
}
func (FfiConverterRoomListServiceState) Read(reader io.Reader) RoomListServiceState {
	id := readInt32(reader)
	return RoomListServiceState(id)
}

func (FfiConverterRoomListServiceState) Write(writer io.Writer, value RoomListServiceState) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerRoomListServiceState struct{}

func (_ FfiDestroyerRoomListServiceState) Destroy(value RoomListServiceState) {
}

type RoomListServiceSyncIndicator uint

const (
	RoomListServiceSyncIndicatorShow RoomListServiceSyncIndicator = 1
	RoomListServiceSyncIndicatorHide RoomListServiceSyncIndicator = 2
)

type FfiConverterRoomListServiceSyncIndicator struct{}

var FfiConverterRoomListServiceSyncIndicatorINSTANCE = FfiConverterRoomListServiceSyncIndicator{}

func (c FfiConverterRoomListServiceSyncIndicator) Lift(rb RustBufferI) RoomListServiceSyncIndicator {
	return LiftFromRustBuffer[RoomListServiceSyncIndicator](c, rb)
}

func (c FfiConverterRoomListServiceSyncIndicator) Lower(value RoomListServiceSyncIndicator) C.RustBuffer {
	return LowerIntoRustBuffer[RoomListServiceSyncIndicator](c, value)
}
func (FfiConverterRoomListServiceSyncIndicator) Read(reader io.Reader) RoomListServiceSyncIndicator {
	id := readInt32(reader)
	return RoomListServiceSyncIndicator(id)
}

func (FfiConverterRoomListServiceSyncIndicator) Write(writer io.Writer, value RoomListServiceSyncIndicator) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerRoomListServiceSyncIndicator struct{}

func (_ FfiDestroyerRoomListServiceSyncIndicator) Destroy(value RoomListServiceSyncIndicator) {
}

// Configure how many rooms will be restored when restoring the session with
// [`Client::restore_session_with`].
//
// Please, see the documentation of [`matrix_sdk::store::RoomLoadSettings`] to
// learn more.
type RoomLoadSettings interface {
	Destroy()
}

// Load all rooms from the `StateStore` into the in-memory state store
// `BaseStateStore`.
type RoomLoadSettingsAll struct {
}

func (e RoomLoadSettingsAll) Destroy() {
}

// Load a single room from the `StateStore` into the in-memory state
// store `BaseStateStore`.
//
// Please, be careful with this option. Read the documentation of
// [`RoomLoadSettings`].
type RoomLoadSettingsOne struct {
	RoomId string
}

func (e RoomLoadSettingsOne) Destroy() {
	FfiDestroyerString{}.Destroy(e.RoomId)
}

type FfiConverterRoomLoadSettings struct{}

var FfiConverterRoomLoadSettingsINSTANCE = FfiConverterRoomLoadSettings{}

func (c FfiConverterRoomLoadSettings) Lift(rb RustBufferI) RoomLoadSettings {
	return LiftFromRustBuffer[RoomLoadSettings](c, rb)
}

func (c FfiConverterRoomLoadSettings) Lower(value RoomLoadSettings) C.RustBuffer {
	return LowerIntoRustBuffer[RoomLoadSettings](c, value)
}
func (FfiConverterRoomLoadSettings) Read(reader io.Reader) RoomLoadSettings {
	id := readInt32(reader)
	switch id {
	case 1:
		return RoomLoadSettingsAll{}
	case 2:
		return RoomLoadSettingsOne{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterRoomLoadSettings.Read()", id))
	}
}

func (FfiConverterRoomLoadSettings) Write(writer io.Writer, value RoomLoadSettings) {
	switch variant_value := value.(type) {
	case RoomLoadSettingsAll:
		writeInt32(writer, 1)
	case RoomLoadSettingsOne:
		writeInt32(writer, 2)
		FfiConverterStringINSTANCE.Write(writer, variant_value.RoomId)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterRoomLoadSettings.Write", value))
	}
}

type FfiDestroyerRoomLoadSettings struct{}

func (_ FfiDestroyerRoomLoadSettings) Destroy(value RoomLoadSettings) {
	value.Destroy()
}

type RoomMessageEventMessageType uint

const (
	RoomMessageEventMessageTypeAudio               RoomMessageEventMessageType = 1
	RoomMessageEventMessageTypeEmote               RoomMessageEventMessageType = 2
	RoomMessageEventMessageTypeFile                RoomMessageEventMessageType = 3
	RoomMessageEventMessageTypeImage               RoomMessageEventMessageType = 4
	RoomMessageEventMessageTypeLocation            RoomMessageEventMessageType = 5
	RoomMessageEventMessageTypeNotice              RoomMessageEventMessageType = 6
	RoomMessageEventMessageTypeServerNotice        RoomMessageEventMessageType = 7
	RoomMessageEventMessageTypeText                RoomMessageEventMessageType = 8
	RoomMessageEventMessageTypeVideo               RoomMessageEventMessageType = 9
	RoomMessageEventMessageTypeVerificationRequest RoomMessageEventMessageType = 10
	RoomMessageEventMessageTypeOther               RoomMessageEventMessageType = 11
)

type FfiConverterRoomMessageEventMessageType struct{}

var FfiConverterRoomMessageEventMessageTypeINSTANCE = FfiConverterRoomMessageEventMessageType{}

func (c FfiConverterRoomMessageEventMessageType) Lift(rb RustBufferI) RoomMessageEventMessageType {
	return LiftFromRustBuffer[RoomMessageEventMessageType](c, rb)
}

func (c FfiConverterRoomMessageEventMessageType) Lower(value RoomMessageEventMessageType) C.RustBuffer {
	return LowerIntoRustBuffer[RoomMessageEventMessageType](c, value)
}
func (FfiConverterRoomMessageEventMessageType) Read(reader io.Reader) RoomMessageEventMessageType {
	id := readInt32(reader)
	return RoomMessageEventMessageType(id)
}

func (FfiConverterRoomMessageEventMessageType) Write(writer io.Writer, value RoomMessageEventMessageType) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerRoomMessageEventMessageType struct{}

func (_ FfiDestroyerRoomMessageEventMessageType) Destroy(value RoomMessageEventMessageType) {
}

// Enum representing the push notification modes for a room.
type RoomNotificationMode uint

const (
	// Receive notifications for all messages.
	RoomNotificationModeAllMessages RoomNotificationMode = 1
	// Receive notifications for mentions and keywords only.
	RoomNotificationModeMentionsAndKeywordsOnly RoomNotificationMode = 2
	// Do not receive any notifications.
	RoomNotificationModeMute RoomNotificationMode = 3
)

type FfiConverterRoomNotificationMode struct{}

var FfiConverterRoomNotificationModeINSTANCE = FfiConverterRoomNotificationMode{}

func (c FfiConverterRoomNotificationMode) Lift(rb RustBufferI) RoomNotificationMode {
	return LiftFromRustBuffer[RoomNotificationMode](c, rb)
}

func (c FfiConverterRoomNotificationMode) Lower(value RoomNotificationMode) C.RustBuffer {
	return LowerIntoRustBuffer[RoomNotificationMode](c, value)
}
func (FfiConverterRoomNotificationMode) Read(reader io.Reader) RoomNotificationMode {
	id := readInt32(reader)
	return RoomNotificationMode(id)
}

func (FfiConverterRoomNotificationMode) Write(writer io.Writer, value RoomNotificationMode) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerRoomNotificationMode struct{}

func (_ FfiDestroyerRoomNotificationMode) Destroy(value RoomNotificationMode) {
}

type RoomPreset uint

const (
	// `join_rules` is set to `invite` and `history_visibility` is set to
	// `shared`.
	RoomPresetPrivateChat RoomPreset = 1
	// `join_rules` is set to `public` and `history_visibility` is set to
	// `shared`.
	RoomPresetPublicChat RoomPreset = 2
	// Same as `PrivateChat`, but all initial invitees get the same power level
	// as the creator.
	RoomPresetTrustedPrivateChat RoomPreset = 3
)

type FfiConverterRoomPreset struct{}

var FfiConverterRoomPresetINSTANCE = FfiConverterRoomPreset{}

func (c FfiConverterRoomPreset) Lift(rb RustBufferI) RoomPreset {
	return LiftFromRustBuffer[RoomPreset](c, rb)
}

func (c FfiConverterRoomPreset) Lower(value RoomPreset) C.RustBuffer {
	return LowerIntoRustBuffer[RoomPreset](c, value)
}
func (FfiConverterRoomPreset) Read(reader io.Reader) RoomPreset {
	id := readInt32(reader)
	return RoomPreset(id)
}

func (FfiConverterRoomPreset) Write(writer io.Writer, value RoomPreset) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerRoomPreset struct{}

func (_ FfiDestroyerRoomPreset) Destroy(value RoomPreset) {
}

// The type of room for a [`RoomPreviewInfo`].
type RoomType interface {
	Destroy()
}

// It's a plain chat room.
type RoomTypeRoom struct {
}

func (e RoomTypeRoom) Destroy() {
}

// It's a space that can group several rooms.
type RoomTypeSpace struct {
}

func (e RoomTypeSpace) Destroy() {
}

// It's a custom implementation.
type RoomTypeCustom struct {
	Value string
}

func (e RoomTypeCustom) Destroy() {
	FfiDestroyerString{}.Destroy(e.Value)
}

type FfiConverterRoomType struct{}

var FfiConverterRoomTypeINSTANCE = FfiConverterRoomType{}

func (c FfiConverterRoomType) Lift(rb RustBufferI) RoomType {
	return LiftFromRustBuffer[RoomType](c, rb)
}

func (c FfiConverterRoomType) Lower(value RoomType) C.RustBuffer {
	return LowerIntoRustBuffer[RoomType](c, value)
}
func (FfiConverterRoomType) Read(reader io.Reader) RoomType {
	id := readInt32(reader)
	switch id {
	case 1:
		return RoomTypeRoom{}
	case 2:
		return RoomTypeSpace{}
	case 3:
		return RoomTypeCustom{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterRoomType.Read()", id))
	}
}

func (FfiConverterRoomType) Write(writer io.Writer, value RoomType) {
	switch variant_value := value.(type) {
	case RoomTypeRoom:
		writeInt32(writer, 1)
	case RoomTypeSpace:
		writeInt32(writer, 2)
	case RoomTypeCustom:
		writeInt32(writer, 3)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Value)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterRoomType.Write", value))
	}
}

type FfiDestroyerRoomType struct{}

func (_ FfiDestroyerRoomType) Destroy(value RoomType) {
	value.Destroy()
}

type RoomVisibility interface {
	Destroy()
}

// Indicates that the room will be shown in the published room list.
type RoomVisibilityPublic struct {
}

func (e RoomVisibilityPublic) Destroy() {
}

// Indicates that the room will not be shown in the published room list.
type RoomVisibilityPrivate struct {
}

func (e RoomVisibilityPrivate) Destroy() {
}

// A custom value that's not present in the spec.
type RoomVisibilityCustom struct {
	Value string
}

func (e RoomVisibilityCustom) Destroy() {
	FfiDestroyerString{}.Destroy(e.Value)
}

type FfiConverterRoomVisibility struct{}

var FfiConverterRoomVisibilityINSTANCE = FfiConverterRoomVisibility{}

func (c FfiConverterRoomVisibility) Lift(rb RustBufferI) RoomVisibility {
	return LiftFromRustBuffer[RoomVisibility](c, rb)
}

func (c FfiConverterRoomVisibility) Lower(value RoomVisibility) C.RustBuffer {
	return LowerIntoRustBuffer[RoomVisibility](c, value)
}
func (FfiConverterRoomVisibility) Read(reader io.Reader) RoomVisibility {
	id := readInt32(reader)
	switch id {
	case 1:
		return RoomVisibilityPublic{}
	case 2:
		return RoomVisibilityPrivate{}
	case 3:
		return RoomVisibilityCustom{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterRoomVisibility.Read()", id))
	}
}

func (FfiConverterRoomVisibility) Write(writer io.Writer, value RoomVisibility) {
	switch variant_value := value.(type) {
	case RoomVisibilityPublic:
		writeInt32(writer, 1)
	case RoomVisibilityPrivate:
		writeInt32(writer, 2)
	case RoomVisibilityCustom:
		writeInt32(writer, 3)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Value)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterRoomVisibility.Write", value))
	}
}

type FfiDestroyerRoomVisibility struct{}

func (_ FfiDestroyerRoomVisibility) Destroy(value RoomVisibility) {
	value.Destroy()
}

type RtcApplicationType uint

const (
	RtcApplicationTypeCall RtcApplicationType = 1
)

type FfiConverterRtcApplicationType struct{}

var FfiConverterRtcApplicationTypeINSTANCE = FfiConverterRtcApplicationType{}

func (c FfiConverterRtcApplicationType) Lift(rb RustBufferI) RtcApplicationType {
	return LiftFromRustBuffer[RtcApplicationType](c, rb)
}

func (c FfiConverterRtcApplicationType) Lower(value RtcApplicationType) C.RustBuffer {
	return LowerIntoRustBuffer[RtcApplicationType](c, value)
}
func (FfiConverterRtcApplicationType) Read(reader io.Reader) RtcApplicationType {
	id := readInt32(reader)
	return RtcApplicationType(id)
}

func (FfiConverterRtcApplicationType) Write(writer io.Writer, value RtcApplicationType) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerRtcApplicationType struct{}

func (_ FfiDestroyerRtcApplicationType) Destroy(value RtcApplicationType) {
}

type RuleKind interface {
	Destroy()
}

// User-configured rules that override all other kinds.
type RuleKindOverride struct {
}

func (e RuleKindOverride) Destroy() {
}

// Lowest priority user-defined rules.
type RuleKindUnderride struct {
}

func (e RuleKindUnderride) Destroy() {
}

// Sender-specific rules.
type RuleKindSender struct {
}

func (e RuleKindSender) Destroy() {
}

// Room-specific rules.
type RuleKindRoom struct {
}

func (e RuleKindRoom) Destroy() {
}

// Content-specific rules.
type RuleKindContent struct {
}

func (e RuleKindContent) Destroy() {
}

type RuleKindCustom struct {
	Value string
}

func (e RuleKindCustom) Destroy() {
	FfiDestroyerString{}.Destroy(e.Value)
}

type FfiConverterRuleKind struct{}

var FfiConverterRuleKindINSTANCE = FfiConverterRuleKind{}

func (c FfiConverterRuleKind) Lift(rb RustBufferI) RuleKind {
	return LiftFromRustBuffer[RuleKind](c, rb)
}

func (c FfiConverterRuleKind) Lower(value RuleKind) C.RustBuffer {
	return LowerIntoRustBuffer[RuleKind](c, value)
}
func (FfiConverterRuleKind) Read(reader io.Reader) RuleKind {
	id := readInt32(reader)
	switch id {
	case 1:
		return RuleKindOverride{}
	case 2:
		return RuleKindUnderride{}
	case 3:
		return RuleKindSender{}
	case 4:
		return RuleKindRoom{}
	case 5:
		return RuleKindContent{}
	case 6:
		return RuleKindCustom{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterRuleKind.Read()", id))
	}
}

func (FfiConverterRuleKind) Write(writer io.Writer, value RuleKind) {
	switch variant_value := value.(type) {
	case RuleKindOverride:
		writeInt32(writer, 1)
	case RuleKindUnderride:
		writeInt32(writer, 2)
	case RuleKindSender:
		writeInt32(writer, 3)
	case RuleKindRoom:
		writeInt32(writer, 4)
	case RuleKindContent:
		writeInt32(writer, 5)
	case RuleKindCustom:
		writeInt32(writer, 6)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Value)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterRuleKind.Write", value))
	}
}

type FfiDestroyerRuleKind struct{}

func (_ FfiDestroyerRuleKind) Destroy(value RuleKind) {
	value.Destroy()
}

// An algorithm and its properties, used to encrypt a secret.
type SecretStorageEncryptionAlgorithm interface {
	Destroy()
}

// Encrypted using the `m.secret_storage.v1.aes-hmac-sha2` algorithm.
//
// Secrets using this method are encrypted using AES-CTR-256 and
// authenticated using HMAC-SHA-256.
type SecretStorageEncryptionAlgorithmV1AesHmacSha2 struct {
	Properties SecretStorageV1AesHmacSha2Properties
}

func (e SecretStorageEncryptionAlgorithmV1AesHmacSha2) Destroy() {
	FfiDestroyerSecretStorageV1AesHmacSha2Properties{}.Destroy(e.Properties)
}

type FfiConverterSecretStorageEncryptionAlgorithm struct{}

var FfiConverterSecretStorageEncryptionAlgorithmINSTANCE = FfiConverterSecretStorageEncryptionAlgorithm{}

func (c FfiConverterSecretStorageEncryptionAlgorithm) Lift(rb RustBufferI) SecretStorageEncryptionAlgorithm {
	return LiftFromRustBuffer[SecretStorageEncryptionAlgorithm](c, rb)
}

func (c FfiConverterSecretStorageEncryptionAlgorithm) Lower(value SecretStorageEncryptionAlgorithm) C.RustBuffer {
	return LowerIntoRustBuffer[SecretStorageEncryptionAlgorithm](c, value)
}
func (FfiConverterSecretStorageEncryptionAlgorithm) Read(reader io.Reader) SecretStorageEncryptionAlgorithm {
	id := readInt32(reader)
	switch id {
	case 1:
		return SecretStorageEncryptionAlgorithmV1AesHmacSha2{
			FfiConverterSecretStorageV1AesHmacSha2PropertiesINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterSecretStorageEncryptionAlgorithm.Read()", id))
	}
}

func (FfiConverterSecretStorageEncryptionAlgorithm) Write(writer io.Writer, value SecretStorageEncryptionAlgorithm) {
	switch variant_value := value.(type) {
	case SecretStorageEncryptionAlgorithmV1AesHmacSha2:
		writeInt32(writer, 1)
		FfiConverterSecretStorageV1AesHmacSha2PropertiesINSTANCE.Write(writer, variant_value.Properties)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterSecretStorageEncryptionAlgorithm.Write", value))
	}
}

type FfiDestroyerSecretStorageEncryptionAlgorithm struct{}

func (_ FfiDestroyerSecretStorageEncryptionAlgorithm) Destroy(value SecretStorageEncryptionAlgorithm) {
	value.Destroy()
}

type SessionVerificationData interface {
	Destroy()
}
type SessionVerificationDataEmojis struct {
	Emojis  []*SessionVerificationEmoji
	Indices []byte
}

func (e SessionVerificationDataEmojis) Destroy() {
	FfiDestroyerSequenceSessionVerificationEmoji{}.Destroy(e.Emojis)
	FfiDestroyerBytes{}.Destroy(e.Indices)
}

type SessionVerificationDataDecimals struct {
	Values []uint16
}

func (e SessionVerificationDataDecimals) Destroy() {
	FfiDestroyerSequenceUint16{}.Destroy(e.Values)
}

type FfiConverterSessionVerificationData struct{}

var FfiConverterSessionVerificationDataINSTANCE = FfiConverterSessionVerificationData{}

func (c FfiConverterSessionVerificationData) Lift(rb RustBufferI) SessionVerificationData {
	return LiftFromRustBuffer[SessionVerificationData](c, rb)
}

func (c FfiConverterSessionVerificationData) Lower(value SessionVerificationData) C.RustBuffer {
	return LowerIntoRustBuffer[SessionVerificationData](c, value)
}
func (FfiConverterSessionVerificationData) Read(reader io.Reader) SessionVerificationData {
	id := readInt32(reader)
	switch id {
	case 1:
		return SessionVerificationDataEmojis{
			FfiConverterSequenceSessionVerificationEmojiINSTANCE.Read(reader),
			FfiConverterBytesINSTANCE.Read(reader),
		}
	case 2:
		return SessionVerificationDataDecimals{
			FfiConverterSequenceUint16INSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterSessionVerificationData.Read()", id))
	}
}

func (FfiConverterSessionVerificationData) Write(writer io.Writer, value SessionVerificationData) {
	switch variant_value := value.(type) {
	case SessionVerificationDataEmojis:
		writeInt32(writer, 1)
		FfiConverterSequenceSessionVerificationEmojiINSTANCE.Write(writer, variant_value.Emojis)
		FfiConverterBytesINSTANCE.Write(writer, variant_value.Indices)
	case SessionVerificationDataDecimals:
		writeInt32(writer, 2)
		FfiConverterSequenceUint16INSTANCE.Write(writer, variant_value.Values)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterSessionVerificationData.Write", value))
	}
}

type FfiDestroyerSessionVerificationData struct{}

func (_ FfiDestroyerSessionVerificationData) Destroy(value SessionVerificationData) {
	value.Destroy()
}

// Recommended decorations for decrypted messages, representing the message's
// authenticity properties.
type ShieldState interface {
	Destroy()
}

// A red shield with a tooltip containing the associated message should be
// presented.
type ShieldStateRed struct {
	Code    matrix_sdk_common.ShieldStateCode
	Message string
}

func (e ShieldStateRed) Destroy() {
	matrix_sdk_common.FfiDestroyerShieldStateCode{}.Destroy(e.Code)
	FfiDestroyerString{}.Destroy(e.Message)
}

// A grey shield with a tooltip containing the associated message should be
// presented.
type ShieldStateGrey struct {
	Code    matrix_sdk_common.ShieldStateCode
	Message string
}

func (e ShieldStateGrey) Destroy() {
	matrix_sdk_common.FfiDestroyerShieldStateCode{}.Destroy(e.Code)
	FfiDestroyerString{}.Destroy(e.Message)
}

// No shield should be presented.
type ShieldStateNone struct {
}

func (e ShieldStateNone) Destroy() {
}

type FfiConverterShieldState struct{}

var FfiConverterShieldStateINSTANCE = FfiConverterShieldState{}

func (c FfiConverterShieldState) Lift(rb RustBufferI) ShieldState {
	return LiftFromRustBuffer[ShieldState](c, rb)
}

func (c FfiConverterShieldState) Lower(value ShieldState) C.RustBuffer {
	return LowerIntoRustBuffer[ShieldState](c, value)
}
func (FfiConverterShieldState) Read(reader io.Reader) ShieldState {
	id := readInt32(reader)
	switch id {
	case 1:
		return ShieldStateRed{
			matrix_sdk_common.FfiConverterShieldStateCodeINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 2:
		return ShieldStateGrey{
			matrix_sdk_common.FfiConverterShieldStateCodeINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 3:
		return ShieldStateNone{}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterShieldState.Read()", id))
	}
}

func (FfiConverterShieldState) Write(writer io.Writer, value ShieldState) {
	switch variant_value := value.(type) {
	case ShieldStateRed:
		writeInt32(writer, 1)
		matrix_sdk_common.FfiConverterShieldStateCodeINSTANCE.Write(writer, variant_value.Code)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Message)
	case ShieldStateGrey:
		writeInt32(writer, 2)
		matrix_sdk_common.FfiConverterShieldStateCodeINSTANCE.Write(writer, variant_value.Code)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Message)
	case ShieldStateNone:
		writeInt32(writer, 3)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterShieldState.Write", value))
	}
}

type FfiDestroyerShieldState struct{}

func (_ FfiDestroyerShieldState) Destroy(value ShieldState) {
	value.Destroy()
}

type SlidingSyncVersion uint

const (
	SlidingSyncVersionNone   SlidingSyncVersion = 1
	SlidingSyncVersionNative SlidingSyncVersion = 2
)

type FfiConverterSlidingSyncVersion struct{}

var FfiConverterSlidingSyncVersionINSTANCE = FfiConverterSlidingSyncVersion{}

func (c FfiConverterSlidingSyncVersion) Lift(rb RustBufferI) SlidingSyncVersion {
	return LiftFromRustBuffer[SlidingSyncVersion](c, rb)
}

func (c FfiConverterSlidingSyncVersion) Lower(value SlidingSyncVersion) C.RustBuffer {
	return LowerIntoRustBuffer[SlidingSyncVersion](c, value)
}
func (FfiConverterSlidingSyncVersion) Read(reader io.Reader) SlidingSyncVersion {
	id := readInt32(reader)
	return SlidingSyncVersion(id)
}

func (FfiConverterSlidingSyncVersion) Write(writer io.Writer, value SlidingSyncVersion) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerSlidingSyncVersion struct{}

func (_ FfiDestroyerSlidingSyncVersion) Destroy(value SlidingSyncVersion) {
}

type SlidingSyncVersionBuilder uint

const (
	SlidingSyncVersionBuilderNone           SlidingSyncVersionBuilder = 1
	SlidingSyncVersionBuilderNative         SlidingSyncVersionBuilder = 2
	SlidingSyncVersionBuilderDiscoverNative SlidingSyncVersionBuilder = 3
)

type FfiConverterSlidingSyncVersionBuilder struct{}

var FfiConverterSlidingSyncVersionBuilderINSTANCE = FfiConverterSlidingSyncVersionBuilder{}

func (c FfiConverterSlidingSyncVersionBuilder) Lift(rb RustBufferI) SlidingSyncVersionBuilder {
	return LiftFromRustBuffer[SlidingSyncVersionBuilder](c, rb)
}

func (c FfiConverterSlidingSyncVersionBuilder) Lower(value SlidingSyncVersionBuilder) C.RustBuffer {
	return LowerIntoRustBuffer[SlidingSyncVersionBuilder](c, value)
}
func (FfiConverterSlidingSyncVersionBuilder) Read(reader io.Reader) SlidingSyncVersionBuilder {
	id := readInt32(reader)
	return SlidingSyncVersionBuilder(id)
}

func (FfiConverterSlidingSyncVersionBuilder) Write(writer io.Writer, value SlidingSyncVersionBuilder) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerSlidingSyncVersionBuilder struct{}

func (_ FfiDestroyerSlidingSyncVersionBuilder) Destroy(value SlidingSyncVersionBuilder) {
}

type SsoError struct {
	err error
}

// Convience method to turn *SsoError into error
// Avoiding treating nil pointer as non nil error interface
func (err *SsoError) AsError() error {
	if err == nil {
		return nil
	} else {
		return err
	}
}

func (err SsoError) Error() string {
	return fmt.Sprintf("SsoError: %s", err.err.Error())
}

func (err SsoError) Unwrap() error {
	return err.err
}

// Err* are used for checking error type with `errors.Is`
var ErrSsoErrorCallbackUrlInvalid = fmt.Errorf("SsoErrorCallbackUrlInvalid")
var ErrSsoErrorLoginWithTokenFailed = fmt.Errorf("SsoErrorLoginWithTokenFailed")
var ErrSsoErrorGeneric = fmt.Errorf("SsoErrorGeneric")

// Variant structs
type SsoErrorCallbackUrlInvalid struct {
	message string
}

func NewSsoErrorCallbackUrlInvalid() *SsoError {
	return &SsoError{err: &SsoErrorCallbackUrlInvalid{}}
}

func (e SsoErrorCallbackUrlInvalid) destroy() {
}

func (err SsoErrorCallbackUrlInvalid) Error() string {
	return fmt.Sprintf("CallbackUrlInvalid: %s", err.message)
}

func (self SsoErrorCallbackUrlInvalid) Is(target error) bool {
	return target == ErrSsoErrorCallbackUrlInvalid
}

type SsoErrorLoginWithTokenFailed struct {
	message string
}

func NewSsoErrorLoginWithTokenFailed() *SsoError {
	return &SsoError{err: &SsoErrorLoginWithTokenFailed{}}
}

func (e SsoErrorLoginWithTokenFailed) destroy() {
}

func (err SsoErrorLoginWithTokenFailed) Error() string {
	return fmt.Sprintf("LoginWithTokenFailed: %s", err.message)
}

func (self SsoErrorLoginWithTokenFailed) Is(target error) bool {
	return target == ErrSsoErrorLoginWithTokenFailed
}

type SsoErrorGeneric struct {
	message string
}

func NewSsoErrorGeneric() *SsoError {
	return &SsoError{err: &SsoErrorGeneric{}}
}

func (e SsoErrorGeneric) destroy() {
}

func (err SsoErrorGeneric) Error() string {
	return fmt.Sprintf("Generic: %s", err.message)
}

func (self SsoErrorGeneric) Is(target error) bool {
	return target == ErrSsoErrorGeneric
}

type FfiConverterSsoError struct{}

var FfiConverterSsoErrorINSTANCE = FfiConverterSsoError{}

func (c FfiConverterSsoError) Lift(eb RustBufferI) *SsoError {
	return LiftFromRustBuffer[*SsoError](c, eb)
}

func (c FfiConverterSsoError) Lower(value *SsoError) C.RustBuffer {
	return LowerIntoRustBuffer[*SsoError](c, value)
}

func (c FfiConverterSsoError) Read(reader io.Reader) *SsoError {
	errorID := readUint32(reader)

	message := FfiConverterStringINSTANCE.Read(reader)
	switch errorID {
	case 1:
		return &SsoError{&SsoErrorCallbackUrlInvalid{message}}
	case 2:
		return &SsoError{&SsoErrorLoginWithTokenFailed{message}}
	case 3:
		return &SsoError{&SsoErrorGeneric{message}}
	default:
		panic(fmt.Sprintf("Unknown error code %d in FfiConverterSsoError.Read()", errorID))
	}

}

func (c FfiConverterSsoError) Write(writer io.Writer, value *SsoError) {
	switch variantValue := value.err.(type) {
	case *SsoErrorCallbackUrlInvalid:
		writeInt32(writer, 1)
	case *SsoErrorLoginWithTokenFailed:
		writeInt32(writer, 2)
	case *SsoErrorGeneric:
		writeInt32(writer, 3)
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiConverterSsoError.Write", value))
	}
}

type FfiDestroyerSsoError struct{}

func (_ FfiDestroyerSsoError) Destroy(value *SsoError) {
	switch variantValue := value.err.(type) {
	case SsoErrorCallbackUrlInvalid:
		variantValue.destroy()
	case SsoErrorLoginWithTokenFailed:
		variantValue.destroy()
	case SsoErrorGeneric:
		variantValue.destroy()
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiDestroyerSsoError.Destroy", value))
	}
}

type StateEventContent interface {
	Destroy()
}
type StateEventContentPolicyRuleRoom struct {
}

func (e StateEventContentPolicyRuleRoom) Destroy() {
}

type StateEventContentPolicyRuleServer struct {
}

func (e StateEventContentPolicyRuleServer) Destroy() {
}

type StateEventContentPolicyRuleUser struct {
}

func (e StateEventContentPolicyRuleUser) Destroy() {
}

type StateEventContentRoomAliases struct {
}

func (e StateEventContentRoomAliases) Destroy() {
}

type StateEventContentRoomAvatar struct {
}

func (e StateEventContentRoomAvatar) Destroy() {
}

type StateEventContentRoomCanonicalAlias struct {
}

func (e StateEventContentRoomCanonicalAlias) Destroy() {
}

type StateEventContentRoomCreate struct {
}

func (e StateEventContentRoomCreate) Destroy() {
}

type StateEventContentRoomEncryption struct {
}

func (e StateEventContentRoomEncryption) Destroy() {
}

type StateEventContentRoomGuestAccess struct {
}

func (e StateEventContentRoomGuestAccess) Destroy() {
}

type StateEventContentRoomHistoryVisibility struct {
}

func (e StateEventContentRoomHistoryVisibility) Destroy() {
}

type StateEventContentRoomJoinRules struct {
}

func (e StateEventContentRoomJoinRules) Destroy() {
}

type StateEventContentRoomMemberContent struct {
	UserId          string
	MembershipState MembershipState
}

func (e StateEventContentRoomMemberContent) Destroy() {
	FfiDestroyerString{}.Destroy(e.UserId)
	FfiDestroyerMembershipState{}.Destroy(e.MembershipState)
}

type StateEventContentRoomName struct {
}

func (e StateEventContentRoomName) Destroy() {
}

type StateEventContentRoomPinnedEvents struct {
}

func (e StateEventContentRoomPinnedEvents) Destroy() {
}

type StateEventContentRoomPowerLevels struct {
}

func (e StateEventContentRoomPowerLevels) Destroy() {
}

type StateEventContentRoomServerAcl struct {
}

func (e StateEventContentRoomServerAcl) Destroy() {
}

type StateEventContentRoomThirdPartyInvite struct {
}

func (e StateEventContentRoomThirdPartyInvite) Destroy() {
}

type StateEventContentRoomTombstone struct {
}

func (e StateEventContentRoomTombstone) Destroy() {
}

type StateEventContentRoomTopic struct {
	Topic string
}

func (e StateEventContentRoomTopic) Destroy() {
	FfiDestroyerString{}.Destroy(e.Topic)
}

type StateEventContentSpaceChild struct {
}

func (e StateEventContentSpaceChild) Destroy() {
}

type StateEventContentSpaceParent struct {
}

func (e StateEventContentSpaceParent) Destroy() {
}

type FfiConverterStateEventContent struct{}

var FfiConverterStateEventContentINSTANCE = FfiConverterStateEventContent{}

func (c FfiConverterStateEventContent) Lift(rb RustBufferI) StateEventContent {
	return LiftFromRustBuffer[StateEventContent](c, rb)
}

func (c FfiConverterStateEventContent) Lower(value StateEventContent) C.RustBuffer {
	return LowerIntoRustBuffer[StateEventContent](c, value)
}
func (FfiConverterStateEventContent) Read(reader io.Reader) StateEventContent {
	id := readInt32(reader)
	switch id {
	case 1:
		return StateEventContentPolicyRuleRoom{}
	case 2:
		return StateEventContentPolicyRuleServer{}
	case 3:
		return StateEventContentPolicyRuleUser{}
	case 4:
		return StateEventContentRoomAliases{}
	case 5:
		return StateEventContentRoomAvatar{}
	case 6:
		return StateEventContentRoomCanonicalAlias{}
	case 7:
		return StateEventContentRoomCreate{}
	case 8:
		return StateEventContentRoomEncryption{}
	case 9:
		return StateEventContentRoomGuestAccess{}
	case 10:
		return StateEventContentRoomHistoryVisibility{}
	case 11:
		return StateEventContentRoomJoinRules{}
	case 12:
		return StateEventContentRoomMemberContent{
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterMembershipStateINSTANCE.Read(reader),
		}
	case 13:
		return StateEventContentRoomName{}
	case 14:
		return StateEventContentRoomPinnedEvents{}
	case 15:
		return StateEventContentRoomPowerLevels{}
	case 16:
		return StateEventContentRoomServerAcl{}
	case 17:
		return StateEventContentRoomThirdPartyInvite{}
	case 18:
		return StateEventContentRoomTombstone{}
	case 19:
		return StateEventContentRoomTopic{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 20:
		return StateEventContentSpaceChild{}
	case 21:
		return StateEventContentSpaceParent{}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterStateEventContent.Read()", id))
	}
}

func (FfiConverterStateEventContent) Write(writer io.Writer, value StateEventContent) {
	switch variant_value := value.(type) {
	case StateEventContentPolicyRuleRoom:
		writeInt32(writer, 1)
	case StateEventContentPolicyRuleServer:
		writeInt32(writer, 2)
	case StateEventContentPolicyRuleUser:
		writeInt32(writer, 3)
	case StateEventContentRoomAliases:
		writeInt32(writer, 4)
	case StateEventContentRoomAvatar:
		writeInt32(writer, 5)
	case StateEventContentRoomCanonicalAlias:
		writeInt32(writer, 6)
	case StateEventContentRoomCreate:
		writeInt32(writer, 7)
	case StateEventContentRoomEncryption:
		writeInt32(writer, 8)
	case StateEventContentRoomGuestAccess:
		writeInt32(writer, 9)
	case StateEventContentRoomHistoryVisibility:
		writeInt32(writer, 10)
	case StateEventContentRoomJoinRules:
		writeInt32(writer, 11)
	case StateEventContentRoomMemberContent:
		writeInt32(writer, 12)
		FfiConverterStringINSTANCE.Write(writer, variant_value.UserId)
		FfiConverterMembershipStateINSTANCE.Write(writer, variant_value.MembershipState)
	case StateEventContentRoomName:
		writeInt32(writer, 13)
	case StateEventContentRoomPinnedEvents:
		writeInt32(writer, 14)
	case StateEventContentRoomPowerLevels:
		writeInt32(writer, 15)
	case StateEventContentRoomServerAcl:
		writeInt32(writer, 16)
	case StateEventContentRoomThirdPartyInvite:
		writeInt32(writer, 17)
	case StateEventContentRoomTombstone:
		writeInt32(writer, 18)
	case StateEventContentRoomTopic:
		writeInt32(writer, 19)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Topic)
	case StateEventContentSpaceChild:
		writeInt32(writer, 20)
	case StateEventContentSpaceParent:
		writeInt32(writer, 21)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterStateEventContent.Write", value))
	}
}

type FfiDestroyerStateEventContent struct{}

func (_ FfiDestroyerStateEventContent) Destroy(value StateEventContent) {
	value.Destroy()
}

type StateEventType uint

const (
	StateEventTypeCallMember            StateEventType = 1
	StateEventTypePolicyRuleRoom        StateEventType = 2
	StateEventTypePolicyRuleServer      StateEventType = 3
	StateEventTypePolicyRuleUser        StateEventType = 4
	StateEventTypeRoomAliases           StateEventType = 5
	StateEventTypeRoomAvatar            StateEventType = 6
	StateEventTypeRoomCanonicalAlias    StateEventType = 7
	StateEventTypeRoomCreate            StateEventType = 8
	StateEventTypeRoomEncryption        StateEventType = 9
	StateEventTypeRoomGuestAccess       StateEventType = 10
	StateEventTypeRoomHistoryVisibility StateEventType = 11
	StateEventTypeRoomJoinRules         StateEventType = 12
	StateEventTypeRoomMemberEvent       StateEventType = 13
	StateEventTypeRoomName              StateEventType = 14
	StateEventTypeRoomPinnedEvents      StateEventType = 15
	StateEventTypeRoomPowerLevels       StateEventType = 16
	StateEventTypeRoomServerAcl         StateEventType = 17
	StateEventTypeRoomThirdPartyInvite  StateEventType = 18
	StateEventTypeRoomTombstone         StateEventType = 19
	StateEventTypeRoomTopic             StateEventType = 20
	StateEventTypeSpaceChild            StateEventType = 21
	StateEventTypeSpaceParent           StateEventType = 22
)

type FfiConverterStateEventType struct{}

var FfiConverterStateEventTypeINSTANCE = FfiConverterStateEventType{}

func (c FfiConverterStateEventType) Lift(rb RustBufferI) StateEventType {
	return LiftFromRustBuffer[StateEventType](c, rb)
}

func (c FfiConverterStateEventType) Lower(value StateEventType) C.RustBuffer {
	return LowerIntoRustBuffer[StateEventType](c, value)
}
func (FfiConverterStateEventType) Read(reader io.Reader) StateEventType {
	id := readInt32(reader)
	return StateEventType(id)
}

func (FfiConverterStateEventType) Write(writer io.Writer, value StateEventType) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerStateEventType struct{}

func (_ FfiDestroyerStateEventType) Destroy(value StateEventType) {
}

type SteadyStateError struct {
	err error
}

// Convience method to turn *SteadyStateError into error
// Avoiding treating nil pointer as non nil error interface
func (err *SteadyStateError) AsError() error {
	if err == nil {
		return nil
	} else {
		return err
	}
}

func (err SteadyStateError) Error() string {
	return fmt.Sprintf("SteadyStateError: %s", err.err.Error())
}

func (err SteadyStateError) Unwrap() error {
	return err.err
}

// Err* are used for checking error type with `errors.Is`
var ErrSteadyStateErrorBackupDisabled = fmt.Errorf("SteadyStateErrorBackupDisabled")
var ErrSteadyStateErrorConnection = fmt.Errorf("SteadyStateErrorConnection")
var ErrSteadyStateErrorLagged = fmt.Errorf("SteadyStateErrorLagged")

// Variant structs
type SteadyStateErrorBackupDisabled struct {
	message string
}

func NewSteadyStateErrorBackupDisabled() *SteadyStateError {
	return &SteadyStateError{err: &SteadyStateErrorBackupDisabled{}}
}

func (e SteadyStateErrorBackupDisabled) destroy() {
}

func (err SteadyStateErrorBackupDisabled) Error() string {
	return fmt.Sprintf("BackupDisabled: %s", err.message)
}

func (self SteadyStateErrorBackupDisabled) Is(target error) bool {
	return target == ErrSteadyStateErrorBackupDisabled
}

type SteadyStateErrorConnection struct {
	message string
}

func NewSteadyStateErrorConnection() *SteadyStateError {
	return &SteadyStateError{err: &SteadyStateErrorConnection{}}
}

func (e SteadyStateErrorConnection) destroy() {
}

func (err SteadyStateErrorConnection) Error() string {
	return fmt.Sprintf("Connection: %s", err.message)
}

func (self SteadyStateErrorConnection) Is(target error) bool {
	return target == ErrSteadyStateErrorConnection
}

type SteadyStateErrorLagged struct {
	message string
}

func NewSteadyStateErrorLagged() *SteadyStateError {
	return &SteadyStateError{err: &SteadyStateErrorLagged{}}
}

func (e SteadyStateErrorLagged) destroy() {
}

func (err SteadyStateErrorLagged) Error() string {
	return fmt.Sprintf("Lagged: %s", err.message)
}

func (self SteadyStateErrorLagged) Is(target error) bool {
	return target == ErrSteadyStateErrorLagged
}

type FfiConverterSteadyStateError struct{}

var FfiConverterSteadyStateErrorINSTANCE = FfiConverterSteadyStateError{}

func (c FfiConverterSteadyStateError) Lift(eb RustBufferI) *SteadyStateError {
	return LiftFromRustBuffer[*SteadyStateError](c, eb)
}

func (c FfiConverterSteadyStateError) Lower(value *SteadyStateError) C.RustBuffer {
	return LowerIntoRustBuffer[*SteadyStateError](c, value)
}

func (c FfiConverterSteadyStateError) Read(reader io.Reader) *SteadyStateError {
	errorID := readUint32(reader)

	message := FfiConverterStringINSTANCE.Read(reader)
	switch errorID {
	case 1:
		return &SteadyStateError{&SteadyStateErrorBackupDisabled{message}}
	case 2:
		return &SteadyStateError{&SteadyStateErrorConnection{message}}
	case 3:
		return &SteadyStateError{&SteadyStateErrorLagged{message}}
	default:
		panic(fmt.Sprintf("Unknown error code %d in FfiConverterSteadyStateError.Read()", errorID))
	}

}

func (c FfiConverterSteadyStateError) Write(writer io.Writer, value *SteadyStateError) {
	switch variantValue := value.err.(type) {
	case *SteadyStateErrorBackupDisabled:
		writeInt32(writer, 1)
	case *SteadyStateErrorConnection:
		writeInt32(writer, 2)
	case *SteadyStateErrorLagged:
		writeInt32(writer, 3)
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiConverterSteadyStateError.Write", value))
	}
}

type FfiDestroyerSteadyStateError struct{}

func (_ FfiDestroyerSteadyStateError) Destroy(value *SteadyStateError) {
	switch variantValue := value.err.(type) {
	case SteadyStateErrorBackupDisabled:
		variantValue.destroy()
	case SteadyStateErrorConnection:
		variantValue.destroy()
	case SteadyStateErrorLagged:
		variantValue.destroy()
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiDestroyerSteadyStateError.Destroy", value))
	}
}

type SyncServiceState uint

const (
	SyncServiceStateIdle       SyncServiceState = 1
	SyncServiceStateRunning    SyncServiceState = 2
	SyncServiceStateTerminated SyncServiceState = 3
	SyncServiceStateError      SyncServiceState = 4
	SyncServiceStateOffline    SyncServiceState = 5
)

type FfiConverterSyncServiceState struct{}

var FfiConverterSyncServiceStateINSTANCE = FfiConverterSyncServiceState{}

func (c FfiConverterSyncServiceState) Lift(rb RustBufferI) SyncServiceState {
	return LiftFromRustBuffer[SyncServiceState](c, rb)
}

func (c FfiConverterSyncServiceState) Lower(value SyncServiceState) C.RustBuffer {
	return LowerIntoRustBuffer[SyncServiceState](c, value)
}
func (FfiConverterSyncServiceState) Read(reader io.Reader) SyncServiceState {
	id := readInt32(reader)
	return SyncServiceState(id)
}

func (FfiConverterSyncServiceState) Write(writer io.Writer, value SyncServiceState) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerSyncServiceState struct{}

func (_ FfiDestroyerSyncServiceState) Destroy(value SyncServiceState) {
}

// The name of a tag.
type TagName interface {
	Destroy()
}

// `m.favourite`: The user's favorite rooms.
type TagNameFavorite struct {
}

func (e TagNameFavorite) Destroy() {
}

// `m.lowpriority`: These should be shown with lower precedence than
// others.
type TagNameLowPriority struct {
}

func (e TagNameLowPriority) Destroy() {
}

// `m.server_notice`: Used to identify
type TagNameServerNotice struct {
}

func (e TagNameServerNotice) Destroy() {
}

// `u.*`: User-defined tag
type TagNameUser struct {
	Name UserTagName
}

func (e TagNameUser) Destroy() {
	FfiDestroyerUserTagName{}.Destroy(e.Name)
}

type FfiConverterTagName struct{}

var FfiConverterTagNameINSTANCE = FfiConverterTagName{}

func (c FfiConverterTagName) Lift(rb RustBufferI) TagName {
	return LiftFromRustBuffer[TagName](c, rb)
}

func (c FfiConverterTagName) Lower(value TagName) C.RustBuffer {
	return LowerIntoRustBuffer[TagName](c, value)
}
func (FfiConverterTagName) Read(reader io.Reader) TagName {
	id := readInt32(reader)
	switch id {
	case 1:
		return TagNameFavorite{}
	case 2:
		return TagNameLowPriority{}
	case 3:
		return TagNameServerNotice{}
	case 4:
		return TagNameUser{
			FfiConverterUserTagNameINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterTagName.Read()", id))
	}
}

func (FfiConverterTagName) Write(writer io.Writer, value TagName) {
	switch variant_value := value.(type) {
	case TagNameFavorite:
		writeInt32(writer, 1)
	case TagNameLowPriority:
		writeInt32(writer, 2)
	case TagNameServerNotice:
		writeInt32(writer, 3)
	case TagNameUser:
		writeInt32(writer, 4)
		FfiConverterUserTagNameINSTANCE.Write(writer, variant_value.Name)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterTagName.Write", value))
	}
}

type FfiDestroyerTagName struct{}

func (_ FfiDestroyerTagName) Destroy(value TagName) {
	value.Destroy()
}

type ThreadSummaryLatestEventDetails interface {
	Destroy()
}
type ThreadSummaryLatestEventDetailsUnavailable struct {
}

func (e ThreadSummaryLatestEventDetailsUnavailable) Destroy() {
}

type ThreadSummaryLatestEventDetailsPending struct {
}

func (e ThreadSummaryLatestEventDetailsPending) Destroy() {
}

type ThreadSummaryLatestEventDetailsReady struct {
	Sender        string
	SenderProfile ProfileDetails
	Content       TimelineItemContent
}

func (e ThreadSummaryLatestEventDetailsReady) Destroy() {
	FfiDestroyerString{}.Destroy(e.Sender)
	FfiDestroyerProfileDetails{}.Destroy(e.SenderProfile)
	FfiDestroyerTimelineItemContent{}.Destroy(e.Content)
}

type ThreadSummaryLatestEventDetailsError struct {
	Message string
}

func (e ThreadSummaryLatestEventDetailsError) Destroy() {
	FfiDestroyerString{}.Destroy(e.Message)
}

type FfiConverterThreadSummaryLatestEventDetails struct{}

var FfiConverterThreadSummaryLatestEventDetailsINSTANCE = FfiConverterThreadSummaryLatestEventDetails{}

func (c FfiConverterThreadSummaryLatestEventDetails) Lift(rb RustBufferI) ThreadSummaryLatestEventDetails {
	return LiftFromRustBuffer[ThreadSummaryLatestEventDetails](c, rb)
}

func (c FfiConverterThreadSummaryLatestEventDetails) Lower(value ThreadSummaryLatestEventDetails) C.RustBuffer {
	return LowerIntoRustBuffer[ThreadSummaryLatestEventDetails](c, value)
}
func (FfiConverterThreadSummaryLatestEventDetails) Read(reader io.Reader) ThreadSummaryLatestEventDetails {
	id := readInt32(reader)
	switch id {
	case 1:
		return ThreadSummaryLatestEventDetailsUnavailable{}
	case 2:
		return ThreadSummaryLatestEventDetailsPending{}
	case 3:
		return ThreadSummaryLatestEventDetailsReady{
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterProfileDetailsINSTANCE.Read(reader),
			FfiConverterTimelineItemContentINSTANCE.Read(reader),
		}
	case 4:
		return ThreadSummaryLatestEventDetailsError{
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterThreadSummaryLatestEventDetails.Read()", id))
	}
}

func (FfiConverterThreadSummaryLatestEventDetails) Write(writer io.Writer, value ThreadSummaryLatestEventDetails) {
	switch variant_value := value.(type) {
	case ThreadSummaryLatestEventDetailsUnavailable:
		writeInt32(writer, 1)
	case ThreadSummaryLatestEventDetailsPending:
		writeInt32(writer, 2)
	case ThreadSummaryLatestEventDetailsReady:
		writeInt32(writer, 3)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Sender)
		FfiConverterProfileDetailsINSTANCE.Write(writer, variant_value.SenderProfile)
		FfiConverterTimelineItemContentINSTANCE.Write(writer, variant_value.Content)
	case ThreadSummaryLatestEventDetailsError:
		writeInt32(writer, 4)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Message)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterThreadSummaryLatestEventDetails.Write", value))
	}
}

type FfiDestroyerThreadSummaryLatestEventDetails struct{}

func (_ FfiDestroyerThreadSummaryLatestEventDetails) Destroy(value ThreadSummaryLatestEventDetails) {
	value.Destroy()
}

type TimelineChange uint

const (
	TimelineChangeAppend    TimelineChange = 1
	TimelineChangeClear     TimelineChange = 2
	TimelineChangeInsert    TimelineChange = 3
	TimelineChangeSet       TimelineChange = 4
	TimelineChangeRemove    TimelineChange = 5
	TimelineChangePushBack  TimelineChange = 6
	TimelineChangePushFront TimelineChange = 7
	TimelineChangePopBack   TimelineChange = 8
	TimelineChangePopFront  TimelineChange = 9
	TimelineChangeTruncate  TimelineChange = 10
	TimelineChangeReset     TimelineChange = 11
)

type FfiConverterTimelineChange struct{}

var FfiConverterTimelineChangeINSTANCE = FfiConverterTimelineChange{}

func (c FfiConverterTimelineChange) Lift(rb RustBufferI) TimelineChange {
	return LiftFromRustBuffer[TimelineChange](c, rb)
}

func (c FfiConverterTimelineChange) Lower(value TimelineChange) C.RustBuffer {
	return LowerIntoRustBuffer[TimelineChange](c, value)
}
func (FfiConverterTimelineChange) Read(reader io.Reader) TimelineChange {
	id := readInt32(reader)
	return TimelineChange(id)
}

func (FfiConverterTimelineChange) Write(writer io.Writer, value TimelineChange) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerTimelineChange struct{}

func (_ FfiDestroyerTimelineChange) Destroy(value TimelineChange) {
}

type TimelineEventType interface {
	Destroy()
}
type TimelineEventTypeMessageLike struct {
	Content MessageLikeEventContent
}

func (e TimelineEventTypeMessageLike) Destroy() {
	FfiDestroyerMessageLikeEventContent{}.Destroy(e.Content)
}

type TimelineEventTypeState struct {
	Content StateEventContent
}

func (e TimelineEventTypeState) Destroy() {
	FfiDestroyerStateEventContent{}.Destroy(e.Content)
}

type FfiConverterTimelineEventType struct{}

var FfiConverterTimelineEventTypeINSTANCE = FfiConverterTimelineEventType{}

func (c FfiConverterTimelineEventType) Lift(rb RustBufferI) TimelineEventType {
	return LiftFromRustBuffer[TimelineEventType](c, rb)
}

func (c FfiConverterTimelineEventType) Lower(value TimelineEventType) C.RustBuffer {
	return LowerIntoRustBuffer[TimelineEventType](c, value)
}
func (FfiConverterTimelineEventType) Read(reader io.Reader) TimelineEventType {
	id := readInt32(reader)
	switch id {
	case 1:
		return TimelineEventTypeMessageLike{
			FfiConverterMessageLikeEventContentINSTANCE.Read(reader),
		}
	case 2:
		return TimelineEventTypeState{
			FfiConverterStateEventContentINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterTimelineEventType.Read()", id))
	}
}

func (FfiConverterTimelineEventType) Write(writer io.Writer, value TimelineEventType) {
	switch variant_value := value.(type) {
	case TimelineEventTypeMessageLike:
		writeInt32(writer, 1)
		FfiConverterMessageLikeEventContentINSTANCE.Write(writer, variant_value.Content)
	case TimelineEventTypeState:
		writeInt32(writer, 2)
		FfiConverterStateEventContentINSTANCE.Write(writer, variant_value.Content)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterTimelineEventType.Write", value))
	}
}

type FfiDestroyerTimelineEventType struct{}

func (_ FfiDestroyerTimelineEventType) Destroy(value TimelineEventType) {
	value.Destroy()
}

type TimelineFilter interface {
	Destroy()
}

// Show all the events in the timeline, independent of their type.
type TimelineFilterAll struct {
}

func (e TimelineFilterAll) Destroy() {
}

// Show only `m.room.messages` of the given room message types.
type TimelineFilterOnlyMessage struct {
	Types []RoomMessageEventMessageType
}

func (e TimelineFilterOnlyMessage) Destroy() {
	FfiDestroyerSequenceRoomMessageEventMessageType{}.Destroy(e.Types)
}

// Show only events which match this filter.
type TimelineFilterEventTypeFilter struct {
	Filter *TimelineEventTypeFilter
}

func (e TimelineFilterEventTypeFilter) Destroy() {
	FfiDestroyerTimelineEventTypeFilter{}.Destroy(e.Filter)
}

type FfiConverterTimelineFilter struct{}

var FfiConverterTimelineFilterINSTANCE = FfiConverterTimelineFilter{}

func (c FfiConverterTimelineFilter) Lift(rb RustBufferI) TimelineFilter {
	return LiftFromRustBuffer[TimelineFilter](c, rb)
}

func (c FfiConverterTimelineFilter) Lower(value TimelineFilter) C.RustBuffer {
	return LowerIntoRustBuffer[TimelineFilter](c, value)
}
func (FfiConverterTimelineFilter) Read(reader io.Reader) TimelineFilter {
	id := readInt32(reader)
	switch id {
	case 1:
		return TimelineFilterAll{}
	case 2:
		return TimelineFilterOnlyMessage{
			FfiConverterSequenceRoomMessageEventMessageTypeINSTANCE.Read(reader),
		}
	case 3:
		return TimelineFilterEventTypeFilter{
			FfiConverterTimelineEventTypeFilterINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterTimelineFilter.Read()", id))
	}
}

func (FfiConverterTimelineFilter) Write(writer io.Writer, value TimelineFilter) {
	switch variant_value := value.(type) {
	case TimelineFilterAll:
		writeInt32(writer, 1)
	case TimelineFilterOnlyMessage:
		writeInt32(writer, 2)
		FfiConverterSequenceRoomMessageEventMessageTypeINSTANCE.Write(writer, variant_value.Types)
	case TimelineFilterEventTypeFilter:
		writeInt32(writer, 3)
		FfiConverterTimelineEventTypeFilterINSTANCE.Write(writer, variant_value.Filter)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterTimelineFilter.Write", value))
	}
}

type FfiDestroyerTimelineFilter struct{}

func (_ FfiDestroyerTimelineFilter) Destroy(value TimelineFilter) {
	value.Destroy()
}

type TimelineFocus interface {
	Destroy()
}
type TimelineFocusLive struct {
}

func (e TimelineFocusLive) Destroy() {
}

type TimelineFocusEvent struct {
	EventId          string
	NumContextEvents uint16
}

func (e TimelineFocusEvent) Destroy() {
	FfiDestroyerString{}.Destroy(e.EventId)
	FfiDestroyerUint16{}.Destroy(e.NumContextEvents)
}

type TimelineFocusThread struct {
	RootEventId string
	NumEvents   uint16
}

func (e TimelineFocusThread) Destroy() {
	FfiDestroyerString{}.Destroy(e.RootEventId)
	FfiDestroyerUint16{}.Destroy(e.NumEvents)
}

type TimelineFocusPinnedEvents struct {
	MaxEventsToLoad       uint16
	MaxConcurrentRequests uint16
}

func (e TimelineFocusPinnedEvents) Destroy() {
	FfiDestroyerUint16{}.Destroy(e.MaxEventsToLoad)
	FfiDestroyerUint16{}.Destroy(e.MaxConcurrentRequests)
}

type FfiConverterTimelineFocus struct{}

var FfiConverterTimelineFocusINSTANCE = FfiConverterTimelineFocus{}

func (c FfiConverterTimelineFocus) Lift(rb RustBufferI) TimelineFocus {
	return LiftFromRustBuffer[TimelineFocus](c, rb)
}

func (c FfiConverterTimelineFocus) Lower(value TimelineFocus) C.RustBuffer {
	return LowerIntoRustBuffer[TimelineFocus](c, value)
}
func (FfiConverterTimelineFocus) Read(reader io.Reader) TimelineFocus {
	id := readInt32(reader)
	switch id {
	case 1:
		return TimelineFocusLive{}
	case 2:
		return TimelineFocusEvent{
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterUint16INSTANCE.Read(reader),
		}
	case 3:
		return TimelineFocusThread{
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterUint16INSTANCE.Read(reader),
		}
	case 4:
		return TimelineFocusPinnedEvents{
			FfiConverterUint16INSTANCE.Read(reader),
			FfiConverterUint16INSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterTimelineFocus.Read()", id))
	}
}

func (FfiConverterTimelineFocus) Write(writer io.Writer, value TimelineFocus) {
	switch variant_value := value.(type) {
	case TimelineFocusLive:
		writeInt32(writer, 1)
	case TimelineFocusEvent:
		writeInt32(writer, 2)
		FfiConverterStringINSTANCE.Write(writer, variant_value.EventId)
		FfiConverterUint16INSTANCE.Write(writer, variant_value.NumContextEvents)
	case TimelineFocusThread:
		writeInt32(writer, 3)
		FfiConverterStringINSTANCE.Write(writer, variant_value.RootEventId)
		FfiConverterUint16INSTANCE.Write(writer, variant_value.NumEvents)
	case TimelineFocusPinnedEvents:
		writeInt32(writer, 4)
		FfiConverterUint16INSTANCE.Write(writer, variant_value.MaxEventsToLoad)
		FfiConverterUint16INSTANCE.Write(writer, variant_value.MaxConcurrentRequests)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterTimelineFocus.Write", value))
	}
}

type FfiDestroyerTimelineFocus struct{}

func (_ FfiDestroyerTimelineFocus) Destroy(value TimelineFocus) {
	value.Destroy()
}

type TimelineItemContent interface {
	Destroy()
}
type TimelineItemContentMsgLike struct {
	Content MsgLikeContent
}

func (e TimelineItemContentMsgLike) Destroy() {
	FfiDestroyerMsgLikeContent{}.Destroy(e.Content)
}

type TimelineItemContentCallInvite struct {
}

func (e TimelineItemContentCallInvite) Destroy() {
}

type TimelineItemContentCallNotify struct {
}

func (e TimelineItemContentCallNotify) Destroy() {
}

type TimelineItemContentRoomMembership struct {
	UserId          string
	UserDisplayName *string
	Change          *MembershipChange
	Reason          *string
}

func (e TimelineItemContentRoomMembership) Destroy() {
	FfiDestroyerString{}.Destroy(e.UserId)
	FfiDestroyerOptionalString{}.Destroy(e.UserDisplayName)
	FfiDestroyerOptionalMembershipChange{}.Destroy(e.Change)
	FfiDestroyerOptionalString{}.Destroy(e.Reason)
}

type TimelineItemContentProfileChange struct {
	DisplayName     *string
	PrevDisplayName *string
	AvatarUrl       *string
	PrevAvatarUrl   *string
}

func (e TimelineItemContentProfileChange) Destroy() {
	FfiDestroyerOptionalString{}.Destroy(e.DisplayName)
	FfiDestroyerOptionalString{}.Destroy(e.PrevDisplayName)
	FfiDestroyerOptionalString{}.Destroy(e.AvatarUrl)
	FfiDestroyerOptionalString{}.Destroy(e.PrevAvatarUrl)
}

type TimelineItemContentState struct {
	StateKey string
	Content  OtherState
}

func (e TimelineItemContentState) Destroy() {
	FfiDestroyerString{}.Destroy(e.StateKey)
	FfiDestroyerOtherState{}.Destroy(e.Content)
}

type TimelineItemContentFailedToParseMessageLike struct {
	EventType string
	Error     string
}

func (e TimelineItemContentFailedToParseMessageLike) Destroy() {
	FfiDestroyerString{}.Destroy(e.EventType)
	FfiDestroyerString{}.Destroy(e.Error)
}

type TimelineItemContentFailedToParseState struct {
	EventType string
	StateKey  string
	Error     string
}

func (e TimelineItemContentFailedToParseState) Destroy() {
	FfiDestroyerString{}.Destroy(e.EventType)
	FfiDestroyerString{}.Destroy(e.StateKey)
	FfiDestroyerString{}.Destroy(e.Error)
}

type FfiConverterTimelineItemContent struct{}

var FfiConverterTimelineItemContentINSTANCE = FfiConverterTimelineItemContent{}

func (c FfiConverterTimelineItemContent) Lift(rb RustBufferI) TimelineItemContent {
	return LiftFromRustBuffer[TimelineItemContent](c, rb)
}

func (c FfiConverterTimelineItemContent) Lower(value TimelineItemContent) C.RustBuffer {
	return LowerIntoRustBuffer[TimelineItemContent](c, value)
}
func (FfiConverterTimelineItemContent) Read(reader io.Reader) TimelineItemContent {
	id := readInt32(reader)
	switch id {
	case 1:
		return TimelineItemContentMsgLike{
			FfiConverterMsgLikeContentINSTANCE.Read(reader),
		}
	case 2:
		return TimelineItemContentCallInvite{}
	case 3:
		return TimelineItemContentCallNotify{}
	case 4:
		return TimelineItemContentRoomMembership{
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalMembershipChangeINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
		}
	case 5:
		return TimelineItemContentProfileChange{
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
			FfiConverterOptionalStringINSTANCE.Read(reader),
		}
	case 6:
		return TimelineItemContentState{
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterOtherStateINSTANCE.Read(reader),
		}
	case 7:
		return TimelineItemContentFailedToParseMessageLike{
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 8:
		return TimelineItemContentFailedToParseState{
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterTimelineItemContent.Read()", id))
	}
}

func (FfiConverterTimelineItemContent) Write(writer io.Writer, value TimelineItemContent) {
	switch variant_value := value.(type) {
	case TimelineItemContentMsgLike:
		writeInt32(writer, 1)
		FfiConverterMsgLikeContentINSTANCE.Write(writer, variant_value.Content)
	case TimelineItemContentCallInvite:
		writeInt32(writer, 2)
	case TimelineItemContentCallNotify:
		writeInt32(writer, 3)
	case TimelineItemContentRoomMembership:
		writeInt32(writer, 4)
		FfiConverterStringINSTANCE.Write(writer, variant_value.UserId)
		FfiConverterOptionalStringINSTANCE.Write(writer, variant_value.UserDisplayName)
		FfiConverterOptionalMembershipChangeINSTANCE.Write(writer, variant_value.Change)
		FfiConverterOptionalStringINSTANCE.Write(writer, variant_value.Reason)
	case TimelineItemContentProfileChange:
		writeInt32(writer, 5)
		FfiConverterOptionalStringINSTANCE.Write(writer, variant_value.DisplayName)
		FfiConverterOptionalStringINSTANCE.Write(writer, variant_value.PrevDisplayName)
		FfiConverterOptionalStringINSTANCE.Write(writer, variant_value.AvatarUrl)
		FfiConverterOptionalStringINSTANCE.Write(writer, variant_value.PrevAvatarUrl)
	case TimelineItemContentState:
		writeInt32(writer, 6)
		FfiConverterStringINSTANCE.Write(writer, variant_value.StateKey)
		FfiConverterOtherStateINSTANCE.Write(writer, variant_value.Content)
	case TimelineItemContentFailedToParseMessageLike:
		writeInt32(writer, 7)
		FfiConverterStringINSTANCE.Write(writer, variant_value.EventType)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Error)
	case TimelineItemContentFailedToParseState:
		writeInt32(writer, 8)
		FfiConverterStringINSTANCE.Write(writer, variant_value.EventType)
		FfiConverterStringINSTANCE.Write(writer, variant_value.StateKey)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Error)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterTimelineItemContent.Write", value))
	}
}

type FfiDestroyerTimelineItemContent struct{}

func (_ FfiDestroyerTimelineItemContent) Destroy(value TimelineItemContent) {
	value.Destroy()
}

// A log pack can be used to set the trace log level for a group of multiple
// log targets at once, for debugging purposes.
type TraceLogPacks uint

const (
	// Enables all the logs relevant to the event cache.
	TraceLogPacksEventCache TraceLogPacks = 1
	// Enables all the logs relevant to the send queue.
	TraceLogPacksSendQueue TraceLogPacks = 2
	// Enables all the logs relevant to the timeline.
	TraceLogPacksTimeline TraceLogPacks = 3
)

type FfiConverterTraceLogPacks struct{}

var FfiConverterTraceLogPacksINSTANCE = FfiConverterTraceLogPacks{}

func (c FfiConverterTraceLogPacks) Lift(rb RustBufferI) TraceLogPacks {
	return LiftFromRustBuffer[TraceLogPacks](c, rb)
}

func (c FfiConverterTraceLogPacks) Lower(value TraceLogPacks) C.RustBuffer {
	return LowerIntoRustBuffer[TraceLogPacks](c, value)
}
func (FfiConverterTraceLogPacks) Read(reader io.Reader) TraceLogPacks {
	id := readInt32(reader)
	return TraceLogPacks(id)
}

func (FfiConverterTraceLogPacks) Write(writer io.Writer, value TraceLogPacks) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerTraceLogPacks struct{}

func (_ FfiDestroyerTraceLogPacks) Destroy(value TraceLogPacks) {
}

// Enum representing the push notification tweaks for a rule.
type Tweak interface {
	Destroy()
}

// A string representing the sound to be played when this notification
// arrives.
//
// A value of "default" means to play a default sound. A device may choose
// to alert the user by some other means if appropriate, eg. vibration.
type TweakSound struct {
	Value string
}

func (e TweakSound) Destroy() {
	FfiDestroyerString{}.Destroy(e.Value)
}

// A boolean representing whether or not this message should be highlighted
// in the UI.
type TweakHighlight struct {
	Value bool
}

func (e TweakHighlight) Destroy() {
	FfiDestroyerBool{}.Destroy(e.Value)
}

// A custom tweak
type TweakCustom struct {
	Name  string
	Value string
}

func (e TweakCustom) Destroy() {
	FfiDestroyerString{}.Destroy(e.Name)
	FfiDestroyerString{}.Destroy(e.Value)
}

type FfiConverterTweak struct{}

var FfiConverterTweakINSTANCE = FfiConverterTweak{}

func (c FfiConverterTweak) Lift(rb RustBufferI) Tweak {
	return LiftFromRustBuffer[Tweak](c, rb)
}

func (c FfiConverterTweak) Lower(value Tweak) C.RustBuffer {
	return LowerIntoRustBuffer[Tweak](c, value)
}
func (FfiConverterTweak) Read(reader io.Reader) Tweak {
	id := readInt32(reader)
	switch id {
	case 1:
		return TweakSound{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 2:
		return TweakHighlight{
			FfiConverterBoolINSTANCE.Read(reader),
		}
	case 3:
		return TweakCustom{
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterTweak.Read()", id))
	}
}

func (FfiConverterTweak) Write(writer io.Writer, value Tweak) {
	switch variant_value := value.(type) {
	case TweakSound:
		writeInt32(writer, 1)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Value)
	case TweakHighlight:
		writeInt32(writer, 2)
		FfiConverterBoolINSTANCE.Write(writer, variant_value.Value)
	case TweakCustom:
		writeInt32(writer, 3)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Name)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Value)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterTweak.Write", value))
	}
}

type FfiDestroyerTweak struct{}

func (_ FfiDestroyerTweak) Destroy(value Tweak) {
	value.Destroy()
}

// A source for uploading a file
type UploadSource interface {
	Destroy()
}

// Upload source is a file on disk
type UploadSourceFile struct {
	Filename string
}

func (e UploadSourceFile) Destroy() {
	FfiDestroyerString{}.Destroy(e.Filename)
}

// Upload source is data in memory
type UploadSourceData struct {
	Bytes    []byte
	Filename string
}

func (e UploadSourceData) Destroy() {
	FfiDestroyerBytes{}.Destroy(e.Bytes)
	FfiDestroyerString{}.Destroy(e.Filename)
}

type FfiConverterUploadSource struct{}

var FfiConverterUploadSourceINSTANCE = FfiConverterUploadSource{}

func (c FfiConverterUploadSource) Lift(rb RustBufferI) UploadSource {
	return LiftFromRustBuffer[UploadSource](c, rb)
}

func (c FfiConverterUploadSource) Lower(value UploadSource) C.RustBuffer {
	return LowerIntoRustBuffer[UploadSource](c, value)
}
func (FfiConverterUploadSource) Read(reader io.Reader) UploadSource {
	id := readInt32(reader)
	switch id {
	case 1:
		return UploadSourceFile{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 2:
		return UploadSourceData{
			FfiConverterBytesINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterUploadSource.Read()", id))
	}
}

func (FfiConverterUploadSource) Write(writer io.Writer, value UploadSource) {
	switch variant_value := value.(type) {
	case UploadSourceFile:
		writeInt32(writer, 1)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Filename)
	case UploadSourceData:
		writeInt32(writer, 2)
		FfiConverterBytesINSTANCE.Write(writer, variant_value.Bytes)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Filename)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterUploadSource.Write", value))
	}
}

type FfiDestroyerUploadSource struct{}

func (_ FfiDestroyerUploadSource) Destroy(value UploadSource) {
	value.Destroy()
}

type VerificationState uint

const (
	VerificationStateUnknown    VerificationState = 1
	VerificationStateVerified   VerificationState = 2
	VerificationStateUnverified VerificationState = 3
)

type FfiConverterVerificationState struct{}

var FfiConverterVerificationStateINSTANCE = FfiConverterVerificationState{}

func (c FfiConverterVerificationState) Lift(rb RustBufferI) VerificationState {
	return LiftFromRustBuffer[VerificationState](c, rb)
}

func (c FfiConverterVerificationState) Lower(value VerificationState) C.RustBuffer {
	return LowerIntoRustBuffer[VerificationState](c, value)
}
func (FfiConverterVerificationState) Read(reader io.Reader) VerificationState {
	id := readInt32(reader)
	return VerificationState(id)
}

func (FfiConverterVerificationState) Write(writer io.Writer, value VerificationState) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerVerificationState struct{}

func (_ FfiDestroyerVerificationState) Destroy(value VerificationState) {
}

// A [`TimelineItem`](super::TimelineItem) that doesn't correspond to an event.
type VirtualTimelineItem interface {
	Destroy()
}

// A divider between messages of different day or month depending on
// timeline settings.
type VirtualTimelineItemDateDivider struct {
	Ts Timestamp
}

func (e VirtualTimelineItemDateDivider) Destroy() {
	FfiDestroyerTypeTimestamp{}.Destroy(e.Ts)
}

// The user's own read marker.
type VirtualTimelineItemReadMarker struct {
}

func (e VirtualTimelineItemReadMarker) Destroy() {
}

// The timeline start, that is, the *oldest* event in time for that room.
type VirtualTimelineItemTimelineStart struct {
}

func (e VirtualTimelineItemTimelineStart) Destroy() {
}

type FfiConverterVirtualTimelineItem struct{}

var FfiConverterVirtualTimelineItemINSTANCE = FfiConverterVirtualTimelineItem{}

func (c FfiConverterVirtualTimelineItem) Lift(rb RustBufferI) VirtualTimelineItem {
	return LiftFromRustBuffer[VirtualTimelineItem](c, rb)
}

func (c FfiConverterVirtualTimelineItem) Lower(value VirtualTimelineItem) C.RustBuffer {
	return LowerIntoRustBuffer[VirtualTimelineItem](c, value)
}
func (FfiConverterVirtualTimelineItem) Read(reader io.Reader) VirtualTimelineItem {
	id := readInt32(reader)
	switch id {
	case 1:
		return VirtualTimelineItemDateDivider{
			FfiConverterTypeTimestampINSTANCE.Read(reader),
		}
	case 2:
		return VirtualTimelineItemReadMarker{}
	case 3:
		return VirtualTimelineItemTimelineStart{}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterVirtualTimelineItem.Read()", id))
	}
}

func (FfiConverterVirtualTimelineItem) Write(writer io.Writer, value VirtualTimelineItem) {
	switch variant_value := value.(type) {
	case VirtualTimelineItemDateDivider:
		writeInt32(writer, 1)
		FfiConverterTypeTimestampINSTANCE.Write(writer, variant_value.Ts)
	case VirtualTimelineItemReadMarker:
		writeInt32(writer, 2)
	case VirtualTimelineItemTimelineStart:
		writeInt32(writer, 3)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterVirtualTimelineItem.Write", value))
	}
}

type FfiDestroyerVirtualTimelineItem struct{}

func (_ FfiDestroyerVirtualTimelineItem) Destroy(value VirtualTimelineItem) {
	value.Destroy()
}

// Different kinds of filters that could be applied to the timeline events.
type WidgetEventFilter interface {
	Destroy()
}

// Matches message-like events with the given `type`.
type WidgetEventFilterMessageLikeWithType struct {
	EventType string
}

func (e WidgetEventFilterMessageLikeWithType) Destroy() {
	FfiDestroyerString{}.Destroy(e.EventType)
}

// Matches `m.room.message` events with the given `msgtype`.
type WidgetEventFilterRoomMessageWithMsgtype struct {
	Msgtype string
}

func (e WidgetEventFilterRoomMessageWithMsgtype) Destroy() {
	FfiDestroyerString{}.Destroy(e.Msgtype)
}

// Matches state events with the given `type`, regardless of `state_key`.
type WidgetEventFilterStateWithType struct {
	EventType string
}

func (e WidgetEventFilterStateWithType) Destroy() {
	FfiDestroyerString{}.Destroy(e.EventType)
}

// Matches state events with the given `type` and `state_key`.
type WidgetEventFilterStateWithTypeAndStateKey struct {
	EventType string
	StateKey  string
}

func (e WidgetEventFilterStateWithTypeAndStateKey) Destroy() {
	FfiDestroyerString{}.Destroy(e.EventType)
	FfiDestroyerString{}.Destroy(e.StateKey)
}

type FfiConverterWidgetEventFilter struct{}

var FfiConverterWidgetEventFilterINSTANCE = FfiConverterWidgetEventFilter{}

func (c FfiConverterWidgetEventFilter) Lift(rb RustBufferI) WidgetEventFilter {
	return LiftFromRustBuffer[WidgetEventFilter](c, rb)
}

func (c FfiConverterWidgetEventFilter) Lower(value WidgetEventFilter) C.RustBuffer {
	return LowerIntoRustBuffer[WidgetEventFilter](c, value)
}
func (FfiConverterWidgetEventFilter) Read(reader io.Reader) WidgetEventFilter {
	id := readInt32(reader)
	switch id {
	case 1:
		return WidgetEventFilterMessageLikeWithType{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 2:
		return WidgetEventFilterRoomMessageWithMsgtype{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 3:
		return WidgetEventFilterStateWithType{
			FfiConverterStringINSTANCE.Read(reader),
		}
	case 4:
		return WidgetEventFilterStateWithTypeAndStateKey{
			FfiConverterStringINSTANCE.Read(reader),
			FfiConverterStringINSTANCE.Read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterWidgetEventFilter.Read()", id))
	}
}

func (FfiConverterWidgetEventFilter) Write(writer io.Writer, value WidgetEventFilter) {
	switch variant_value := value.(type) {
	case WidgetEventFilterMessageLikeWithType:
		writeInt32(writer, 1)
		FfiConverterStringINSTANCE.Write(writer, variant_value.EventType)
	case WidgetEventFilterRoomMessageWithMsgtype:
		writeInt32(writer, 2)
		FfiConverterStringINSTANCE.Write(writer, variant_value.Msgtype)
	case WidgetEventFilterStateWithType:
		writeInt32(writer, 3)
		FfiConverterStringINSTANCE.Write(writer, variant_value.EventType)
	case WidgetEventFilterStateWithTypeAndStateKey:
		writeInt32(writer, 4)
		FfiConverterStringINSTANCE.Write(writer, variant_value.EventType)
		FfiConverterStringINSTANCE.Write(writer, variant_value.StateKey)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterWidgetEventFilter.Write", value))
	}
}

type FfiDestroyerWidgetEventFilter struct{}

func (_ FfiDestroyerWidgetEventFilter) Destroy(value WidgetEventFilter) {
	value.Destroy()
}

// A listener for changes of global account data events.
type AccountDataListener interface {

	// Called when a global account data event has changed.
	OnChange(event AccountDataEvent)
}

type FfiConverterCallbackInterfaceAccountDataListener struct {
	handleMap *concurrentHandleMap[AccountDataListener]
}

var FfiConverterCallbackInterfaceAccountDataListenerINSTANCE = FfiConverterCallbackInterfaceAccountDataListener{
	handleMap: newConcurrentHandleMap[AccountDataListener](),
}

func (c FfiConverterCallbackInterfaceAccountDataListener) Lift(handle uint64) AccountDataListener {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceAccountDataListener) Read(reader io.Reader) AccountDataListener {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceAccountDataListener) Lower(value AccountDataListener) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceAccountDataListener) Write(writer io.Writer, value AccountDataListener) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceAccountDataListener struct{}

func (FfiDestroyerCallbackInterfaceAccountDataListener) Destroy(value AccountDataListener) {}

type uniffiCallbackResult C.int8_t

const (
	uniffiIdxCallbackFree               uniffiCallbackResult = 0
	uniffiCallbackResultSuccess         uniffiCallbackResult = 0
	uniffiCallbackResultError           uniffiCallbackResult = 1
	uniffiCallbackUnexpectedResultError uniffiCallbackResult = 2
	uniffiCallbackCancelled             uniffiCallbackResult = 3
)

type concurrentHandleMap[T any] struct {
	handles       map[uint64]T
	currentHandle uint64
	lock          sync.RWMutex
}

func newConcurrentHandleMap[T any]() *concurrentHandleMap[T] {
	return &concurrentHandleMap[T]{
		handles: map[uint64]T{},
	}
}

func (cm *concurrentHandleMap[T]) insert(obj T) uint64 {
	cm.lock.Lock()
	defer cm.lock.Unlock()

	cm.currentHandle = cm.currentHandle + 1
	cm.handles[cm.currentHandle] = obj
	return cm.currentHandle
}

func (cm *concurrentHandleMap[T]) remove(handle uint64) {
	cm.lock.Lock()
	defer cm.lock.Unlock()

	delete(cm.handles, handle)
}

func (cm *concurrentHandleMap[T]) tryGet(handle uint64) (T, bool) {
	cm.lock.RLock()
	defer cm.lock.RUnlock()

	val, ok := cm.handles[handle]
	return val, ok
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceAccountDataListenerMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceAccountDataListenerMethod0(uniffiHandle C.uint64_t, event C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceAccountDataListenerINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.OnChange(
		FfiConverterAccountDataEventINSTANCE.Lift(GoRustBuffer{
			inner: event,
		}),
	)

}

var UniffiVTableCallbackInterfaceAccountDataListenerINSTANCE = C.UniffiVTableCallbackInterfaceAccountDataListener{
	onChange: (C.UniffiCallbackInterfaceAccountDataListenerMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceAccountDataListenerMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceAccountDataListenerFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceAccountDataListenerFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceAccountDataListenerFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceAccountDataListenerINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceAccountDataListener) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_accountdatalistener(&UniffiVTableCallbackInterfaceAccountDataListenerINSTANCE)
}

type BackupStateListener interface {
	OnUpdate(status BackupState)
}

type FfiConverterCallbackInterfaceBackupStateListener struct {
	handleMap *concurrentHandleMap[BackupStateListener]
}

var FfiConverterCallbackInterfaceBackupStateListenerINSTANCE = FfiConverterCallbackInterfaceBackupStateListener{
	handleMap: newConcurrentHandleMap[BackupStateListener](),
}

func (c FfiConverterCallbackInterfaceBackupStateListener) Lift(handle uint64) BackupStateListener {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceBackupStateListener) Read(reader io.Reader) BackupStateListener {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceBackupStateListener) Lower(value BackupStateListener) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceBackupStateListener) Write(writer io.Writer, value BackupStateListener) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceBackupStateListener struct{}

func (FfiDestroyerCallbackInterfaceBackupStateListener) Destroy(value BackupStateListener) {}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceBackupStateListenerMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceBackupStateListenerMethod0(uniffiHandle C.uint64_t, status C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceBackupStateListenerINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.OnUpdate(
		FfiConverterBackupStateINSTANCE.Lift(GoRustBuffer{
			inner: status,
		}),
	)

}

var UniffiVTableCallbackInterfaceBackupStateListenerINSTANCE = C.UniffiVTableCallbackInterfaceBackupStateListener{
	onUpdate: (C.UniffiCallbackInterfaceBackupStateListenerMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceBackupStateListenerMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceBackupStateListenerFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceBackupStateListenerFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceBackupStateListenerFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceBackupStateListenerINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceBackupStateListener) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_backupstatelistener(&UniffiVTableCallbackInterfaceBackupStateListenerINSTANCE)
}

type BackupSteadyStateListener interface {
	OnUpdate(status BackupUploadState)
}

type FfiConverterCallbackInterfaceBackupSteadyStateListener struct {
	handleMap *concurrentHandleMap[BackupSteadyStateListener]
}

var FfiConverterCallbackInterfaceBackupSteadyStateListenerINSTANCE = FfiConverterCallbackInterfaceBackupSteadyStateListener{
	handleMap: newConcurrentHandleMap[BackupSteadyStateListener](),
}

func (c FfiConverterCallbackInterfaceBackupSteadyStateListener) Lift(handle uint64) BackupSteadyStateListener {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceBackupSteadyStateListener) Read(reader io.Reader) BackupSteadyStateListener {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceBackupSteadyStateListener) Lower(value BackupSteadyStateListener) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceBackupSteadyStateListener) Write(writer io.Writer, value BackupSteadyStateListener) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceBackupSteadyStateListener struct{}

func (FfiDestroyerCallbackInterfaceBackupSteadyStateListener) Destroy(value BackupSteadyStateListener) {
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceBackupSteadyStateListenerMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceBackupSteadyStateListenerMethod0(uniffiHandle C.uint64_t, status C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceBackupSteadyStateListenerINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.OnUpdate(
		FfiConverterBackupUploadStateINSTANCE.Lift(GoRustBuffer{
			inner: status,
		}),
	)

}

var UniffiVTableCallbackInterfaceBackupSteadyStateListenerINSTANCE = C.UniffiVTableCallbackInterfaceBackupSteadyStateListener{
	onUpdate: (C.UniffiCallbackInterfaceBackupSteadyStateListenerMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceBackupSteadyStateListenerMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceBackupSteadyStateListenerFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceBackupSteadyStateListenerFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceBackupSteadyStateListenerFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceBackupSteadyStateListenerINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceBackupSteadyStateListener) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_backupsteadystatelistener(&UniffiVTableCallbackInterfaceBackupSteadyStateListenerINSTANCE)
}

type ClientDelegate interface {
	DidReceiveAuthError(isSoftLogout bool)
}

type FfiConverterCallbackInterfaceClientDelegate struct {
	handleMap *concurrentHandleMap[ClientDelegate]
}

var FfiConverterCallbackInterfaceClientDelegateINSTANCE = FfiConverterCallbackInterfaceClientDelegate{
	handleMap: newConcurrentHandleMap[ClientDelegate](),
}

func (c FfiConverterCallbackInterfaceClientDelegate) Lift(handle uint64) ClientDelegate {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceClientDelegate) Read(reader io.Reader) ClientDelegate {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceClientDelegate) Lower(value ClientDelegate) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceClientDelegate) Write(writer io.Writer, value ClientDelegate) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceClientDelegate struct{}

func (FfiDestroyerCallbackInterfaceClientDelegate) Destroy(value ClientDelegate) {}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceClientDelegateMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceClientDelegateMethod0(uniffiHandle C.uint64_t, isSoftLogout C.int8_t, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceClientDelegateINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.DidReceiveAuthError(
		FfiConverterBoolINSTANCE.Lift(isSoftLogout),
	)

}

var UniffiVTableCallbackInterfaceClientDelegateINSTANCE = C.UniffiVTableCallbackInterfaceClientDelegate{
	didReceiveAuthError: (C.UniffiCallbackInterfaceClientDelegateMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceClientDelegateMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceClientDelegateFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceClientDelegateFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceClientDelegateFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceClientDelegateINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceClientDelegate) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_clientdelegate(&UniffiVTableCallbackInterfaceClientDelegateINSTANCE)
}

type ClientSessionDelegate interface {
	RetrieveSessionFromKeychain(userId string) (Session, error)

	SaveSessionInKeychain(session Session)
}

type FfiConverterCallbackInterfaceClientSessionDelegate struct {
	handleMap *concurrentHandleMap[ClientSessionDelegate]
}

var FfiConverterCallbackInterfaceClientSessionDelegateINSTANCE = FfiConverterCallbackInterfaceClientSessionDelegate{
	handleMap: newConcurrentHandleMap[ClientSessionDelegate](),
}

func (c FfiConverterCallbackInterfaceClientSessionDelegate) Lift(handle uint64) ClientSessionDelegate {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceClientSessionDelegate) Read(reader io.Reader) ClientSessionDelegate {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceClientSessionDelegate) Lower(value ClientSessionDelegate) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceClientSessionDelegate) Write(writer io.Writer, value ClientSessionDelegate) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceClientSessionDelegate struct{}

func (FfiDestroyerCallbackInterfaceClientSessionDelegate) Destroy(value ClientSessionDelegate) {}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceClientSessionDelegateMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceClientSessionDelegateMethod0(uniffiHandle C.uint64_t, userId C.RustBuffer, uniffiOutReturn *C.RustBuffer, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceClientSessionDelegateINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	res, err :=
		uniffiObj.RetrieveSessionFromKeychain(
			FfiConverterStringINSTANCE.Lift(GoRustBuffer{
				inner: userId,
			}),
		)

	if err != nil {
		var actualError *ClientError
		if errors.As(err, &actualError) {
			*callStatus = C.RustCallStatus{
				code:     C.int8_t(uniffiCallbackResultError),
				errorBuf: FfiConverterClientErrorINSTANCE.Lower(actualError),
			}
		} else {
			*callStatus = C.RustCallStatus{
				code: C.int8_t(uniffiCallbackUnexpectedResultError),
			}
		}
		return
	}

	*uniffiOutReturn = FfiConverterSessionINSTANCE.Lower(res)
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceClientSessionDelegateMethod1
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceClientSessionDelegateMethod1(uniffiHandle C.uint64_t, session C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceClientSessionDelegateINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.SaveSessionInKeychain(
		FfiConverterSessionINSTANCE.Lift(GoRustBuffer{
			inner: session,
		}),
	)

}

var UniffiVTableCallbackInterfaceClientSessionDelegateINSTANCE = C.UniffiVTableCallbackInterfaceClientSessionDelegate{
	retrieveSessionFromKeychain: (C.UniffiCallbackInterfaceClientSessionDelegateMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceClientSessionDelegateMethod0),
	saveSessionInKeychain:       (C.UniffiCallbackInterfaceClientSessionDelegateMethod1)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceClientSessionDelegateMethod1),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceClientSessionDelegateFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceClientSessionDelegateFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceClientSessionDelegateFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceClientSessionDelegateINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceClientSessionDelegate) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_clientsessiondelegate(&UniffiVTableCallbackInterfaceClientSessionDelegateINSTANCE)
}

type EnableRecoveryProgressListener interface {
	OnUpdate(status EnableRecoveryProgress)
}

type FfiConverterCallbackInterfaceEnableRecoveryProgressListener struct {
	handleMap *concurrentHandleMap[EnableRecoveryProgressListener]
}

var FfiConverterCallbackInterfaceEnableRecoveryProgressListenerINSTANCE = FfiConverterCallbackInterfaceEnableRecoveryProgressListener{
	handleMap: newConcurrentHandleMap[EnableRecoveryProgressListener](),
}

func (c FfiConverterCallbackInterfaceEnableRecoveryProgressListener) Lift(handle uint64) EnableRecoveryProgressListener {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceEnableRecoveryProgressListener) Read(reader io.Reader) EnableRecoveryProgressListener {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceEnableRecoveryProgressListener) Lower(value EnableRecoveryProgressListener) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceEnableRecoveryProgressListener) Write(writer io.Writer, value EnableRecoveryProgressListener) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceEnableRecoveryProgressListener struct{}

func (FfiDestroyerCallbackInterfaceEnableRecoveryProgressListener) Destroy(value EnableRecoveryProgressListener) {
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceEnableRecoveryProgressListenerMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceEnableRecoveryProgressListenerMethod0(uniffiHandle C.uint64_t, status C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceEnableRecoveryProgressListenerINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.OnUpdate(
		FfiConverterEnableRecoveryProgressINSTANCE.Lift(GoRustBuffer{
			inner: status,
		}),
	)

}

var UniffiVTableCallbackInterfaceEnableRecoveryProgressListenerINSTANCE = C.UniffiVTableCallbackInterfaceEnableRecoveryProgressListener{
	onUpdate: (C.UniffiCallbackInterfaceEnableRecoveryProgressListenerMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceEnableRecoveryProgressListenerMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceEnableRecoveryProgressListenerFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceEnableRecoveryProgressListenerFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceEnableRecoveryProgressListenerFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceEnableRecoveryProgressListenerINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceEnableRecoveryProgressListener) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_enablerecoveryprogresslistener(&UniffiVTableCallbackInterfaceEnableRecoveryProgressListenerINSTANCE)
}

type IdentityStatusChangeListener interface {
	Call(identityStatusChange []IdentityStatusChange)
}

type FfiConverterCallbackInterfaceIdentityStatusChangeListener struct {
	handleMap *concurrentHandleMap[IdentityStatusChangeListener]
}

var FfiConverterCallbackInterfaceIdentityStatusChangeListenerINSTANCE = FfiConverterCallbackInterfaceIdentityStatusChangeListener{
	handleMap: newConcurrentHandleMap[IdentityStatusChangeListener](),
}

func (c FfiConverterCallbackInterfaceIdentityStatusChangeListener) Lift(handle uint64) IdentityStatusChangeListener {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceIdentityStatusChangeListener) Read(reader io.Reader) IdentityStatusChangeListener {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceIdentityStatusChangeListener) Lower(value IdentityStatusChangeListener) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceIdentityStatusChangeListener) Write(writer io.Writer, value IdentityStatusChangeListener) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceIdentityStatusChangeListener struct{}

func (FfiDestroyerCallbackInterfaceIdentityStatusChangeListener) Destroy(value IdentityStatusChangeListener) {
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceIdentityStatusChangeListenerMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceIdentityStatusChangeListenerMethod0(uniffiHandle C.uint64_t, identityStatusChange C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceIdentityStatusChangeListenerINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.Call(
		FfiConverterSequenceIdentityStatusChangeINSTANCE.Lift(GoRustBuffer{
			inner: identityStatusChange,
		}),
	)

}

var UniffiVTableCallbackInterfaceIdentityStatusChangeListenerINSTANCE = C.UniffiVTableCallbackInterfaceIdentityStatusChangeListener{
	call: (C.UniffiCallbackInterfaceIdentityStatusChangeListenerMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceIdentityStatusChangeListenerMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceIdentityStatusChangeListenerFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceIdentityStatusChangeListenerFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceIdentityStatusChangeListenerFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceIdentityStatusChangeListenerINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceIdentityStatusChangeListener) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_identitystatuschangelistener(&UniffiVTableCallbackInterfaceIdentityStatusChangeListenerINSTANCE)
}

type IgnoredUsersListener interface {
	Call(ignoredUserIds []string)
}

type FfiConverterCallbackInterfaceIgnoredUsersListener struct {
	handleMap *concurrentHandleMap[IgnoredUsersListener]
}

var FfiConverterCallbackInterfaceIgnoredUsersListenerINSTANCE = FfiConverterCallbackInterfaceIgnoredUsersListener{
	handleMap: newConcurrentHandleMap[IgnoredUsersListener](),
}

func (c FfiConverterCallbackInterfaceIgnoredUsersListener) Lift(handle uint64) IgnoredUsersListener {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceIgnoredUsersListener) Read(reader io.Reader) IgnoredUsersListener {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceIgnoredUsersListener) Lower(value IgnoredUsersListener) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceIgnoredUsersListener) Write(writer io.Writer, value IgnoredUsersListener) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceIgnoredUsersListener struct{}

func (FfiDestroyerCallbackInterfaceIgnoredUsersListener) Destroy(value IgnoredUsersListener) {}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceIgnoredUsersListenerMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceIgnoredUsersListenerMethod0(uniffiHandle C.uint64_t, ignoredUserIds C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceIgnoredUsersListenerINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.Call(
		FfiConverterSequenceStringINSTANCE.Lift(GoRustBuffer{
			inner: ignoredUserIds,
		}),
	)

}

var UniffiVTableCallbackInterfaceIgnoredUsersListenerINSTANCE = C.UniffiVTableCallbackInterfaceIgnoredUsersListener{
	call: (C.UniffiCallbackInterfaceIgnoredUsersListenerMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceIgnoredUsersListenerMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceIgnoredUsersListenerFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceIgnoredUsersListenerFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceIgnoredUsersListenerFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceIgnoredUsersListenerINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceIgnoredUsersListener) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_ignoreduserslistener(&UniffiVTableCallbackInterfaceIgnoredUsersListenerINSTANCE)
}

// A listener for receiving new requests to a join a room.
type KnockRequestsListener interface {
	Call(joinRequests []KnockRequest)
}

type FfiConverterCallbackInterfaceKnockRequestsListener struct {
	handleMap *concurrentHandleMap[KnockRequestsListener]
}

var FfiConverterCallbackInterfaceKnockRequestsListenerINSTANCE = FfiConverterCallbackInterfaceKnockRequestsListener{
	handleMap: newConcurrentHandleMap[KnockRequestsListener](),
}

func (c FfiConverterCallbackInterfaceKnockRequestsListener) Lift(handle uint64) KnockRequestsListener {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceKnockRequestsListener) Read(reader io.Reader) KnockRequestsListener {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceKnockRequestsListener) Lower(value KnockRequestsListener) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceKnockRequestsListener) Write(writer io.Writer, value KnockRequestsListener) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceKnockRequestsListener struct{}

func (FfiDestroyerCallbackInterfaceKnockRequestsListener) Destroy(value KnockRequestsListener) {}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceKnockRequestsListenerMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceKnockRequestsListenerMethod0(uniffiHandle C.uint64_t, joinRequests C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceKnockRequestsListenerINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.Call(
		FfiConverterSequenceKnockRequestINSTANCE.Lift(GoRustBuffer{
			inner: joinRequests,
		}),
	)

}

var UniffiVTableCallbackInterfaceKnockRequestsListenerINSTANCE = C.UniffiVTableCallbackInterfaceKnockRequestsListener{
	call: (C.UniffiCallbackInterfaceKnockRequestsListenerMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceKnockRequestsListenerMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceKnockRequestsListenerFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceKnockRequestsListenerFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceKnockRequestsListenerFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceKnockRequestsListenerINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceKnockRequestsListener) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_knockrequestslistener(&UniffiVTableCallbackInterfaceKnockRequestsListenerINSTANCE)
}

// A listener for receiving new live location shares in a room.
type LiveLocationShareListener interface {
	Call(liveLocationShares []LiveLocationShare)
}

type FfiConverterCallbackInterfaceLiveLocationShareListener struct {
	handleMap *concurrentHandleMap[LiveLocationShareListener]
}

var FfiConverterCallbackInterfaceLiveLocationShareListenerINSTANCE = FfiConverterCallbackInterfaceLiveLocationShareListener{
	handleMap: newConcurrentHandleMap[LiveLocationShareListener](),
}

func (c FfiConverterCallbackInterfaceLiveLocationShareListener) Lift(handle uint64) LiveLocationShareListener {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceLiveLocationShareListener) Read(reader io.Reader) LiveLocationShareListener {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceLiveLocationShareListener) Lower(value LiveLocationShareListener) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceLiveLocationShareListener) Write(writer io.Writer, value LiveLocationShareListener) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceLiveLocationShareListener struct{}

func (FfiDestroyerCallbackInterfaceLiveLocationShareListener) Destroy(value LiveLocationShareListener) {
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceLiveLocationShareListenerMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceLiveLocationShareListenerMethod0(uniffiHandle C.uint64_t, liveLocationShares C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceLiveLocationShareListenerINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.Call(
		FfiConverterSequenceLiveLocationShareINSTANCE.Lift(GoRustBuffer{
			inner: liveLocationShares,
		}),
	)

}

var UniffiVTableCallbackInterfaceLiveLocationShareListenerINSTANCE = C.UniffiVTableCallbackInterfaceLiveLocationShareListener{
	call: (C.UniffiCallbackInterfaceLiveLocationShareListenerMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceLiveLocationShareListenerMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceLiveLocationShareListenerFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceLiveLocationShareListenerFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceLiveLocationShareListenerFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceLiveLocationShareListenerINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceLiveLocationShareListener) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_livelocationsharelistener(&UniffiVTableCallbackInterfaceLiveLocationShareListenerINSTANCE)
}

type MediaPreviewConfigListener interface {
	OnChange(mediaPreviewConfig MediaPreviewConfig)
}

type FfiConverterCallbackInterfaceMediaPreviewConfigListener struct {
	handleMap *concurrentHandleMap[MediaPreviewConfigListener]
}

var FfiConverterCallbackInterfaceMediaPreviewConfigListenerINSTANCE = FfiConverterCallbackInterfaceMediaPreviewConfigListener{
	handleMap: newConcurrentHandleMap[MediaPreviewConfigListener](),
}

func (c FfiConverterCallbackInterfaceMediaPreviewConfigListener) Lift(handle uint64) MediaPreviewConfigListener {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceMediaPreviewConfigListener) Read(reader io.Reader) MediaPreviewConfigListener {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceMediaPreviewConfigListener) Lower(value MediaPreviewConfigListener) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceMediaPreviewConfigListener) Write(writer io.Writer, value MediaPreviewConfigListener) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceMediaPreviewConfigListener struct{}

func (FfiDestroyerCallbackInterfaceMediaPreviewConfigListener) Destroy(value MediaPreviewConfigListener) {
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceMediaPreviewConfigListenerMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceMediaPreviewConfigListenerMethod0(uniffiHandle C.uint64_t, mediaPreviewConfig C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceMediaPreviewConfigListenerINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.OnChange(
		FfiConverterMediaPreviewConfigINSTANCE.Lift(GoRustBuffer{
			inner: mediaPreviewConfig,
		}),
	)

}

var UniffiVTableCallbackInterfaceMediaPreviewConfigListenerINSTANCE = C.UniffiVTableCallbackInterfaceMediaPreviewConfigListener{
	onChange: (C.UniffiCallbackInterfaceMediaPreviewConfigListenerMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceMediaPreviewConfigListenerMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceMediaPreviewConfigListenerFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceMediaPreviewConfigListenerFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceMediaPreviewConfigListenerFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceMediaPreviewConfigListenerINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceMediaPreviewConfigListener) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_mediapreviewconfiglistener(&UniffiVTableCallbackInterfaceMediaPreviewConfigListenerINSTANCE)
}

// Delegate to notify of changes in push rules
type NotificationSettingsDelegate interface {
	SettingsDidChange()
}

type FfiConverterCallbackInterfaceNotificationSettingsDelegate struct {
	handleMap *concurrentHandleMap[NotificationSettingsDelegate]
}

var FfiConverterCallbackInterfaceNotificationSettingsDelegateINSTANCE = FfiConverterCallbackInterfaceNotificationSettingsDelegate{
	handleMap: newConcurrentHandleMap[NotificationSettingsDelegate](),
}

func (c FfiConverterCallbackInterfaceNotificationSettingsDelegate) Lift(handle uint64) NotificationSettingsDelegate {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceNotificationSettingsDelegate) Read(reader io.Reader) NotificationSettingsDelegate {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceNotificationSettingsDelegate) Lower(value NotificationSettingsDelegate) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceNotificationSettingsDelegate) Write(writer io.Writer, value NotificationSettingsDelegate) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceNotificationSettingsDelegate struct{}

func (FfiDestroyerCallbackInterfaceNotificationSettingsDelegate) Destroy(value NotificationSettingsDelegate) {
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceNotificationSettingsDelegateMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceNotificationSettingsDelegateMethod0(uniffiHandle C.uint64_t, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceNotificationSettingsDelegateINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.SettingsDidChange()

}

var UniffiVTableCallbackInterfaceNotificationSettingsDelegateINSTANCE = C.UniffiVTableCallbackInterfaceNotificationSettingsDelegate{
	settingsDidChange: (C.UniffiCallbackInterfaceNotificationSettingsDelegateMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceNotificationSettingsDelegateMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceNotificationSettingsDelegateFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceNotificationSettingsDelegateFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceNotificationSettingsDelegateFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceNotificationSettingsDelegateINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceNotificationSettingsDelegate) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_notificationsettingsdelegate(&UniffiVTableCallbackInterfaceNotificationSettingsDelegateINSTANCE)
}

type PaginationStatusListener interface {
	OnUpdate(status matrix_sdk.RoomPaginationStatus)
}

type FfiConverterCallbackInterfacePaginationStatusListener struct {
	handleMap *concurrentHandleMap[PaginationStatusListener]
}

var FfiConverterCallbackInterfacePaginationStatusListenerINSTANCE = FfiConverterCallbackInterfacePaginationStatusListener{
	handleMap: newConcurrentHandleMap[PaginationStatusListener](),
}

func (c FfiConverterCallbackInterfacePaginationStatusListener) Lift(handle uint64) PaginationStatusListener {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfacePaginationStatusListener) Read(reader io.Reader) PaginationStatusListener {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfacePaginationStatusListener) Lower(value PaginationStatusListener) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfacePaginationStatusListener) Write(writer io.Writer, value PaginationStatusListener) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfacePaginationStatusListener struct{}

func (FfiDestroyerCallbackInterfacePaginationStatusListener) Destroy(value PaginationStatusListener) {
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfacePaginationStatusListenerMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfacePaginationStatusListenerMethod0(uniffiHandle C.uint64_t, status C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfacePaginationStatusListenerINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.OnUpdate(
		matrix_sdk.FfiConverterRoomPaginationStatusINSTANCE.Lift(GoRustBuffer{
			inner: status,
		}),
	)

}

var UniffiVTableCallbackInterfacePaginationStatusListenerINSTANCE = C.UniffiVTableCallbackInterfacePaginationStatusListener{
	onUpdate: (C.UniffiCallbackInterfacePaginationStatusListenerMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfacePaginationStatusListenerMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfacePaginationStatusListenerFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfacePaginationStatusListenerFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfacePaginationStatusListenerFree(handle C.uint64_t) {
	FfiConverterCallbackInterfacePaginationStatusListenerINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfacePaginationStatusListener) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_paginationstatuslistener(&UniffiVTableCallbackInterfacePaginationStatusListenerINSTANCE)
}

type ProgressWatcher interface {
	TransmissionProgress(progress TransmissionProgress)
}

type FfiConverterCallbackInterfaceProgressWatcher struct {
	handleMap *concurrentHandleMap[ProgressWatcher]
}

var FfiConverterCallbackInterfaceProgressWatcherINSTANCE = FfiConverterCallbackInterfaceProgressWatcher{
	handleMap: newConcurrentHandleMap[ProgressWatcher](),
}

func (c FfiConverterCallbackInterfaceProgressWatcher) Lift(handle uint64) ProgressWatcher {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceProgressWatcher) Read(reader io.Reader) ProgressWatcher {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceProgressWatcher) Lower(value ProgressWatcher) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceProgressWatcher) Write(writer io.Writer, value ProgressWatcher) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceProgressWatcher struct{}

func (FfiDestroyerCallbackInterfaceProgressWatcher) Destroy(value ProgressWatcher) {}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceProgressWatcherMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceProgressWatcherMethod0(uniffiHandle C.uint64_t, progress C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceProgressWatcherINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.TransmissionProgress(
		FfiConverterTransmissionProgressINSTANCE.Lift(GoRustBuffer{
			inner: progress,
		}),
	)

}

var UniffiVTableCallbackInterfaceProgressWatcherINSTANCE = C.UniffiVTableCallbackInterfaceProgressWatcher{
	transmissionProgress: (C.UniffiCallbackInterfaceProgressWatcherMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceProgressWatcherMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceProgressWatcherFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceProgressWatcherFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceProgressWatcherFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceProgressWatcherINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceProgressWatcher) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_progresswatcher(&UniffiVTableCallbackInterfaceProgressWatcherINSTANCE)
}

type QrLoginProgressListener interface {
	OnUpdate(state QrLoginProgress)
}

type FfiConverterCallbackInterfaceQrLoginProgressListener struct {
	handleMap *concurrentHandleMap[QrLoginProgressListener]
}

var FfiConverterCallbackInterfaceQrLoginProgressListenerINSTANCE = FfiConverterCallbackInterfaceQrLoginProgressListener{
	handleMap: newConcurrentHandleMap[QrLoginProgressListener](),
}

func (c FfiConverterCallbackInterfaceQrLoginProgressListener) Lift(handle uint64) QrLoginProgressListener {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceQrLoginProgressListener) Read(reader io.Reader) QrLoginProgressListener {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceQrLoginProgressListener) Lower(value QrLoginProgressListener) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceQrLoginProgressListener) Write(writer io.Writer, value QrLoginProgressListener) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceQrLoginProgressListener struct{}

func (FfiDestroyerCallbackInterfaceQrLoginProgressListener) Destroy(value QrLoginProgressListener) {}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceQrLoginProgressListenerMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceQrLoginProgressListenerMethod0(uniffiHandle C.uint64_t, state C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceQrLoginProgressListenerINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.OnUpdate(
		FfiConverterQrLoginProgressINSTANCE.Lift(GoRustBuffer{
			inner: state,
		}),
	)

}

var UniffiVTableCallbackInterfaceQrLoginProgressListenerINSTANCE = C.UniffiVTableCallbackInterfaceQrLoginProgressListener{
	onUpdate: (C.UniffiCallbackInterfaceQrLoginProgressListenerMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceQrLoginProgressListenerMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceQrLoginProgressListenerFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceQrLoginProgressListenerFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceQrLoginProgressListenerFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceQrLoginProgressListenerINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceQrLoginProgressListener) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_qrloginprogresslistener(&UniffiVTableCallbackInterfaceQrLoginProgressListenerINSTANCE)
}

type RecoveryStateListener interface {
	OnUpdate(status RecoveryState)
}

type FfiConverterCallbackInterfaceRecoveryStateListener struct {
	handleMap *concurrentHandleMap[RecoveryStateListener]
}

var FfiConverterCallbackInterfaceRecoveryStateListenerINSTANCE = FfiConverterCallbackInterfaceRecoveryStateListener{
	handleMap: newConcurrentHandleMap[RecoveryStateListener](),
}

func (c FfiConverterCallbackInterfaceRecoveryStateListener) Lift(handle uint64) RecoveryStateListener {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceRecoveryStateListener) Read(reader io.Reader) RecoveryStateListener {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceRecoveryStateListener) Lower(value RecoveryStateListener) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceRecoveryStateListener) Write(writer io.Writer, value RecoveryStateListener) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceRecoveryStateListener struct{}

func (FfiDestroyerCallbackInterfaceRecoveryStateListener) Destroy(value RecoveryStateListener) {}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRecoveryStateListenerMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRecoveryStateListenerMethod0(uniffiHandle C.uint64_t, status C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceRecoveryStateListenerINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.OnUpdate(
		FfiConverterRecoveryStateINSTANCE.Lift(GoRustBuffer{
			inner: status,
		}),
	)

}

var UniffiVTableCallbackInterfaceRecoveryStateListenerINSTANCE = C.UniffiVTableCallbackInterfaceRecoveryStateListener{
	onUpdate: (C.UniffiCallbackInterfaceRecoveryStateListenerMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRecoveryStateListenerMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRecoveryStateListenerFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRecoveryStateListenerFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRecoveryStateListenerFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceRecoveryStateListenerINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceRecoveryStateListener) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_recoverystatelistener(&UniffiVTableCallbackInterfaceRecoveryStateListenerINSTANCE)
}

// A listener for changes of room account data events.
type RoomAccountDataListener interface {

	// Called when a room account data event was changed.
	OnChange(event RoomAccountDataEvent, roomId string)
}

type FfiConverterCallbackInterfaceRoomAccountDataListener struct {
	handleMap *concurrentHandleMap[RoomAccountDataListener]
}

var FfiConverterCallbackInterfaceRoomAccountDataListenerINSTANCE = FfiConverterCallbackInterfaceRoomAccountDataListener{
	handleMap: newConcurrentHandleMap[RoomAccountDataListener](),
}

func (c FfiConverterCallbackInterfaceRoomAccountDataListener) Lift(handle uint64) RoomAccountDataListener {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceRoomAccountDataListener) Read(reader io.Reader) RoomAccountDataListener {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceRoomAccountDataListener) Lower(value RoomAccountDataListener) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceRoomAccountDataListener) Write(writer io.Writer, value RoomAccountDataListener) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceRoomAccountDataListener struct{}

func (FfiDestroyerCallbackInterfaceRoomAccountDataListener) Destroy(value RoomAccountDataListener) {}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomAccountDataListenerMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomAccountDataListenerMethod0(uniffiHandle C.uint64_t, event C.RustBuffer, roomId C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceRoomAccountDataListenerINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.OnChange(
		FfiConverterRoomAccountDataEventINSTANCE.Lift(GoRustBuffer{
			inner: event,
		}),
		FfiConverterStringINSTANCE.Lift(GoRustBuffer{
			inner: roomId,
		}),
	)

}

var UniffiVTableCallbackInterfaceRoomAccountDataListenerINSTANCE = C.UniffiVTableCallbackInterfaceRoomAccountDataListener{
	onChange: (C.UniffiCallbackInterfaceRoomAccountDataListenerMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomAccountDataListenerMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomAccountDataListenerFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomAccountDataListenerFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomAccountDataListenerFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceRoomAccountDataListenerINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceRoomAccountDataListener) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomaccountdatalistener(&UniffiVTableCallbackInterfaceRoomAccountDataListenerINSTANCE)
}

type RoomDirectorySearchEntriesListener interface {
	OnUpdate(roomEntriesUpdate []RoomDirectorySearchEntryUpdate)
}

type FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListener struct {
	handleMap *concurrentHandleMap[RoomDirectorySearchEntriesListener]
}

var FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListenerINSTANCE = FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListener{
	handleMap: newConcurrentHandleMap[RoomDirectorySearchEntriesListener](),
}

func (c FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListener) Lift(handle uint64) RoomDirectorySearchEntriesListener {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListener) Read(reader io.Reader) RoomDirectorySearchEntriesListener {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListener) Lower(value RoomDirectorySearchEntriesListener) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListener) Write(writer io.Writer, value RoomDirectorySearchEntriesListener) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceRoomDirectorySearchEntriesListener struct{}

func (FfiDestroyerCallbackInterfaceRoomDirectorySearchEntriesListener) Destroy(value RoomDirectorySearchEntriesListener) {
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomDirectorySearchEntriesListenerMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomDirectorySearchEntriesListenerMethod0(uniffiHandle C.uint64_t, roomEntriesUpdate C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListenerINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.OnUpdate(
		FfiConverterSequenceRoomDirectorySearchEntryUpdateINSTANCE.Lift(GoRustBuffer{
			inner: roomEntriesUpdate,
		}),
	)

}

var UniffiVTableCallbackInterfaceRoomDirectorySearchEntriesListenerINSTANCE = C.UniffiVTableCallbackInterfaceRoomDirectorySearchEntriesListener{
	onUpdate: (C.UniffiCallbackInterfaceRoomDirectorySearchEntriesListenerMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomDirectorySearchEntriesListenerMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomDirectorySearchEntriesListenerFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomDirectorySearchEntriesListenerFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomDirectorySearchEntriesListenerFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListenerINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListener) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomdirectorysearchentrieslistener(&UniffiVTableCallbackInterfaceRoomDirectorySearchEntriesListenerINSTANCE)
}

type RoomInfoListener interface {
	Call(roomInfo RoomInfo)
}

type FfiConverterCallbackInterfaceRoomInfoListener struct {
	handleMap *concurrentHandleMap[RoomInfoListener]
}

var FfiConverterCallbackInterfaceRoomInfoListenerINSTANCE = FfiConverterCallbackInterfaceRoomInfoListener{
	handleMap: newConcurrentHandleMap[RoomInfoListener](),
}

func (c FfiConverterCallbackInterfaceRoomInfoListener) Lift(handle uint64) RoomInfoListener {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceRoomInfoListener) Read(reader io.Reader) RoomInfoListener {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceRoomInfoListener) Lower(value RoomInfoListener) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceRoomInfoListener) Write(writer io.Writer, value RoomInfoListener) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceRoomInfoListener struct{}

func (FfiDestroyerCallbackInterfaceRoomInfoListener) Destroy(value RoomInfoListener) {}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomInfoListenerMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomInfoListenerMethod0(uniffiHandle C.uint64_t, roomInfo C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceRoomInfoListenerINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.Call(
		FfiConverterRoomInfoINSTANCE.Lift(GoRustBuffer{
			inner: roomInfo,
		}),
	)

}

var UniffiVTableCallbackInterfaceRoomInfoListenerINSTANCE = C.UniffiVTableCallbackInterfaceRoomInfoListener{
	call: (C.UniffiCallbackInterfaceRoomInfoListenerMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomInfoListenerMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomInfoListenerFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomInfoListenerFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomInfoListenerFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceRoomInfoListenerINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceRoomInfoListener) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roominfolistener(&UniffiVTableCallbackInterfaceRoomInfoListenerINSTANCE)
}

type RoomListEntriesListener interface {
	OnUpdate(roomEntriesUpdate []RoomListEntriesUpdate)
}

type FfiConverterCallbackInterfaceRoomListEntriesListener struct {
	handleMap *concurrentHandleMap[RoomListEntriesListener]
}

var FfiConverterCallbackInterfaceRoomListEntriesListenerINSTANCE = FfiConverterCallbackInterfaceRoomListEntriesListener{
	handleMap: newConcurrentHandleMap[RoomListEntriesListener](),
}

func (c FfiConverterCallbackInterfaceRoomListEntriesListener) Lift(handle uint64) RoomListEntriesListener {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceRoomListEntriesListener) Read(reader io.Reader) RoomListEntriesListener {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceRoomListEntriesListener) Lower(value RoomListEntriesListener) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceRoomListEntriesListener) Write(writer io.Writer, value RoomListEntriesListener) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceRoomListEntriesListener struct{}

func (FfiDestroyerCallbackInterfaceRoomListEntriesListener) Destroy(value RoomListEntriesListener) {}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListEntriesListenerMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListEntriesListenerMethod0(uniffiHandle C.uint64_t, roomEntriesUpdate C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceRoomListEntriesListenerINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.OnUpdate(
		FfiConverterSequenceRoomListEntriesUpdateINSTANCE.Lift(GoRustBuffer{
			inner: roomEntriesUpdate,
		}),
	)

}

var UniffiVTableCallbackInterfaceRoomListEntriesListenerINSTANCE = C.UniffiVTableCallbackInterfaceRoomListEntriesListener{
	onUpdate: (C.UniffiCallbackInterfaceRoomListEntriesListenerMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListEntriesListenerMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListEntriesListenerFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListEntriesListenerFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListEntriesListenerFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceRoomListEntriesListenerINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceRoomListEntriesListener) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistentrieslistener(&UniffiVTableCallbackInterfaceRoomListEntriesListenerINSTANCE)
}

type RoomListLoadingStateListener interface {
	OnUpdate(state RoomListLoadingState)
}

type FfiConverterCallbackInterfaceRoomListLoadingStateListener struct {
	handleMap *concurrentHandleMap[RoomListLoadingStateListener]
}

var FfiConverterCallbackInterfaceRoomListLoadingStateListenerINSTANCE = FfiConverterCallbackInterfaceRoomListLoadingStateListener{
	handleMap: newConcurrentHandleMap[RoomListLoadingStateListener](),
}

func (c FfiConverterCallbackInterfaceRoomListLoadingStateListener) Lift(handle uint64) RoomListLoadingStateListener {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceRoomListLoadingStateListener) Read(reader io.Reader) RoomListLoadingStateListener {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceRoomListLoadingStateListener) Lower(value RoomListLoadingStateListener) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceRoomListLoadingStateListener) Write(writer io.Writer, value RoomListLoadingStateListener) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceRoomListLoadingStateListener struct{}

func (FfiDestroyerCallbackInterfaceRoomListLoadingStateListener) Destroy(value RoomListLoadingStateListener) {
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListLoadingStateListenerMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListLoadingStateListenerMethod0(uniffiHandle C.uint64_t, state C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceRoomListLoadingStateListenerINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.OnUpdate(
		FfiConverterRoomListLoadingStateINSTANCE.Lift(GoRustBuffer{
			inner: state,
		}),
	)

}

var UniffiVTableCallbackInterfaceRoomListLoadingStateListenerINSTANCE = C.UniffiVTableCallbackInterfaceRoomListLoadingStateListener{
	onUpdate: (C.UniffiCallbackInterfaceRoomListLoadingStateListenerMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListLoadingStateListenerMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListLoadingStateListenerFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListLoadingStateListenerFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListLoadingStateListenerFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceRoomListLoadingStateListenerINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceRoomListLoadingStateListener) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistloadingstatelistener(&UniffiVTableCallbackInterfaceRoomListLoadingStateListenerINSTANCE)
}

type RoomListServiceStateListener interface {
	OnUpdate(state RoomListServiceState)
}

type FfiConverterCallbackInterfaceRoomListServiceStateListener struct {
	handleMap *concurrentHandleMap[RoomListServiceStateListener]
}

var FfiConverterCallbackInterfaceRoomListServiceStateListenerINSTANCE = FfiConverterCallbackInterfaceRoomListServiceStateListener{
	handleMap: newConcurrentHandleMap[RoomListServiceStateListener](),
}

func (c FfiConverterCallbackInterfaceRoomListServiceStateListener) Lift(handle uint64) RoomListServiceStateListener {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceRoomListServiceStateListener) Read(reader io.Reader) RoomListServiceStateListener {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceRoomListServiceStateListener) Lower(value RoomListServiceStateListener) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceRoomListServiceStateListener) Write(writer io.Writer, value RoomListServiceStateListener) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceRoomListServiceStateListener struct{}

func (FfiDestroyerCallbackInterfaceRoomListServiceStateListener) Destroy(value RoomListServiceStateListener) {
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListServiceStateListenerMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListServiceStateListenerMethod0(uniffiHandle C.uint64_t, state C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceRoomListServiceStateListenerINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.OnUpdate(
		FfiConverterRoomListServiceStateINSTANCE.Lift(GoRustBuffer{
			inner: state,
		}),
	)

}

var UniffiVTableCallbackInterfaceRoomListServiceStateListenerINSTANCE = C.UniffiVTableCallbackInterfaceRoomListServiceStateListener{
	onUpdate: (C.UniffiCallbackInterfaceRoomListServiceStateListenerMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListServiceStateListenerMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListServiceStateListenerFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListServiceStateListenerFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListServiceStateListenerFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceRoomListServiceStateListenerINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceRoomListServiceStateListener) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistservicestatelistener(&UniffiVTableCallbackInterfaceRoomListServiceStateListenerINSTANCE)
}

type RoomListServiceSyncIndicatorListener interface {
	OnUpdate(syncIndicator RoomListServiceSyncIndicator)
}

type FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListener struct {
	handleMap *concurrentHandleMap[RoomListServiceSyncIndicatorListener]
}

var FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListenerINSTANCE = FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListener{
	handleMap: newConcurrentHandleMap[RoomListServiceSyncIndicatorListener](),
}

func (c FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListener) Lift(handle uint64) RoomListServiceSyncIndicatorListener {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListener) Read(reader io.Reader) RoomListServiceSyncIndicatorListener {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListener) Lower(value RoomListServiceSyncIndicatorListener) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListener) Write(writer io.Writer, value RoomListServiceSyncIndicatorListener) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceRoomListServiceSyncIndicatorListener struct{}

func (FfiDestroyerCallbackInterfaceRoomListServiceSyncIndicatorListener) Destroy(value RoomListServiceSyncIndicatorListener) {
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListServiceSyncIndicatorListenerMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListServiceSyncIndicatorListenerMethod0(uniffiHandle C.uint64_t, syncIndicator C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListenerINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.OnUpdate(
		FfiConverterRoomListServiceSyncIndicatorINSTANCE.Lift(GoRustBuffer{
			inner: syncIndicator,
		}),
	)

}

var UniffiVTableCallbackInterfaceRoomListServiceSyncIndicatorListenerINSTANCE = C.UniffiVTableCallbackInterfaceRoomListServiceSyncIndicatorListener{
	onUpdate: (C.UniffiCallbackInterfaceRoomListServiceSyncIndicatorListenerMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListServiceSyncIndicatorListenerMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListServiceSyncIndicatorListenerFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListServiceSyncIndicatorListenerFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceRoomListServiceSyncIndicatorListenerFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListenerINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListener) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistservicesyncindicatorlistener(&UniffiVTableCallbackInterfaceRoomListServiceSyncIndicatorListenerINSTANCE)
}

// A listener to the global (client-wide) error reporter of the send queue.
type SendQueueRoomErrorListener interface {

	// Called every time the send queue has ran into an error for a given room,
	// which will disable the send queue for that particular room.
	OnError(roomId string, error *ClientError)
}

type FfiConverterCallbackInterfaceSendQueueRoomErrorListener struct {
	handleMap *concurrentHandleMap[SendQueueRoomErrorListener]
}

var FfiConverterCallbackInterfaceSendQueueRoomErrorListenerINSTANCE = FfiConverterCallbackInterfaceSendQueueRoomErrorListener{
	handleMap: newConcurrentHandleMap[SendQueueRoomErrorListener](),
}

func (c FfiConverterCallbackInterfaceSendQueueRoomErrorListener) Lift(handle uint64) SendQueueRoomErrorListener {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceSendQueueRoomErrorListener) Read(reader io.Reader) SendQueueRoomErrorListener {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceSendQueueRoomErrorListener) Lower(value SendQueueRoomErrorListener) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceSendQueueRoomErrorListener) Write(writer io.Writer, value SendQueueRoomErrorListener) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceSendQueueRoomErrorListener struct{}

func (FfiDestroyerCallbackInterfaceSendQueueRoomErrorListener) Destroy(value SendQueueRoomErrorListener) {
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSendQueueRoomErrorListenerMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSendQueueRoomErrorListenerMethod0(uniffiHandle C.uint64_t, roomId C.RustBuffer, error C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceSendQueueRoomErrorListenerINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.OnError(
		FfiConverterStringINSTANCE.Lift(GoRustBuffer{
			inner: roomId,
		}),
		FfiConverterClientErrorINSTANCE.Lift(GoRustBuffer{
			inner: error,
		}),
	)

}

var UniffiVTableCallbackInterfaceSendQueueRoomErrorListenerINSTANCE = C.UniffiVTableCallbackInterfaceSendQueueRoomErrorListener{
	onError: (C.UniffiCallbackInterfaceSendQueueRoomErrorListenerMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSendQueueRoomErrorListenerMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSendQueueRoomErrorListenerFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSendQueueRoomErrorListenerFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSendQueueRoomErrorListenerFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceSendQueueRoomErrorListenerINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceSendQueueRoomErrorListener) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sendqueueroomerrorlistener(&UniffiVTableCallbackInterfaceSendQueueRoomErrorListenerINSTANCE)
}

type SessionVerificationControllerDelegate interface {
	DidReceiveVerificationRequest(details SessionVerificationRequestDetails)

	DidAcceptVerificationRequest()

	DidStartSasVerification()

	DidReceiveVerificationData(data SessionVerificationData)

	DidFail()

	DidCancel()

	DidFinish()
}

type FfiConverterCallbackInterfaceSessionVerificationControllerDelegate struct {
	handleMap *concurrentHandleMap[SessionVerificationControllerDelegate]
}

var FfiConverterCallbackInterfaceSessionVerificationControllerDelegateINSTANCE = FfiConverterCallbackInterfaceSessionVerificationControllerDelegate{
	handleMap: newConcurrentHandleMap[SessionVerificationControllerDelegate](),
}

func (c FfiConverterCallbackInterfaceSessionVerificationControllerDelegate) Lift(handle uint64) SessionVerificationControllerDelegate {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceSessionVerificationControllerDelegate) Read(reader io.Reader) SessionVerificationControllerDelegate {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceSessionVerificationControllerDelegate) Lower(value SessionVerificationControllerDelegate) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceSessionVerificationControllerDelegate) Write(writer io.Writer, value SessionVerificationControllerDelegate) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceSessionVerificationControllerDelegate struct{}

func (FfiDestroyerCallbackInterfaceSessionVerificationControllerDelegate) Destroy(value SessionVerificationControllerDelegate) {
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateMethod0(uniffiHandle C.uint64_t, details C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceSessionVerificationControllerDelegateINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.DidReceiveVerificationRequest(
		FfiConverterSessionVerificationRequestDetailsINSTANCE.Lift(GoRustBuffer{
			inner: details,
		}),
	)

}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateMethod1
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateMethod1(uniffiHandle C.uint64_t, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceSessionVerificationControllerDelegateINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.DidAcceptVerificationRequest()

}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateMethod2
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateMethod2(uniffiHandle C.uint64_t, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceSessionVerificationControllerDelegateINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.DidStartSasVerification()

}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateMethod3
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateMethod3(uniffiHandle C.uint64_t, data C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceSessionVerificationControllerDelegateINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.DidReceiveVerificationData(
		FfiConverterSessionVerificationDataINSTANCE.Lift(GoRustBuffer{
			inner: data,
		}),
	)

}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateMethod4
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateMethod4(uniffiHandle C.uint64_t, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceSessionVerificationControllerDelegateINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.DidFail()

}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateMethod5
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateMethod5(uniffiHandle C.uint64_t, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceSessionVerificationControllerDelegateINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.DidCancel()

}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateMethod6
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateMethod6(uniffiHandle C.uint64_t, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceSessionVerificationControllerDelegateINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.DidFinish()

}

var UniffiVTableCallbackInterfaceSessionVerificationControllerDelegateINSTANCE = C.UniffiVTableCallbackInterfaceSessionVerificationControllerDelegate{
	didReceiveVerificationRequest: (C.UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateMethod0),
	didAcceptVerificationRequest:  (C.UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod1)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateMethod1),
	didStartSasVerification:       (C.UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod2)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateMethod2),
	didReceiveVerificationData:    (C.UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod3)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateMethod3),
	didFail:                       (C.UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod4)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateMethod4),
	didCancel:                     (C.UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod5)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateMethod5),
	didFinish:                     (C.UniffiCallbackInterfaceSessionVerificationControllerDelegateMethod6)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateMethod6),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSessionVerificationControllerDelegateFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceSessionVerificationControllerDelegateINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceSessionVerificationControllerDelegate) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sessionverificationcontrollerdelegate(&UniffiVTableCallbackInterfaceSessionVerificationControllerDelegateINSTANCE)
}

type SyncServiceStateObserver interface {
	OnUpdate(state SyncServiceState)
}

type FfiConverterCallbackInterfaceSyncServiceStateObserver struct {
	handleMap *concurrentHandleMap[SyncServiceStateObserver]
}

var FfiConverterCallbackInterfaceSyncServiceStateObserverINSTANCE = FfiConverterCallbackInterfaceSyncServiceStateObserver{
	handleMap: newConcurrentHandleMap[SyncServiceStateObserver](),
}

func (c FfiConverterCallbackInterfaceSyncServiceStateObserver) Lift(handle uint64) SyncServiceStateObserver {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceSyncServiceStateObserver) Read(reader io.Reader) SyncServiceStateObserver {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceSyncServiceStateObserver) Lower(value SyncServiceStateObserver) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceSyncServiceStateObserver) Write(writer io.Writer, value SyncServiceStateObserver) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceSyncServiceStateObserver struct{}

func (FfiDestroyerCallbackInterfaceSyncServiceStateObserver) Destroy(value SyncServiceStateObserver) {
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSyncServiceStateObserverMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSyncServiceStateObserverMethod0(uniffiHandle C.uint64_t, state C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceSyncServiceStateObserverINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.OnUpdate(
		FfiConverterSyncServiceStateINSTANCE.Lift(GoRustBuffer{
			inner: state,
		}),
	)

}

var UniffiVTableCallbackInterfaceSyncServiceStateObserverINSTANCE = C.UniffiVTableCallbackInterfaceSyncServiceStateObserver{
	onUpdate: (C.UniffiCallbackInterfaceSyncServiceStateObserverMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSyncServiceStateObserverMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSyncServiceStateObserverFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSyncServiceStateObserverFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceSyncServiceStateObserverFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceSyncServiceStateObserverINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceSyncServiceStateObserver) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_syncservicestateobserver(&UniffiVTableCallbackInterfaceSyncServiceStateObserverINSTANCE)
}

type TimelineListener interface {
	OnUpdate(diff []*TimelineDiff)
}

type FfiConverterCallbackInterfaceTimelineListener struct {
	handleMap *concurrentHandleMap[TimelineListener]
}

var FfiConverterCallbackInterfaceTimelineListenerINSTANCE = FfiConverterCallbackInterfaceTimelineListener{
	handleMap: newConcurrentHandleMap[TimelineListener](),
}

func (c FfiConverterCallbackInterfaceTimelineListener) Lift(handle uint64) TimelineListener {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceTimelineListener) Read(reader io.Reader) TimelineListener {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceTimelineListener) Lower(value TimelineListener) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceTimelineListener) Write(writer io.Writer, value TimelineListener) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceTimelineListener struct{}

func (FfiDestroyerCallbackInterfaceTimelineListener) Destroy(value TimelineListener) {}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceTimelineListenerMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceTimelineListenerMethod0(uniffiHandle C.uint64_t, diff C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceTimelineListenerINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.OnUpdate(
		FfiConverterSequenceTimelineDiffINSTANCE.Lift(GoRustBuffer{
			inner: diff,
		}),
	)

}

var UniffiVTableCallbackInterfaceTimelineListenerINSTANCE = C.UniffiVTableCallbackInterfaceTimelineListener{
	onUpdate: (C.UniffiCallbackInterfaceTimelineListenerMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceTimelineListenerMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceTimelineListenerFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceTimelineListenerFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceTimelineListenerFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceTimelineListenerINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceTimelineListener) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_timelinelistener(&UniffiVTableCallbackInterfaceTimelineListenerINSTANCE)
}

type TypingNotificationsListener interface {
	Call(typingUserIds []string)
}

type FfiConverterCallbackInterfaceTypingNotificationsListener struct {
	handleMap *concurrentHandleMap[TypingNotificationsListener]
}

var FfiConverterCallbackInterfaceTypingNotificationsListenerINSTANCE = FfiConverterCallbackInterfaceTypingNotificationsListener{
	handleMap: newConcurrentHandleMap[TypingNotificationsListener](),
}

func (c FfiConverterCallbackInterfaceTypingNotificationsListener) Lift(handle uint64) TypingNotificationsListener {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceTypingNotificationsListener) Read(reader io.Reader) TypingNotificationsListener {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceTypingNotificationsListener) Lower(value TypingNotificationsListener) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceTypingNotificationsListener) Write(writer io.Writer, value TypingNotificationsListener) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceTypingNotificationsListener struct{}

func (FfiDestroyerCallbackInterfaceTypingNotificationsListener) Destroy(value TypingNotificationsListener) {
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceTypingNotificationsListenerMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceTypingNotificationsListenerMethod0(uniffiHandle C.uint64_t, typingUserIds C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceTypingNotificationsListenerINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.Call(
		FfiConverterSequenceStringINSTANCE.Lift(GoRustBuffer{
			inner: typingUserIds,
		}),
	)

}

var UniffiVTableCallbackInterfaceTypingNotificationsListenerINSTANCE = C.UniffiVTableCallbackInterfaceTypingNotificationsListener{
	call: (C.UniffiCallbackInterfaceTypingNotificationsListenerMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceTypingNotificationsListenerMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceTypingNotificationsListenerFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceTypingNotificationsListenerFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceTypingNotificationsListenerFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceTypingNotificationsListenerINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceTypingNotificationsListener) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_typingnotificationslistener(&UniffiVTableCallbackInterfaceTypingNotificationsListenerINSTANCE)
}

type UnableToDecryptDelegate interface {
	OnUtd(info UnableToDecryptInfo)
}

type FfiConverterCallbackInterfaceUnableToDecryptDelegate struct {
	handleMap *concurrentHandleMap[UnableToDecryptDelegate]
}

var FfiConverterCallbackInterfaceUnableToDecryptDelegateINSTANCE = FfiConverterCallbackInterfaceUnableToDecryptDelegate{
	handleMap: newConcurrentHandleMap[UnableToDecryptDelegate](),
}

func (c FfiConverterCallbackInterfaceUnableToDecryptDelegate) Lift(handle uint64) UnableToDecryptDelegate {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceUnableToDecryptDelegate) Read(reader io.Reader) UnableToDecryptDelegate {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceUnableToDecryptDelegate) Lower(value UnableToDecryptDelegate) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceUnableToDecryptDelegate) Write(writer io.Writer, value UnableToDecryptDelegate) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceUnableToDecryptDelegate struct{}

func (FfiDestroyerCallbackInterfaceUnableToDecryptDelegate) Destroy(value UnableToDecryptDelegate) {}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceUnableToDecryptDelegateMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceUnableToDecryptDelegateMethod0(uniffiHandle C.uint64_t, info C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceUnableToDecryptDelegateINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.OnUtd(
		FfiConverterUnableToDecryptInfoINSTANCE.Lift(GoRustBuffer{
			inner: info,
		}),
	)

}

var UniffiVTableCallbackInterfaceUnableToDecryptDelegateINSTANCE = C.UniffiVTableCallbackInterfaceUnableToDecryptDelegate{
	onUtd: (C.UniffiCallbackInterfaceUnableToDecryptDelegateMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceUnableToDecryptDelegateMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceUnableToDecryptDelegateFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceUnableToDecryptDelegateFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceUnableToDecryptDelegateFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceUnableToDecryptDelegateINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceUnableToDecryptDelegate) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_unabletodecryptdelegate(&UniffiVTableCallbackInterfaceUnableToDecryptDelegateINSTANCE)
}

type VerificationStateListener interface {
	OnUpdate(status VerificationState)
}

type FfiConverterCallbackInterfaceVerificationStateListener struct {
	handleMap *concurrentHandleMap[VerificationStateListener]
}

var FfiConverterCallbackInterfaceVerificationStateListenerINSTANCE = FfiConverterCallbackInterfaceVerificationStateListener{
	handleMap: newConcurrentHandleMap[VerificationStateListener](),
}

func (c FfiConverterCallbackInterfaceVerificationStateListener) Lift(handle uint64) VerificationStateListener {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceVerificationStateListener) Read(reader io.Reader) VerificationStateListener {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceVerificationStateListener) Lower(value VerificationStateListener) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceVerificationStateListener) Write(writer io.Writer, value VerificationStateListener) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceVerificationStateListener struct{}

func (FfiDestroyerCallbackInterfaceVerificationStateListener) Destroy(value VerificationStateListener) {
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceVerificationStateListenerMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceVerificationStateListenerMethod0(uniffiHandle C.uint64_t, status C.RustBuffer, uniffiOutReturn *C.void, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceVerificationStateListenerINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	uniffiObj.OnUpdate(
		FfiConverterVerificationStateINSTANCE.Lift(GoRustBuffer{
			inner: status,
		}),
	)

}

var UniffiVTableCallbackInterfaceVerificationStateListenerINSTANCE = C.UniffiVTableCallbackInterfaceVerificationStateListener{
	onUpdate: (C.UniffiCallbackInterfaceVerificationStateListenerMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceVerificationStateListenerMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceVerificationStateListenerFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceVerificationStateListenerFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceVerificationStateListenerFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceVerificationStateListenerINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceVerificationStateListener) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_verificationstatelistener(&UniffiVTableCallbackInterfaceVerificationStateListenerINSTANCE)
}

type WidgetCapabilitiesProvider interface {
	AcquireCapabilities(capabilities WidgetCapabilities) WidgetCapabilities
}

type FfiConverterCallbackInterfaceWidgetCapabilitiesProvider struct {
	handleMap *concurrentHandleMap[WidgetCapabilitiesProvider]
}

var FfiConverterCallbackInterfaceWidgetCapabilitiesProviderINSTANCE = FfiConverterCallbackInterfaceWidgetCapabilitiesProvider{
	handleMap: newConcurrentHandleMap[WidgetCapabilitiesProvider](),
}

func (c FfiConverterCallbackInterfaceWidgetCapabilitiesProvider) Lift(handle uint64) WidgetCapabilitiesProvider {
	val, ok := c.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}
	return val
}

func (c FfiConverterCallbackInterfaceWidgetCapabilitiesProvider) Read(reader io.Reader) WidgetCapabilitiesProvider {
	return c.Lift(readUint64(reader))
}

func (c FfiConverterCallbackInterfaceWidgetCapabilitiesProvider) Lower(value WidgetCapabilitiesProvider) C.uint64_t {
	return C.uint64_t(c.handleMap.insert(value))
}

func (c FfiConverterCallbackInterfaceWidgetCapabilitiesProvider) Write(writer io.Writer, value WidgetCapabilitiesProvider) {
	writeUint64(writer, uint64(c.Lower(value)))
}

type FfiDestroyerCallbackInterfaceWidgetCapabilitiesProvider struct{}

func (FfiDestroyerCallbackInterfaceWidgetCapabilitiesProvider) Destroy(value WidgetCapabilitiesProvider) {
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceWidgetCapabilitiesProviderMethod0
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceWidgetCapabilitiesProviderMethod0(uniffiHandle C.uint64_t, capabilities C.RustBuffer, uniffiOutReturn *C.RustBuffer, callStatus *C.RustCallStatus) {
	handle := uint64(uniffiHandle)
	uniffiObj, ok := FfiConverterCallbackInterfaceWidgetCapabilitiesProviderINSTANCE.handleMap.tryGet(handle)
	if !ok {
		panic(fmt.Errorf("no callback in handle map: %d", handle))
	}

	res :=
		uniffiObj.AcquireCapabilities(
			FfiConverterWidgetCapabilitiesINSTANCE.Lift(GoRustBuffer{
				inner: capabilities,
			}),
		)

	*uniffiOutReturn = FfiConverterWidgetCapabilitiesINSTANCE.Lower(res)
}

var UniffiVTableCallbackInterfaceWidgetCapabilitiesProviderINSTANCE = C.UniffiVTableCallbackInterfaceWidgetCapabilitiesProvider{
	acquireCapabilities: (C.UniffiCallbackInterfaceWidgetCapabilitiesProviderMethod0)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceWidgetCapabilitiesProviderMethod0),

	uniffiFree: (C.UniffiCallbackInterfaceFree)(C.matrix_sdk_ffi_cgo_dispatchCallbackInterfaceWidgetCapabilitiesProviderFree),
}

//export matrix_sdk_ffi_cgo_dispatchCallbackInterfaceWidgetCapabilitiesProviderFree
func matrix_sdk_ffi_cgo_dispatchCallbackInterfaceWidgetCapabilitiesProviderFree(handle C.uint64_t) {
	FfiConverterCallbackInterfaceWidgetCapabilitiesProviderINSTANCE.handleMap.remove(uint64(handle))
}

func (c FfiConverterCallbackInterfaceWidgetCapabilitiesProvider) register() {
	C.uniffi_matrix_sdk_ffi_fn_init_callback_vtable_widgetcapabilitiesprovider(&UniffiVTableCallbackInterfaceWidgetCapabilitiesProviderINSTANCE)
}

type FfiConverterOptionalUint8 struct{}

var FfiConverterOptionalUint8INSTANCE = FfiConverterOptionalUint8{}

func (c FfiConverterOptionalUint8) Lift(rb RustBufferI) *uint8 {
	return LiftFromRustBuffer[*uint8](c, rb)
}

func (_ FfiConverterOptionalUint8) Read(reader io.Reader) *uint8 {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterUint8INSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalUint8) Lower(value *uint8) C.RustBuffer {
	return LowerIntoRustBuffer[*uint8](c, value)
}

func (_ FfiConverterOptionalUint8) Write(writer io.Writer, value *uint8) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterUint8INSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalUint8 struct{}

func (_ FfiDestroyerOptionalUint8) Destroy(value *uint8) {
	if value != nil {
		FfiDestroyerUint8{}.Destroy(*value)
	}
}

type FfiConverterOptionalUint16 struct{}

var FfiConverterOptionalUint16INSTANCE = FfiConverterOptionalUint16{}

func (c FfiConverterOptionalUint16) Lift(rb RustBufferI) *uint16 {
	return LiftFromRustBuffer[*uint16](c, rb)
}

func (_ FfiConverterOptionalUint16) Read(reader io.Reader) *uint16 {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterUint16INSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalUint16) Lower(value *uint16) C.RustBuffer {
	return LowerIntoRustBuffer[*uint16](c, value)
}

func (_ FfiConverterOptionalUint16) Write(writer io.Writer, value *uint16) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterUint16INSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalUint16 struct{}

func (_ FfiDestroyerOptionalUint16) Destroy(value *uint16) {
	if value != nil {
		FfiDestroyerUint16{}.Destroy(*value)
	}
}

type FfiConverterOptionalUint32 struct{}

var FfiConverterOptionalUint32INSTANCE = FfiConverterOptionalUint32{}

func (c FfiConverterOptionalUint32) Lift(rb RustBufferI) *uint32 {
	return LiftFromRustBuffer[*uint32](c, rb)
}

func (_ FfiConverterOptionalUint32) Read(reader io.Reader) *uint32 {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterUint32INSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalUint32) Lower(value *uint32) C.RustBuffer {
	return LowerIntoRustBuffer[*uint32](c, value)
}

func (_ FfiConverterOptionalUint32) Write(writer io.Writer, value *uint32) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterUint32INSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalUint32 struct{}

func (_ FfiDestroyerOptionalUint32) Destroy(value *uint32) {
	if value != nil {
		FfiDestroyerUint32{}.Destroy(*value)
	}
}

type FfiConverterOptionalInt32 struct{}

var FfiConverterOptionalInt32INSTANCE = FfiConverterOptionalInt32{}

func (c FfiConverterOptionalInt32) Lift(rb RustBufferI) *int32 {
	return LiftFromRustBuffer[*int32](c, rb)
}

func (_ FfiConverterOptionalInt32) Read(reader io.Reader) *int32 {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterInt32INSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalInt32) Lower(value *int32) C.RustBuffer {
	return LowerIntoRustBuffer[*int32](c, value)
}

func (_ FfiConverterOptionalInt32) Write(writer io.Writer, value *int32) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterInt32INSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalInt32 struct{}

func (_ FfiDestroyerOptionalInt32) Destroy(value *int32) {
	if value != nil {
		FfiDestroyerInt32{}.Destroy(*value)
	}
}

type FfiConverterOptionalUint64 struct{}

var FfiConverterOptionalUint64INSTANCE = FfiConverterOptionalUint64{}

func (c FfiConverterOptionalUint64) Lift(rb RustBufferI) *uint64 {
	return LiftFromRustBuffer[*uint64](c, rb)
}

func (_ FfiConverterOptionalUint64) Read(reader io.Reader) *uint64 {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterUint64INSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalUint64) Lower(value *uint64) C.RustBuffer {
	return LowerIntoRustBuffer[*uint64](c, value)
}

func (_ FfiConverterOptionalUint64) Write(writer io.Writer, value *uint64) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterUint64INSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalUint64 struct{}

func (_ FfiDestroyerOptionalUint64) Destroy(value *uint64) {
	if value != nil {
		FfiDestroyerUint64{}.Destroy(*value)
	}
}

type FfiConverterOptionalFloat64 struct{}

var FfiConverterOptionalFloat64INSTANCE = FfiConverterOptionalFloat64{}

func (c FfiConverterOptionalFloat64) Lift(rb RustBufferI) *float64 {
	return LiftFromRustBuffer[*float64](c, rb)
}

func (_ FfiConverterOptionalFloat64) Read(reader io.Reader) *float64 {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterFloat64INSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalFloat64) Lower(value *float64) C.RustBuffer {
	return LowerIntoRustBuffer[*float64](c, value)
}

func (_ FfiConverterOptionalFloat64) Write(writer io.Writer, value *float64) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterFloat64INSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalFloat64 struct{}

func (_ FfiDestroyerOptionalFloat64) Destroy(value *float64) {
	if value != nil {
		FfiDestroyerFloat64{}.Destroy(*value)
	}
}

type FfiConverterOptionalBool struct{}

var FfiConverterOptionalBoolINSTANCE = FfiConverterOptionalBool{}

func (c FfiConverterOptionalBool) Lift(rb RustBufferI) *bool {
	return LiftFromRustBuffer[*bool](c, rb)
}

func (_ FfiConverterOptionalBool) Read(reader io.Reader) *bool {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterBoolINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalBool) Lower(value *bool) C.RustBuffer {
	return LowerIntoRustBuffer[*bool](c, value)
}

func (_ FfiConverterOptionalBool) Write(writer io.Writer, value *bool) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterBoolINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalBool struct{}

func (_ FfiDestroyerOptionalBool) Destroy(value *bool) {
	if value != nil {
		FfiDestroyerBool{}.Destroy(*value)
	}
}

type FfiConverterOptionalString struct{}

var FfiConverterOptionalStringINSTANCE = FfiConverterOptionalString{}

func (c FfiConverterOptionalString) Lift(rb RustBufferI) *string {
	return LiftFromRustBuffer[*string](c, rb)
}

func (_ FfiConverterOptionalString) Read(reader io.Reader) *string {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterStringINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalString) Lower(value *string) C.RustBuffer {
	return LowerIntoRustBuffer[*string](c, value)
}

func (_ FfiConverterOptionalString) Write(writer io.Writer, value *string) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterStringINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalString struct{}

func (_ FfiDestroyerOptionalString) Destroy(value *string) {
	if value != nil {
		FfiDestroyerString{}.Destroy(*value)
	}
}

type FfiConverterOptionalDuration struct{}

var FfiConverterOptionalDurationINSTANCE = FfiConverterOptionalDuration{}

func (c FfiConverterOptionalDuration) Lift(rb RustBufferI) *time.Duration {
	return LiftFromRustBuffer[*time.Duration](c, rb)
}

func (_ FfiConverterOptionalDuration) Read(reader io.Reader) *time.Duration {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterDurationINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalDuration) Lower(value *time.Duration) C.RustBuffer {
	return LowerIntoRustBuffer[*time.Duration](c, value)
}

func (_ FfiConverterOptionalDuration) Write(writer io.Writer, value *time.Duration) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterDurationINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalDuration struct{}

func (_ FfiDestroyerOptionalDuration) Destroy(value *time.Duration) {
	if value != nil {
		FfiDestroyerDuration{}.Destroy(*value)
	}
}

type FfiConverterOptionalIdentityResetHandle struct{}

var FfiConverterOptionalIdentityResetHandleINSTANCE = FfiConverterOptionalIdentityResetHandle{}

func (c FfiConverterOptionalIdentityResetHandle) Lift(rb RustBufferI) **IdentityResetHandle {
	return LiftFromRustBuffer[**IdentityResetHandle](c, rb)
}

func (_ FfiConverterOptionalIdentityResetHandle) Read(reader io.Reader) **IdentityResetHandle {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterIdentityResetHandleINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalIdentityResetHandle) Lower(value **IdentityResetHandle) C.RustBuffer {
	return LowerIntoRustBuffer[**IdentityResetHandle](c, value)
}

func (_ FfiConverterOptionalIdentityResetHandle) Write(writer io.Writer, value **IdentityResetHandle) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterIdentityResetHandleINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalIdentityResetHandle struct{}

func (_ FfiDestroyerOptionalIdentityResetHandle) Destroy(value **IdentityResetHandle) {
	if value != nil {
		FfiDestroyerIdentityResetHandle{}.Destroy(*value)
	}
}

type FfiConverterOptionalInReplyToDetails struct{}

var FfiConverterOptionalInReplyToDetailsINSTANCE = FfiConverterOptionalInReplyToDetails{}

func (c FfiConverterOptionalInReplyToDetails) Lift(rb RustBufferI) **InReplyToDetails {
	return LiftFromRustBuffer[**InReplyToDetails](c, rb)
}

func (_ FfiConverterOptionalInReplyToDetails) Read(reader io.Reader) **InReplyToDetails {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterInReplyToDetailsINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalInReplyToDetails) Lower(value **InReplyToDetails) C.RustBuffer {
	return LowerIntoRustBuffer[**InReplyToDetails](c, value)
}

func (_ FfiConverterOptionalInReplyToDetails) Write(writer io.Writer, value **InReplyToDetails) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterInReplyToDetailsINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalInReplyToDetails struct{}

func (_ FfiDestroyerOptionalInReplyToDetails) Destroy(value **InReplyToDetails) {
	if value != nil {
		FfiDestroyerInReplyToDetails{}.Destroy(*value)
	}
}

type FfiConverterOptionalMediaSource struct{}

var FfiConverterOptionalMediaSourceINSTANCE = FfiConverterOptionalMediaSource{}

func (c FfiConverterOptionalMediaSource) Lift(rb RustBufferI) **MediaSource {
	return LiftFromRustBuffer[**MediaSource](c, rb)
}

func (_ FfiConverterOptionalMediaSource) Read(reader io.Reader) **MediaSource {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterMediaSourceINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalMediaSource) Lower(value **MediaSource) C.RustBuffer {
	return LowerIntoRustBuffer[**MediaSource](c, value)
}

func (_ FfiConverterOptionalMediaSource) Write(writer io.Writer, value **MediaSource) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterMediaSourceINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalMediaSource struct{}

func (_ FfiDestroyerOptionalMediaSource) Destroy(value **MediaSource) {
	if value != nil {
		FfiDestroyerMediaSource{}.Destroy(*value)
	}
}

type FfiConverterOptionalRoom struct{}

var FfiConverterOptionalRoomINSTANCE = FfiConverterOptionalRoom{}

func (c FfiConverterOptionalRoom) Lift(rb RustBufferI) **Room {
	return LiftFromRustBuffer[**Room](c, rb)
}

func (_ FfiConverterOptionalRoom) Read(reader io.Reader) **Room {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterRoomINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalRoom) Lower(value **Room) C.RustBuffer {
	return LowerIntoRustBuffer[**Room](c, value)
}

func (_ FfiConverterOptionalRoom) Write(writer io.Writer, value **Room) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterRoomINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalRoom struct{}

func (_ FfiDestroyerOptionalRoom) Destroy(value **Room) {
	if value != nil {
		FfiDestroyerRoom{}.Destroy(*value)
	}
}

type FfiConverterOptionalRoomMessageEventContentWithoutRelation struct{}

var FfiConverterOptionalRoomMessageEventContentWithoutRelationINSTANCE = FfiConverterOptionalRoomMessageEventContentWithoutRelation{}

func (c FfiConverterOptionalRoomMessageEventContentWithoutRelation) Lift(rb RustBufferI) **RoomMessageEventContentWithoutRelation {
	return LiftFromRustBuffer[**RoomMessageEventContentWithoutRelation](c, rb)
}

func (_ FfiConverterOptionalRoomMessageEventContentWithoutRelation) Read(reader io.Reader) **RoomMessageEventContentWithoutRelation {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterRoomMessageEventContentWithoutRelationINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalRoomMessageEventContentWithoutRelation) Lower(value **RoomMessageEventContentWithoutRelation) C.RustBuffer {
	return LowerIntoRustBuffer[**RoomMessageEventContentWithoutRelation](c, value)
}

func (_ FfiConverterOptionalRoomMessageEventContentWithoutRelation) Write(writer io.Writer, value **RoomMessageEventContentWithoutRelation) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterRoomMessageEventContentWithoutRelationINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalRoomMessageEventContentWithoutRelation struct{}

func (_ FfiDestroyerOptionalRoomMessageEventContentWithoutRelation) Destroy(value **RoomMessageEventContentWithoutRelation) {
	if value != nil {
		FfiDestroyerRoomMessageEventContentWithoutRelation{}.Destroy(*value)
	}
}

type FfiConverterOptionalSendHandle struct{}

var FfiConverterOptionalSendHandleINSTANCE = FfiConverterOptionalSendHandle{}

func (c FfiConverterOptionalSendHandle) Lift(rb RustBufferI) **SendHandle {
	return LiftFromRustBuffer[**SendHandle](c, rb)
}

func (_ FfiConverterOptionalSendHandle) Read(reader io.Reader) **SendHandle {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterSendHandleINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalSendHandle) Lower(value **SendHandle) C.RustBuffer {
	return LowerIntoRustBuffer[**SendHandle](c, value)
}

func (_ FfiConverterOptionalSendHandle) Write(writer io.Writer, value **SendHandle) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterSendHandleINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalSendHandle struct{}

func (_ FfiDestroyerOptionalSendHandle) Destroy(value **SendHandle) {
	if value != nil {
		FfiDestroyerSendHandle{}.Destroy(*value)
	}
}

type FfiConverterOptionalTaskHandle struct{}

var FfiConverterOptionalTaskHandleINSTANCE = FfiConverterOptionalTaskHandle{}

func (c FfiConverterOptionalTaskHandle) Lift(rb RustBufferI) **TaskHandle {
	return LiftFromRustBuffer[**TaskHandle](c, rb)
}

func (_ FfiConverterOptionalTaskHandle) Read(reader io.Reader) **TaskHandle {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterTaskHandleINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalTaskHandle) Lower(value **TaskHandle) C.RustBuffer {
	return LowerIntoRustBuffer[**TaskHandle](c, value)
}

func (_ FfiConverterOptionalTaskHandle) Write(writer io.Writer, value **TaskHandle) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterTaskHandleINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalTaskHandle struct{}

func (_ FfiDestroyerOptionalTaskHandle) Destroy(value **TaskHandle) {
	if value != nil {
		FfiDestroyerTaskHandle{}.Destroy(*value)
	}
}

type FfiConverterOptionalThreadSummary struct{}

var FfiConverterOptionalThreadSummaryINSTANCE = FfiConverterOptionalThreadSummary{}

func (c FfiConverterOptionalThreadSummary) Lift(rb RustBufferI) **ThreadSummary {
	return LiftFromRustBuffer[**ThreadSummary](c, rb)
}

func (_ FfiConverterOptionalThreadSummary) Read(reader io.Reader) **ThreadSummary {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterThreadSummaryINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalThreadSummary) Lower(value **ThreadSummary) C.RustBuffer {
	return LowerIntoRustBuffer[**ThreadSummary](c, value)
}

func (_ FfiConverterOptionalThreadSummary) Write(writer io.Writer, value **ThreadSummary) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterThreadSummaryINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalThreadSummary struct{}

func (_ FfiDestroyerOptionalThreadSummary) Destroy(value **ThreadSummary) {
	if value != nil {
		FfiDestroyerThreadSummary{}.Destroy(*value)
	}
}

type FfiConverterOptionalTimelineItem struct{}

var FfiConverterOptionalTimelineItemINSTANCE = FfiConverterOptionalTimelineItem{}

func (c FfiConverterOptionalTimelineItem) Lift(rb RustBufferI) **TimelineItem {
	return LiftFromRustBuffer[**TimelineItem](c, rb)
}

func (_ FfiConverterOptionalTimelineItem) Read(reader io.Reader) **TimelineItem {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterTimelineItemINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalTimelineItem) Lower(value **TimelineItem) C.RustBuffer {
	return LowerIntoRustBuffer[**TimelineItem](c, value)
}

func (_ FfiConverterOptionalTimelineItem) Write(writer io.Writer, value **TimelineItem) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterTimelineItemINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalTimelineItem struct{}

func (_ FfiDestroyerOptionalTimelineItem) Destroy(value **TimelineItem) {
	if value != nil {
		FfiDestroyerTimelineItem{}.Destroy(*value)
	}
}

type FfiConverterOptionalUserIdentity struct{}

var FfiConverterOptionalUserIdentityINSTANCE = FfiConverterOptionalUserIdentity{}

func (c FfiConverterOptionalUserIdentity) Lift(rb RustBufferI) **UserIdentity {
	return LiftFromRustBuffer[**UserIdentity](c, rb)
}

func (_ FfiConverterOptionalUserIdentity) Read(reader io.Reader) **UserIdentity {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterUserIdentityINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalUserIdentity) Lower(value **UserIdentity) C.RustBuffer {
	return LowerIntoRustBuffer[**UserIdentity](c, value)
}

func (_ FfiConverterOptionalUserIdentity) Write(writer io.Writer, value **UserIdentity) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterUserIdentityINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalUserIdentity struct{}

func (_ FfiDestroyerOptionalUserIdentity) Destroy(value **UserIdentity) {
	if value != nil {
		FfiDestroyerUserIdentity{}.Destroy(*value)
	}
}

type FfiConverterOptionalAudioInfo struct{}

var FfiConverterOptionalAudioInfoINSTANCE = FfiConverterOptionalAudioInfo{}

func (c FfiConverterOptionalAudioInfo) Lift(rb RustBufferI) *AudioInfo {
	return LiftFromRustBuffer[*AudioInfo](c, rb)
}

func (_ FfiConverterOptionalAudioInfo) Read(reader io.Reader) *AudioInfo {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterAudioInfoINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalAudioInfo) Lower(value *AudioInfo) C.RustBuffer {
	return LowerIntoRustBuffer[*AudioInfo](c, value)
}

func (_ FfiConverterOptionalAudioInfo) Write(writer io.Writer, value *AudioInfo) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterAudioInfoINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalAudioInfo struct{}

func (_ FfiDestroyerOptionalAudioInfo) Destroy(value *AudioInfo) {
	if value != nil {
		FfiDestroyerAudioInfo{}.Destroy(*value)
	}
}

type FfiConverterOptionalComposerDraft struct{}

var FfiConverterOptionalComposerDraftINSTANCE = FfiConverterOptionalComposerDraft{}

func (c FfiConverterOptionalComposerDraft) Lift(rb RustBufferI) *ComposerDraft {
	return LiftFromRustBuffer[*ComposerDraft](c, rb)
}

func (_ FfiConverterOptionalComposerDraft) Read(reader io.Reader) *ComposerDraft {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterComposerDraftINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalComposerDraft) Lower(value *ComposerDraft) C.RustBuffer {
	return LowerIntoRustBuffer[*ComposerDraft](c, value)
}

func (_ FfiConverterOptionalComposerDraft) Write(writer io.Writer, value *ComposerDraft) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterComposerDraftINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalComposerDraft struct{}

func (_ FfiDestroyerOptionalComposerDraft) Destroy(value *ComposerDraft) {
	if value != nil {
		FfiDestroyerComposerDraft{}.Destroy(*value)
	}
}

type FfiConverterOptionalElementCallWellKnown struct{}

var FfiConverterOptionalElementCallWellKnownINSTANCE = FfiConverterOptionalElementCallWellKnown{}

func (c FfiConverterOptionalElementCallWellKnown) Lift(rb RustBufferI) *ElementCallWellKnown {
	return LiftFromRustBuffer[*ElementCallWellKnown](c, rb)
}

func (_ FfiConverterOptionalElementCallWellKnown) Read(reader io.Reader) *ElementCallWellKnown {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterElementCallWellKnownINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalElementCallWellKnown) Lower(value *ElementCallWellKnown) C.RustBuffer {
	return LowerIntoRustBuffer[*ElementCallWellKnown](c, value)
}

func (_ FfiConverterOptionalElementCallWellKnown) Write(writer io.Writer, value *ElementCallWellKnown) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterElementCallWellKnownINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalElementCallWellKnown struct{}

func (_ FfiDestroyerOptionalElementCallWellKnown) Destroy(value *ElementCallWellKnown) {
	if value != nil {
		FfiDestroyerElementCallWellKnown{}.Destroy(*value)
	}
}

type FfiConverterOptionalEventTimelineItem struct{}

var FfiConverterOptionalEventTimelineItemINSTANCE = FfiConverterOptionalEventTimelineItem{}

func (c FfiConverterOptionalEventTimelineItem) Lift(rb RustBufferI) *EventTimelineItem {
	return LiftFromRustBuffer[*EventTimelineItem](c, rb)
}

func (_ FfiConverterOptionalEventTimelineItem) Read(reader io.Reader) *EventTimelineItem {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterEventTimelineItemINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalEventTimelineItem) Lower(value *EventTimelineItem) C.RustBuffer {
	return LowerIntoRustBuffer[*EventTimelineItem](c, value)
}

func (_ FfiConverterOptionalEventTimelineItem) Write(writer io.Writer, value *EventTimelineItem) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterEventTimelineItemINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalEventTimelineItem struct{}

func (_ FfiDestroyerOptionalEventTimelineItem) Destroy(value *EventTimelineItem) {
	if value != nil {
		FfiDestroyerEventTimelineItem{}.Destroy(*value)
	}
}

type FfiConverterOptionalFileInfo struct{}

var FfiConverterOptionalFileInfoINSTANCE = FfiConverterOptionalFileInfo{}

func (c FfiConverterOptionalFileInfo) Lift(rb RustBufferI) *FileInfo {
	return LiftFromRustBuffer[*FileInfo](c, rb)
}

func (_ FfiConverterOptionalFileInfo) Read(reader io.Reader) *FileInfo {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterFileInfoINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalFileInfo) Lower(value *FileInfo) C.RustBuffer {
	return LowerIntoRustBuffer[*FileInfo](c, value)
}

func (_ FfiConverterOptionalFileInfo) Write(writer io.Writer, value *FileInfo) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterFileInfoINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalFileInfo struct{}

func (_ FfiDestroyerOptionalFileInfo) Destroy(value *FileInfo) {
	if value != nil {
		FfiDestroyerFileInfo{}.Destroy(*value)
	}
}

type FfiConverterOptionalFormattedBody struct{}

var FfiConverterOptionalFormattedBodyINSTANCE = FfiConverterOptionalFormattedBody{}

func (c FfiConverterOptionalFormattedBody) Lift(rb RustBufferI) *FormattedBody {
	return LiftFromRustBuffer[*FormattedBody](c, rb)
}

func (_ FfiConverterOptionalFormattedBody) Read(reader io.Reader) *FormattedBody {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterFormattedBodyINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalFormattedBody) Lower(value *FormattedBody) C.RustBuffer {
	return LowerIntoRustBuffer[*FormattedBody](c, value)
}

func (_ FfiConverterOptionalFormattedBody) Write(writer io.Writer, value *FormattedBody) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterFormattedBodyINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalFormattedBody struct{}

func (_ FfiDestroyerOptionalFormattedBody) Destroy(value *FormattedBody) {
	if value != nil {
		FfiDestroyerFormattedBody{}.Destroy(*value)
	}
}

type FfiConverterOptionalImageInfo struct{}

var FfiConverterOptionalImageInfoINSTANCE = FfiConverterOptionalImageInfo{}

func (c FfiConverterOptionalImageInfo) Lift(rb RustBufferI) *ImageInfo {
	return LiftFromRustBuffer[*ImageInfo](c, rb)
}

func (_ FfiConverterOptionalImageInfo) Read(reader io.Reader) *ImageInfo {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterImageInfoINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalImageInfo) Lower(value *ImageInfo) C.RustBuffer {
	return LowerIntoRustBuffer[*ImageInfo](c, value)
}

func (_ FfiConverterOptionalImageInfo) Write(writer io.Writer, value *ImageInfo) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterImageInfoINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalImageInfo struct{}

func (_ FfiDestroyerOptionalImageInfo) Destroy(value *ImageInfo) {
	if value != nil {
		FfiDestroyerImageInfo{}.Destroy(*value)
	}
}

type FfiConverterOptionalInsertData struct{}

var FfiConverterOptionalInsertDataINSTANCE = FfiConverterOptionalInsertData{}

func (c FfiConverterOptionalInsertData) Lift(rb RustBufferI) *InsertData {
	return LiftFromRustBuffer[*InsertData](c, rb)
}

func (_ FfiConverterOptionalInsertData) Read(reader io.Reader) *InsertData {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterInsertDataINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalInsertData) Lower(value *InsertData) C.RustBuffer {
	return LowerIntoRustBuffer[*InsertData](c, value)
}

func (_ FfiConverterOptionalInsertData) Write(writer io.Writer, value *InsertData) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterInsertDataINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalInsertData struct{}

func (_ FfiDestroyerOptionalInsertData) Destroy(value *InsertData) {
	if value != nil {
		FfiDestroyerInsertData{}.Destroy(*value)
	}
}

type FfiConverterOptionalMatrixEntity struct{}

var FfiConverterOptionalMatrixEntityINSTANCE = FfiConverterOptionalMatrixEntity{}

func (c FfiConverterOptionalMatrixEntity) Lift(rb RustBufferI) *MatrixEntity {
	return LiftFromRustBuffer[*MatrixEntity](c, rb)
}

func (_ FfiConverterOptionalMatrixEntity) Read(reader io.Reader) *MatrixEntity {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterMatrixEntityINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalMatrixEntity) Lower(value *MatrixEntity) C.RustBuffer {
	return LowerIntoRustBuffer[*MatrixEntity](c, value)
}

func (_ FfiConverterOptionalMatrixEntity) Write(writer io.Writer, value *MatrixEntity) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterMatrixEntityINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalMatrixEntity struct{}

func (_ FfiDestroyerOptionalMatrixEntity) Destroy(value *MatrixEntity) {
	if value != nil {
		FfiDestroyerMatrixEntity{}.Destroy(*value)
	}
}

type FfiConverterOptionalMentions struct{}

var FfiConverterOptionalMentionsINSTANCE = FfiConverterOptionalMentions{}

func (c FfiConverterOptionalMentions) Lift(rb RustBufferI) *Mentions {
	return LiftFromRustBuffer[*Mentions](c, rb)
}

func (_ FfiConverterOptionalMentions) Read(reader io.Reader) *Mentions {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterMentionsINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalMentions) Lower(value *Mentions) C.RustBuffer {
	return LowerIntoRustBuffer[*Mentions](c, value)
}

func (_ FfiConverterOptionalMentions) Write(writer io.Writer, value *Mentions) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterMentionsINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalMentions struct{}

func (_ FfiDestroyerOptionalMentions) Destroy(value *Mentions) {
	if value != nil {
		FfiDestroyerMentions{}.Destroy(*value)
	}
}

type FfiConverterOptionalNotificationItem struct{}

var FfiConverterOptionalNotificationItemINSTANCE = FfiConverterOptionalNotificationItem{}

func (c FfiConverterOptionalNotificationItem) Lift(rb RustBufferI) *NotificationItem {
	return LiftFromRustBuffer[*NotificationItem](c, rb)
}

func (_ FfiConverterOptionalNotificationItem) Read(reader io.Reader) *NotificationItem {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterNotificationItemINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalNotificationItem) Lower(value *NotificationItem) C.RustBuffer {
	return LowerIntoRustBuffer[*NotificationItem](c, value)
}

func (_ FfiConverterOptionalNotificationItem) Write(writer io.Writer, value *NotificationItem) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterNotificationItemINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalNotificationItem struct{}

func (_ FfiDestroyerOptionalNotificationItem) Destroy(value *NotificationItem) {
	if value != nil {
		FfiDestroyerNotificationItem{}.Destroy(*value)
	}
}

type FfiConverterOptionalNotificationPowerLevels struct{}

var FfiConverterOptionalNotificationPowerLevelsINSTANCE = FfiConverterOptionalNotificationPowerLevels{}

func (c FfiConverterOptionalNotificationPowerLevels) Lift(rb RustBufferI) *NotificationPowerLevels {
	return LiftFromRustBuffer[*NotificationPowerLevels](c, rb)
}

func (_ FfiConverterOptionalNotificationPowerLevels) Read(reader io.Reader) *NotificationPowerLevels {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterNotificationPowerLevelsINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalNotificationPowerLevels) Lower(value *NotificationPowerLevels) C.RustBuffer {
	return LowerIntoRustBuffer[*NotificationPowerLevels](c, value)
}

func (_ FfiConverterOptionalNotificationPowerLevels) Write(writer io.Writer, value *NotificationPowerLevels) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterNotificationPowerLevelsINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalNotificationPowerLevels struct{}

func (_ FfiDestroyerOptionalNotificationPowerLevels) Destroy(value *NotificationPowerLevels) {
	if value != nil {
		FfiDestroyerNotificationPowerLevels{}.Destroy(*value)
	}
}

type FfiConverterOptionalPassPhrase struct{}

var FfiConverterOptionalPassPhraseINSTANCE = FfiConverterOptionalPassPhrase{}

func (c FfiConverterOptionalPassPhrase) Lift(rb RustBufferI) *PassPhrase {
	return LiftFromRustBuffer[*PassPhrase](c, rb)
}

func (_ FfiConverterOptionalPassPhrase) Read(reader io.Reader) *PassPhrase {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterPassPhraseINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalPassPhrase) Lower(value *PassPhrase) C.RustBuffer {
	return LowerIntoRustBuffer[*PassPhrase](c, value)
}

func (_ FfiConverterOptionalPassPhrase) Write(writer io.Writer, value *PassPhrase) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterPassPhraseINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalPassPhrase struct{}

func (_ FfiDestroyerOptionalPassPhrase) Destroy(value *PassPhrase) {
	if value != nil {
		FfiDestroyerPassPhrase{}.Destroy(*value)
	}
}

type FfiConverterOptionalPowerLevels struct{}

var FfiConverterOptionalPowerLevelsINSTANCE = FfiConverterOptionalPowerLevels{}

func (c FfiConverterOptionalPowerLevels) Lift(rb RustBufferI) *PowerLevels {
	return LiftFromRustBuffer[*PowerLevels](c, rb)
}

func (_ FfiConverterOptionalPowerLevels) Read(reader io.Reader) *PowerLevels {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterPowerLevelsINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalPowerLevels) Lower(value *PowerLevels) C.RustBuffer {
	return LowerIntoRustBuffer[*PowerLevels](c, value)
}

func (_ FfiConverterOptionalPowerLevels) Write(writer io.Writer, value *PowerLevels) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterPowerLevelsINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalPowerLevels struct{}

func (_ FfiDestroyerOptionalPowerLevels) Destroy(value *PowerLevels) {
	if value != nil {
		FfiDestroyerPowerLevels{}.Destroy(*value)
	}
}

type FfiConverterOptionalReplyParameters struct{}

var FfiConverterOptionalReplyParametersINSTANCE = FfiConverterOptionalReplyParameters{}

func (c FfiConverterOptionalReplyParameters) Lift(rb RustBufferI) *ReplyParameters {
	return LiftFromRustBuffer[*ReplyParameters](c, rb)
}

func (_ FfiConverterOptionalReplyParameters) Read(reader io.Reader) *ReplyParameters {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterReplyParametersINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalReplyParameters) Lower(value *ReplyParameters) C.RustBuffer {
	return LowerIntoRustBuffer[*ReplyParameters](c, value)
}

func (_ FfiConverterOptionalReplyParameters) Write(writer io.Writer, value *ReplyParameters) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterReplyParametersINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalReplyParameters struct{}

func (_ FfiDestroyerOptionalReplyParameters) Destroy(value *ReplyParameters) {
	if value != nil {
		FfiDestroyerReplyParameters{}.Destroy(*value)
	}
}

type FfiConverterOptionalResolvedRoomAlias struct{}

var FfiConverterOptionalResolvedRoomAliasINSTANCE = FfiConverterOptionalResolvedRoomAlias{}

func (c FfiConverterOptionalResolvedRoomAlias) Lift(rb RustBufferI) *ResolvedRoomAlias {
	return LiftFromRustBuffer[*ResolvedRoomAlias](c, rb)
}

func (_ FfiConverterOptionalResolvedRoomAlias) Read(reader io.Reader) *ResolvedRoomAlias {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterResolvedRoomAliasINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalResolvedRoomAlias) Lower(value *ResolvedRoomAlias) C.RustBuffer {
	return LowerIntoRustBuffer[*ResolvedRoomAlias](c, value)
}

func (_ FfiConverterOptionalResolvedRoomAlias) Write(writer io.Writer, value *ResolvedRoomAlias) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterResolvedRoomAliasINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalResolvedRoomAlias struct{}

func (_ FfiDestroyerOptionalResolvedRoomAlias) Destroy(value *ResolvedRoomAlias) {
	if value != nil {
		FfiDestroyerResolvedRoomAlias{}.Destroy(*value)
	}
}

type FfiConverterOptionalRoomMember struct{}

var FfiConverterOptionalRoomMemberINSTANCE = FfiConverterOptionalRoomMember{}

func (c FfiConverterOptionalRoomMember) Lift(rb RustBufferI) *RoomMember {
	return LiftFromRustBuffer[*RoomMember](c, rb)
}

func (_ FfiConverterOptionalRoomMember) Read(reader io.Reader) *RoomMember {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterRoomMemberINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalRoomMember) Lower(value *RoomMember) C.RustBuffer {
	return LowerIntoRustBuffer[*RoomMember](c, value)
}

func (_ FfiConverterOptionalRoomMember) Write(writer io.Writer, value *RoomMember) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterRoomMemberINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalRoomMember struct{}

func (_ FfiDestroyerOptionalRoomMember) Destroy(value *RoomMember) {
	if value != nil {
		FfiDestroyerRoomMember{}.Destroy(*value)
	}
}

type FfiConverterOptionalRoomMemberWithSenderInfo struct{}

var FfiConverterOptionalRoomMemberWithSenderInfoINSTANCE = FfiConverterOptionalRoomMemberWithSenderInfo{}

func (c FfiConverterOptionalRoomMemberWithSenderInfo) Lift(rb RustBufferI) *RoomMemberWithSenderInfo {
	return LiftFromRustBuffer[*RoomMemberWithSenderInfo](c, rb)
}

func (_ FfiConverterOptionalRoomMemberWithSenderInfo) Read(reader io.Reader) *RoomMemberWithSenderInfo {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterRoomMemberWithSenderInfoINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalRoomMemberWithSenderInfo) Lower(value *RoomMemberWithSenderInfo) C.RustBuffer {
	return LowerIntoRustBuffer[*RoomMemberWithSenderInfo](c, value)
}

func (_ FfiConverterOptionalRoomMemberWithSenderInfo) Write(writer io.Writer, value *RoomMemberWithSenderInfo) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterRoomMemberWithSenderInfoINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalRoomMemberWithSenderInfo struct{}

func (_ FfiDestroyerOptionalRoomMemberWithSenderInfo) Destroy(value *RoomMemberWithSenderInfo) {
	if value != nil {
		FfiDestroyerRoomMemberWithSenderInfo{}.Destroy(*value)
	}
}

type FfiConverterOptionalRoomTombstoneInfo struct{}

var FfiConverterOptionalRoomTombstoneInfoINSTANCE = FfiConverterOptionalRoomTombstoneInfo{}

func (c FfiConverterOptionalRoomTombstoneInfo) Lift(rb RustBufferI) *RoomTombstoneInfo {
	return LiftFromRustBuffer[*RoomTombstoneInfo](c, rb)
}

func (_ FfiConverterOptionalRoomTombstoneInfo) Read(reader io.Reader) *RoomTombstoneInfo {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterRoomTombstoneInfoINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalRoomTombstoneInfo) Lower(value *RoomTombstoneInfo) C.RustBuffer {
	return LowerIntoRustBuffer[*RoomTombstoneInfo](c, value)
}

func (_ FfiConverterOptionalRoomTombstoneInfo) Write(writer io.Writer, value *RoomTombstoneInfo) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterRoomTombstoneInfoINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalRoomTombstoneInfo struct{}

func (_ FfiDestroyerOptionalRoomTombstoneInfo) Destroy(value *RoomTombstoneInfo) {
	if value != nil {
		FfiDestroyerRoomTombstoneInfo{}.Destroy(*value)
	}
}

type FfiConverterOptionalSetData struct{}

var FfiConverterOptionalSetDataINSTANCE = FfiConverterOptionalSetData{}

func (c FfiConverterOptionalSetData) Lift(rb RustBufferI) *SetData {
	return LiftFromRustBuffer[*SetData](c, rb)
}

func (_ FfiConverterOptionalSetData) Read(reader io.Reader) *SetData {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterSetDataINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalSetData) Lower(value *SetData) C.RustBuffer {
	return LowerIntoRustBuffer[*SetData](c, value)
}

func (_ FfiConverterOptionalSetData) Write(writer io.Writer, value *SetData) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterSetDataINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalSetData struct{}

func (_ FfiDestroyerOptionalSetData) Destroy(value *SetData) {
	if value != nil {
		FfiDestroyerSetData{}.Destroy(*value)
	}
}

type FfiConverterOptionalThumbnailInfo struct{}

var FfiConverterOptionalThumbnailInfoINSTANCE = FfiConverterOptionalThumbnailInfo{}

func (c FfiConverterOptionalThumbnailInfo) Lift(rb RustBufferI) *ThumbnailInfo {
	return LiftFromRustBuffer[*ThumbnailInfo](c, rb)
}

func (_ FfiConverterOptionalThumbnailInfo) Read(reader io.Reader) *ThumbnailInfo {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterThumbnailInfoINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalThumbnailInfo) Lower(value *ThumbnailInfo) C.RustBuffer {
	return LowerIntoRustBuffer[*ThumbnailInfo](c, value)
}

func (_ FfiConverterOptionalThumbnailInfo) Write(writer io.Writer, value *ThumbnailInfo) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterThumbnailInfoINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalThumbnailInfo struct{}

func (_ FfiDestroyerOptionalThumbnailInfo) Destroy(value *ThumbnailInfo) {
	if value != nil {
		FfiDestroyerThumbnailInfo{}.Destroy(*value)
	}
}

type FfiConverterOptionalTracingFileConfiguration struct{}

var FfiConverterOptionalTracingFileConfigurationINSTANCE = FfiConverterOptionalTracingFileConfiguration{}

func (c FfiConverterOptionalTracingFileConfiguration) Lift(rb RustBufferI) *TracingFileConfiguration {
	return LiftFromRustBuffer[*TracingFileConfiguration](c, rb)
}

func (_ FfiConverterOptionalTracingFileConfiguration) Read(reader io.Reader) *TracingFileConfiguration {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterTracingFileConfigurationINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalTracingFileConfiguration) Lower(value *TracingFileConfiguration) C.RustBuffer {
	return LowerIntoRustBuffer[*TracingFileConfiguration](c, value)
}

func (_ FfiConverterOptionalTracingFileConfiguration) Write(writer io.Writer, value *TracingFileConfiguration) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterTracingFileConfigurationINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalTracingFileConfiguration struct{}

func (_ FfiDestroyerOptionalTracingFileConfiguration) Destroy(value *TracingFileConfiguration) {
	if value != nil {
		FfiDestroyerTracingFileConfiguration{}.Destroy(*value)
	}
}

type FfiConverterOptionalUnstableAudioDetailsContent struct{}

var FfiConverterOptionalUnstableAudioDetailsContentINSTANCE = FfiConverterOptionalUnstableAudioDetailsContent{}

func (c FfiConverterOptionalUnstableAudioDetailsContent) Lift(rb RustBufferI) *UnstableAudioDetailsContent {
	return LiftFromRustBuffer[*UnstableAudioDetailsContent](c, rb)
}

func (_ FfiConverterOptionalUnstableAudioDetailsContent) Read(reader io.Reader) *UnstableAudioDetailsContent {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterUnstableAudioDetailsContentINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalUnstableAudioDetailsContent) Lower(value *UnstableAudioDetailsContent) C.RustBuffer {
	return LowerIntoRustBuffer[*UnstableAudioDetailsContent](c, value)
}

func (_ FfiConverterOptionalUnstableAudioDetailsContent) Write(writer io.Writer, value *UnstableAudioDetailsContent) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterUnstableAudioDetailsContentINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalUnstableAudioDetailsContent struct{}

func (_ FfiDestroyerOptionalUnstableAudioDetailsContent) Destroy(value *UnstableAudioDetailsContent) {
	if value != nil {
		FfiDestroyerUnstableAudioDetailsContent{}.Destroy(*value)
	}
}

type FfiConverterOptionalUnstableVoiceContent struct{}

var FfiConverterOptionalUnstableVoiceContentINSTANCE = FfiConverterOptionalUnstableVoiceContent{}

func (c FfiConverterOptionalUnstableVoiceContent) Lift(rb RustBufferI) *UnstableVoiceContent {
	return LiftFromRustBuffer[*UnstableVoiceContent](c, rb)
}

func (_ FfiConverterOptionalUnstableVoiceContent) Read(reader io.Reader) *UnstableVoiceContent {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterUnstableVoiceContentINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalUnstableVoiceContent) Lower(value *UnstableVoiceContent) C.RustBuffer {
	return LowerIntoRustBuffer[*UnstableVoiceContent](c, value)
}

func (_ FfiConverterOptionalUnstableVoiceContent) Write(writer io.Writer, value *UnstableVoiceContent) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterUnstableVoiceContentINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalUnstableVoiceContent struct{}

func (_ FfiDestroyerOptionalUnstableVoiceContent) Destroy(value *UnstableVoiceContent) {
	if value != nil {
		FfiDestroyerUnstableVoiceContent{}.Destroy(*value)
	}
}

type FfiConverterOptionalVideoInfo struct{}

var FfiConverterOptionalVideoInfoINSTANCE = FfiConverterOptionalVideoInfo{}

func (c FfiConverterOptionalVideoInfo) Lift(rb RustBufferI) *VideoInfo {
	return LiftFromRustBuffer[*VideoInfo](c, rb)
}

func (_ FfiConverterOptionalVideoInfo) Read(reader io.Reader) *VideoInfo {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterVideoInfoINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalVideoInfo) Lower(value *VideoInfo) C.RustBuffer {
	return LowerIntoRustBuffer[*VideoInfo](c, value)
}

func (_ FfiConverterOptionalVideoInfo) Write(writer io.Writer, value *VideoInfo) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterVideoInfoINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalVideoInfo struct{}

func (_ FfiDestroyerOptionalVideoInfo) Destroy(value *VideoInfo) {
	if value != nil {
		FfiDestroyerVideoInfo{}.Destroy(*value)
	}
}

type FfiConverterOptionalAccountManagementAction struct{}

var FfiConverterOptionalAccountManagementActionINSTANCE = FfiConverterOptionalAccountManagementAction{}

func (c FfiConverterOptionalAccountManagementAction) Lift(rb RustBufferI) *AccountManagementAction {
	return LiftFromRustBuffer[*AccountManagementAction](c, rb)
}

func (_ FfiConverterOptionalAccountManagementAction) Read(reader io.Reader) *AccountManagementAction {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterAccountManagementActionINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalAccountManagementAction) Lower(value *AccountManagementAction) C.RustBuffer {
	return LowerIntoRustBuffer[*AccountManagementAction](c, value)
}

func (_ FfiConverterOptionalAccountManagementAction) Write(writer io.Writer, value *AccountManagementAction) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterAccountManagementActionINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalAccountManagementAction struct{}

func (_ FfiDestroyerOptionalAccountManagementAction) Destroy(value *AccountManagementAction) {
	if value != nil {
		FfiDestroyerAccountManagementAction{}.Destroy(*value)
	}
}

type FfiConverterOptionalAssetType struct{}

var FfiConverterOptionalAssetTypeINSTANCE = FfiConverterOptionalAssetType{}

func (c FfiConverterOptionalAssetType) Lift(rb RustBufferI) *AssetType {
	return LiftFromRustBuffer[*AssetType](c, rb)
}

func (_ FfiConverterOptionalAssetType) Read(reader io.Reader) *AssetType {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterAssetTypeINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalAssetType) Lower(value *AssetType) C.RustBuffer {
	return LowerIntoRustBuffer[*AssetType](c, value)
}

func (_ FfiConverterOptionalAssetType) Write(writer io.Writer, value *AssetType) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterAssetTypeINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalAssetType struct{}

func (_ FfiDestroyerOptionalAssetType) Destroy(value *AssetType) {
	if value != nil {
		FfiDestroyerAssetType{}.Destroy(*value)
	}
}

type FfiConverterOptionalAuthData struct{}

var FfiConverterOptionalAuthDataINSTANCE = FfiConverterOptionalAuthData{}

func (c FfiConverterOptionalAuthData) Lift(rb RustBufferI) *AuthData {
	return LiftFromRustBuffer[*AuthData](c, rb)
}

func (_ FfiConverterOptionalAuthData) Read(reader io.Reader) *AuthData {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterAuthDataINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalAuthData) Lower(value *AuthData) C.RustBuffer {
	return LowerIntoRustBuffer[*AuthData](c, value)
}

func (_ FfiConverterOptionalAuthData) Write(writer io.Writer, value *AuthData) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterAuthDataINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalAuthData struct{}

func (_ FfiDestroyerOptionalAuthData) Destroy(value *AuthData) {
	if value != nil {
		FfiDestroyerAuthData{}.Destroy(*value)
	}
}

type FfiConverterOptionalEventSendState struct{}

var FfiConverterOptionalEventSendStateINSTANCE = FfiConverterOptionalEventSendState{}

func (c FfiConverterOptionalEventSendState) Lift(rb RustBufferI) *EventSendState {
	return LiftFromRustBuffer[*EventSendState](c, rb)
}

func (_ FfiConverterOptionalEventSendState) Read(reader io.Reader) *EventSendState {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterEventSendStateINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalEventSendState) Lower(value *EventSendState) C.RustBuffer {
	return LowerIntoRustBuffer[*EventSendState](c, value)
}

func (_ FfiConverterOptionalEventSendState) Write(writer io.Writer, value *EventSendState) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterEventSendStateINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalEventSendState struct{}

func (_ FfiDestroyerOptionalEventSendState) Destroy(value *EventSendState) {
	if value != nil {
		FfiDestroyerEventSendState{}.Destroy(*value)
	}
}

type FfiConverterOptionalIntent struct{}

var FfiConverterOptionalIntentINSTANCE = FfiConverterOptionalIntent{}

func (c FfiConverterOptionalIntent) Lift(rb RustBufferI) *Intent {
	return LiftFromRustBuffer[*Intent](c, rb)
}

func (_ FfiConverterOptionalIntent) Read(reader io.Reader) *Intent {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterIntentINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalIntent) Lower(value *Intent) C.RustBuffer {
	return LowerIntoRustBuffer[*Intent](c, value)
}

func (_ FfiConverterOptionalIntent) Write(writer io.Writer, value *Intent) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterIntentINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalIntent struct{}

func (_ FfiDestroyerOptionalIntent) Destroy(value *Intent) {
	if value != nil {
		FfiDestroyerIntent{}.Destroy(*value)
	}
}

type FfiConverterOptionalJoinRule struct{}

var FfiConverterOptionalJoinRuleINSTANCE = FfiConverterOptionalJoinRule{}

func (c FfiConverterOptionalJoinRule) Lift(rb RustBufferI) *JoinRule {
	return LiftFromRustBuffer[*JoinRule](c, rb)
}

func (_ FfiConverterOptionalJoinRule) Read(reader io.Reader) *JoinRule {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterJoinRuleINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalJoinRule) Lower(value *JoinRule) C.RustBuffer {
	return LowerIntoRustBuffer[*JoinRule](c, value)
}

func (_ FfiConverterOptionalJoinRule) Write(writer io.Writer, value *JoinRule) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterJoinRuleINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalJoinRule struct{}

func (_ FfiDestroyerOptionalJoinRule) Destroy(value *JoinRule) {
	if value != nil {
		FfiDestroyerJoinRule{}.Destroy(*value)
	}
}

type FfiConverterOptionalMembership struct{}

var FfiConverterOptionalMembershipINSTANCE = FfiConverterOptionalMembership{}

func (c FfiConverterOptionalMembership) Lift(rb RustBufferI) *Membership {
	return LiftFromRustBuffer[*Membership](c, rb)
}

func (_ FfiConverterOptionalMembership) Read(reader io.Reader) *Membership {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterMembershipINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalMembership) Lower(value *Membership) C.RustBuffer {
	return LowerIntoRustBuffer[*Membership](c, value)
}

func (_ FfiConverterOptionalMembership) Write(writer io.Writer, value *Membership) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterMembershipINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalMembership struct{}

func (_ FfiDestroyerOptionalMembership) Destroy(value *Membership) {
	if value != nil {
		FfiDestroyerMembership{}.Destroy(*value)
	}
}

type FfiConverterOptionalMembershipChange struct{}

var FfiConverterOptionalMembershipChangeINSTANCE = FfiConverterOptionalMembershipChange{}

func (c FfiConverterOptionalMembershipChange) Lift(rb RustBufferI) *MembershipChange {
	return LiftFromRustBuffer[*MembershipChange](c, rb)
}

func (_ FfiConverterOptionalMembershipChange) Read(reader io.Reader) *MembershipChange {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterMembershipChangeINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalMembershipChange) Lower(value *MembershipChange) C.RustBuffer {
	return LowerIntoRustBuffer[*MembershipChange](c, value)
}

func (_ FfiConverterOptionalMembershipChange) Write(writer io.Writer, value *MembershipChange) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterMembershipChangeINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalMembershipChange struct{}

func (_ FfiDestroyerOptionalMembershipChange) Destroy(value *MembershipChange) {
	if value != nil {
		FfiDestroyerMembershipChange{}.Destroy(*value)
	}
}

type FfiConverterOptionalOidcPrompt struct{}

var FfiConverterOptionalOidcPromptINSTANCE = FfiConverterOptionalOidcPrompt{}

func (c FfiConverterOptionalOidcPrompt) Lift(rb RustBufferI) *OidcPrompt {
	return LiftFromRustBuffer[*OidcPrompt](c, rb)
}

func (_ FfiConverterOptionalOidcPrompt) Read(reader io.Reader) *OidcPrompt {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterOidcPromptINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalOidcPrompt) Lower(value *OidcPrompt) C.RustBuffer {
	return LowerIntoRustBuffer[*OidcPrompt](c, value)
}

func (_ FfiConverterOptionalOidcPrompt) Write(writer io.Writer, value *OidcPrompt) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterOidcPromptINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalOidcPrompt struct{}

func (_ FfiDestroyerOptionalOidcPrompt) Destroy(value *OidcPrompt) {
	if value != nil {
		FfiDestroyerOidcPrompt{}.Destroy(*value)
	}
}

type FfiConverterOptionalPublicRoomJoinRule struct{}

var FfiConverterOptionalPublicRoomJoinRuleINSTANCE = FfiConverterOptionalPublicRoomJoinRule{}

func (c FfiConverterOptionalPublicRoomJoinRule) Lift(rb RustBufferI) *PublicRoomJoinRule {
	return LiftFromRustBuffer[*PublicRoomJoinRule](c, rb)
}

func (_ FfiConverterOptionalPublicRoomJoinRule) Read(reader io.Reader) *PublicRoomJoinRule {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterPublicRoomJoinRuleINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalPublicRoomJoinRule) Lower(value *PublicRoomJoinRule) C.RustBuffer {
	return LowerIntoRustBuffer[*PublicRoomJoinRule](c, value)
}

func (_ FfiConverterOptionalPublicRoomJoinRule) Write(writer io.Writer, value *PublicRoomJoinRule) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterPublicRoomJoinRuleINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalPublicRoomJoinRule struct{}

func (_ FfiDestroyerOptionalPublicRoomJoinRule) Destroy(value *PublicRoomJoinRule) {
	if value != nil {
		FfiDestroyerPublicRoomJoinRule{}.Destroy(*value)
	}
}

type FfiConverterOptionalPushFormat struct{}

var FfiConverterOptionalPushFormatINSTANCE = FfiConverterOptionalPushFormat{}

func (c FfiConverterOptionalPushFormat) Lift(rb RustBufferI) *PushFormat {
	return LiftFromRustBuffer[*PushFormat](c, rb)
}

func (_ FfiConverterOptionalPushFormat) Read(reader io.Reader) *PushFormat {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterPushFormatINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalPushFormat) Lower(value *PushFormat) C.RustBuffer {
	return LowerIntoRustBuffer[*PushFormat](c, value)
}

func (_ FfiConverterOptionalPushFormat) Write(writer io.Writer, value *PushFormat) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterPushFormatINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalPushFormat struct{}

func (_ FfiDestroyerOptionalPushFormat) Destroy(value *PushFormat) {
	if value != nil {
		FfiDestroyerPushFormat{}.Destroy(*value)
	}
}

type FfiConverterOptionalRoomHistoryVisibility struct{}

var FfiConverterOptionalRoomHistoryVisibilityINSTANCE = FfiConverterOptionalRoomHistoryVisibility{}

func (c FfiConverterOptionalRoomHistoryVisibility) Lift(rb RustBufferI) *RoomHistoryVisibility {
	return LiftFromRustBuffer[*RoomHistoryVisibility](c, rb)
}

func (_ FfiConverterOptionalRoomHistoryVisibility) Read(reader io.Reader) *RoomHistoryVisibility {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterRoomHistoryVisibilityINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalRoomHistoryVisibility) Lower(value *RoomHistoryVisibility) C.RustBuffer {
	return LowerIntoRustBuffer[*RoomHistoryVisibility](c, value)
}

func (_ FfiConverterOptionalRoomHistoryVisibility) Write(writer io.Writer, value *RoomHistoryVisibility) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterRoomHistoryVisibilityINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalRoomHistoryVisibility struct{}

func (_ FfiDestroyerOptionalRoomHistoryVisibility) Destroy(value *RoomHistoryVisibility) {
	if value != nil {
		FfiDestroyerRoomHistoryVisibility{}.Destroy(*value)
	}
}

type FfiConverterOptionalRoomNotificationMode struct{}

var FfiConverterOptionalRoomNotificationModeINSTANCE = FfiConverterOptionalRoomNotificationMode{}

func (c FfiConverterOptionalRoomNotificationMode) Lift(rb RustBufferI) *RoomNotificationMode {
	return LiftFromRustBuffer[*RoomNotificationMode](c, rb)
}

func (_ FfiConverterOptionalRoomNotificationMode) Read(reader io.Reader) *RoomNotificationMode {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterRoomNotificationModeINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalRoomNotificationMode) Lower(value *RoomNotificationMode) C.RustBuffer {
	return LowerIntoRustBuffer[*RoomNotificationMode](c, value)
}

func (_ FfiConverterOptionalRoomNotificationMode) Write(writer io.Writer, value *RoomNotificationMode) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterRoomNotificationModeINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalRoomNotificationMode struct{}

func (_ FfiDestroyerOptionalRoomNotificationMode) Destroy(value *RoomNotificationMode) {
	if value != nil {
		FfiDestroyerRoomNotificationMode{}.Destroy(*value)
	}
}

type FfiConverterOptionalShieldState struct{}

var FfiConverterOptionalShieldStateINSTANCE = FfiConverterOptionalShieldState{}

func (c FfiConverterOptionalShieldState) Lift(rb RustBufferI) *ShieldState {
	return LiftFromRustBuffer[*ShieldState](c, rb)
}

func (_ FfiConverterOptionalShieldState) Read(reader io.Reader) *ShieldState {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterShieldStateINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalShieldState) Lower(value *ShieldState) C.RustBuffer {
	return LowerIntoRustBuffer[*ShieldState](c, value)
}

func (_ FfiConverterOptionalShieldState) Write(writer io.Writer, value *ShieldState) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterShieldStateINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalShieldState struct{}

func (_ FfiDestroyerOptionalShieldState) Destroy(value *ShieldState) {
	if value != nil {
		FfiDestroyerShieldState{}.Destroy(*value)
	}
}

type FfiConverterOptionalVirtualTimelineItem struct{}

var FfiConverterOptionalVirtualTimelineItemINSTANCE = FfiConverterOptionalVirtualTimelineItem{}

func (c FfiConverterOptionalVirtualTimelineItem) Lift(rb RustBufferI) *VirtualTimelineItem {
	return LiftFromRustBuffer[*VirtualTimelineItem](c, rb)
}

func (_ FfiConverterOptionalVirtualTimelineItem) Read(reader io.Reader) *VirtualTimelineItem {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterVirtualTimelineItemINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalVirtualTimelineItem) Lower(value *VirtualTimelineItem) C.RustBuffer {
	return LowerIntoRustBuffer[*VirtualTimelineItem](c, value)
}

func (_ FfiConverterOptionalVirtualTimelineItem) Write(writer io.Writer, value *VirtualTimelineItem) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterVirtualTimelineItemINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalVirtualTimelineItem struct{}

func (_ FfiDestroyerOptionalVirtualTimelineItem) Destroy(value *VirtualTimelineItem) {
	if value != nil {
		FfiDestroyerVirtualTimelineItem{}.Destroy(*value)
	}
}

type FfiConverterOptionalCallbackInterfaceBackupSteadyStateListener struct{}

var FfiConverterOptionalCallbackInterfaceBackupSteadyStateListenerINSTANCE = FfiConverterOptionalCallbackInterfaceBackupSteadyStateListener{}

func (c FfiConverterOptionalCallbackInterfaceBackupSteadyStateListener) Lift(rb RustBufferI) *BackupSteadyStateListener {
	return LiftFromRustBuffer[*BackupSteadyStateListener](c, rb)
}

func (_ FfiConverterOptionalCallbackInterfaceBackupSteadyStateListener) Read(reader io.Reader) *BackupSteadyStateListener {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterCallbackInterfaceBackupSteadyStateListenerINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalCallbackInterfaceBackupSteadyStateListener) Lower(value *BackupSteadyStateListener) C.RustBuffer {
	return LowerIntoRustBuffer[*BackupSteadyStateListener](c, value)
}

func (_ FfiConverterOptionalCallbackInterfaceBackupSteadyStateListener) Write(writer io.Writer, value *BackupSteadyStateListener) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterCallbackInterfaceBackupSteadyStateListenerINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalCallbackInterfaceBackupSteadyStateListener struct{}

func (_ FfiDestroyerOptionalCallbackInterfaceBackupSteadyStateListener) Destroy(value *BackupSteadyStateListener) {
	if value != nil {
		FfiDestroyerCallbackInterfaceBackupSteadyStateListener{}.Destroy(*value)
	}
}

type FfiConverterOptionalCallbackInterfaceClientDelegate struct{}

var FfiConverterOptionalCallbackInterfaceClientDelegateINSTANCE = FfiConverterOptionalCallbackInterfaceClientDelegate{}

func (c FfiConverterOptionalCallbackInterfaceClientDelegate) Lift(rb RustBufferI) *ClientDelegate {
	return LiftFromRustBuffer[*ClientDelegate](c, rb)
}

func (_ FfiConverterOptionalCallbackInterfaceClientDelegate) Read(reader io.Reader) *ClientDelegate {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterCallbackInterfaceClientDelegateINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalCallbackInterfaceClientDelegate) Lower(value *ClientDelegate) C.RustBuffer {
	return LowerIntoRustBuffer[*ClientDelegate](c, value)
}

func (_ FfiConverterOptionalCallbackInterfaceClientDelegate) Write(writer io.Writer, value *ClientDelegate) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterCallbackInterfaceClientDelegateINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalCallbackInterfaceClientDelegate struct{}

func (_ FfiDestroyerOptionalCallbackInterfaceClientDelegate) Destroy(value *ClientDelegate) {
	if value != nil {
		FfiDestroyerCallbackInterfaceClientDelegate{}.Destroy(*value)
	}
}

type FfiConverterOptionalCallbackInterfaceNotificationSettingsDelegate struct{}

var FfiConverterOptionalCallbackInterfaceNotificationSettingsDelegateINSTANCE = FfiConverterOptionalCallbackInterfaceNotificationSettingsDelegate{}

func (c FfiConverterOptionalCallbackInterfaceNotificationSettingsDelegate) Lift(rb RustBufferI) *NotificationSettingsDelegate {
	return LiftFromRustBuffer[*NotificationSettingsDelegate](c, rb)
}

func (_ FfiConverterOptionalCallbackInterfaceNotificationSettingsDelegate) Read(reader io.Reader) *NotificationSettingsDelegate {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterCallbackInterfaceNotificationSettingsDelegateINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalCallbackInterfaceNotificationSettingsDelegate) Lower(value *NotificationSettingsDelegate) C.RustBuffer {
	return LowerIntoRustBuffer[*NotificationSettingsDelegate](c, value)
}

func (_ FfiConverterOptionalCallbackInterfaceNotificationSettingsDelegate) Write(writer io.Writer, value *NotificationSettingsDelegate) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterCallbackInterfaceNotificationSettingsDelegateINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalCallbackInterfaceNotificationSettingsDelegate struct{}

func (_ FfiDestroyerOptionalCallbackInterfaceNotificationSettingsDelegate) Destroy(value *NotificationSettingsDelegate) {
	if value != nil {
		FfiDestroyerCallbackInterfaceNotificationSettingsDelegate{}.Destroy(*value)
	}
}

type FfiConverterOptionalCallbackInterfaceProgressWatcher struct{}

var FfiConverterOptionalCallbackInterfaceProgressWatcherINSTANCE = FfiConverterOptionalCallbackInterfaceProgressWatcher{}

func (c FfiConverterOptionalCallbackInterfaceProgressWatcher) Lift(rb RustBufferI) *ProgressWatcher {
	return LiftFromRustBuffer[*ProgressWatcher](c, rb)
}

func (_ FfiConverterOptionalCallbackInterfaceProgressWatcher) Read(reader io.Reader) *ProgressWatcher {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterCallbackInterfaceProgressWatcherINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalCallbackInterfaceProgressWatcher) Lower(value *ProgressWatcher) C.RustBuffer {
	return LowerIntoRustBuffer[*ProgressWatcher](c, value)
}

func (_ FfiConverterOptionalCallbackInterfaceProgressWatcher) Write(writer io.Writer, value *ProgressWatcher) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterCallbackInterfaceProgressWatcherINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalCallbackInterfaceProgressWatcher struct{}

func (_ FfiDestroyerOptionalCallbackInterfaceProgressWatcher) Destroy(value *ProgressWatcher) {
	if value != nil {
		FfiDestroyerCallbackInterfaceProgressWatcher{}.Destroy(*value)
	}
}

type FfiConverterOptionalCallbackInterfaceSessionVerificationControllerDelegate struct{}

var FfiConverterOptionalCallbackInterfaceSessionVerificationControllerDelegateINSTANCE = FfiConverterOptionalCallbackInterfaceSessionVerificationControllerDelegate{}

func (c FfiConverterOptionalCallbackInterfaceSessionVerificationControllerDelegate) Lift(rb RustBufferI) *SessionVerificationControllerDelegate {
	return LiftFromRustBuffer[*SessionVerificationControllerDelegate](c, rb)
}

func (_ FfiConverterOptionalCallbackInterfaceSessionVerificationControllerDelegate) Read(reader io.Reader) *SessionVerificationControllerDelegate {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterCallbackInterfaceSessionVerificationControllerDelegateINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalCallbackInterfaceSessionVerificationControllerDelegate) Lower(value *SessionVerificationControllerDelegate) C.RustBuffer {
	return LowerIntoRustBuffer[*SessionVerificationControllerDelegate](c, value)
}

func (_ FfiConverterOptionalCallbackInterfaceSessionVerificationControllerDelegate) Write(writer io.Writer, value *SessionVerificationControllerDelegate) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterCallbackInterfaceSessionVerificationControllerDelegateINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalCallbackInterfaceSessionVerificationControllerDelegate struct{}

func (_ FfiDestroyerOptionalCallbackInterfaceSessionVerificationControllerDelegate) Destroy(value *SessionVerificationControllerDelegate) {
	if value != nil {
		FfiDestroyerCallbackInterfaceSessionVerificationControllerDelegate{}.Destroy(*value)
	}
}

type FfiConverterOptionalSequenceString struct{}

var FfiConverterOptionalSequenceStringINSTANCE = FfiConverterOptionalSequenceString{}

func (c FfiConverterOptionalSequenceString) Lift(rb RustBufferI) *[]string {
	return LiftFromRustBuffer[*[]string](c, rb)
}

func (_ FfiConverterOptionalSequenceString) Read(reader io.Reader) *[]string {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterSequenceStringINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalSequenceString) Lower(value *[]string) C.RustBuffer {
	return LowerIntoRustBuffer[*[]string](c, value)
}

func (_ FfiConverterOptionalSequenceString) Write(writer io.Writer, value *[]string) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterSequenceStringINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalSequenceString struct{}

func (_ FfiDestroyerOptionalSequenceString) Destroy(value *[]string) {
	if value != nil {
		FfiDestroyerSequenceString{}.Destroy(*value)
	}
}

type FfiConverterOptionalSequenceTimelineItem struct{}

var FfiConverterOptionalSequenceTimelineItemINSTANCE = FfiConverterOptionalSequenceTimelineItem{}

func (c FfiConverterOptionalSequenceTimelineItem) Lift(rb RustBufferI) *[]*TimelineItem {
	return LiftFromRustBuffer[*[]*TimelineItem](c, rb)
}

func (_ FfiConverterOptionalSequenceTimelineItem) Read(reader io.Reader) *[]*TimelineItem {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterSequenceTimelineItemINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalSequenceTimelineItem) Lower(value *[]*TimelineItem) C.RustBuffer {
	return LowerIntoRustBuffer[*[]*TimelineItem](c, value)
}

func (_ FfiConverterOptionalSequenceTimelineItem) Write(writer io.Writer, value *[]*TimelineItem) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterSequenceTimelineItemINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalSequenceTimelineItem struct{}

func (_ FfiDestroyerOptionalSequenceTimelineItem) Destroy(value *[]*TimelineItem) {
	if value != nil {
		FfiDestroyerSequenceTimelineItem{}.Destroy(*value)
	}
}

type FfiConverterOptionalSequenceRoomHero struct{}

var FfiConverterOptionalSequenceRoomHeroINSTANCE = FfiConverterOptionalSequenceRoomHero{}

func (c FfiConverterOptionalSequenceRoomHero) Lift(rb RustBufferI) *[]RoomHero {
	return LiftFromRustBuffer[*[]RoomHero](c, rb)
}

func (_ FfiConverterOptionalSequenceRoomHero) Read(reader io.Reader) *[]RoomHero {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterSequenceRoomHeroINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalSequenceRoomHero) Lower(value *[]RoomHero) C.RustBuffer {
	return LowerIntoRustBuffer[*[]RoomHero](c, value)
}

func (_ FfiConverterOptionalSequenceRoomHero) Write(writer io.Writer, value *[]RoomHero) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterSequenceRoomHeroINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalSequenceRoomHero struct{}

func (_ FfiDestroyerOptionalSequenceRoomHero) Destroy(value *[]RoomHero) {
	if value != nil {
		FfiDestroyerSequenceRoomHero{}.Destroy(*value)
	}
}

type FfiConverterOptionalSequenceRoomMember struct{}

var FfiConverterOptionalSequenceRoomMemberINSTANCE = FfiConverterOptionalSequenceRoomMember{}

func (c FfiConverterOptionalSequenceRoomMember) Lift(rb RustBufferI) *[]RoomMember {
	return LiftFromRustBuffer[*[]RoomMember](c, rb)
}

func (_ FfiConverterOptionalSequenceRoomMember) Read(reader io.Reader) *[]RoomMember {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterSequenceRoomMemberINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalSequenceRoomMember) Lower(value *[]RoomMember) C.RustBuffer {
	return LowerIntoRustBuffer[*[]RoomMember](c, value)
}

func (_ FfiConverterOptionalSequenceRoomMember) Write(writer io.Writer, value *[]RoomMember) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterSequenceRoomMemberINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalSequenceRoomMember struct{}

func (_ FfiDestroyerOptionalSequenceRoomMember) Destroy(value *[]RoomMember) {
	if value != nil {
		FfiDestroyerSequenceRoomMember{}.Destroy(*value)
	}
}

type FfiConverterOptionalMapStringInt64 struct{}

var FfiConverterOptionalMapStringInt64INSTANCE = FfiConverterOptionalMapStringInt64{}

func (c FfiConverterOptionalMapStringInt64) Lift(rb RustBufferI) *map[string]int64 {
	return LiftFromRustBuffer[*map[string]int64](c, rb)
}

func (_ FfiConverterOptionalMapStringInt64) Read(reader io.Reader) *map[string]int64 {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterMapStringInt64INSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalMapStringInt64) Lower(value *map[string]int64) C.RustBuffer {
	return LowerIntoRustBuffer[*map[string]int64](c, value)
}

func (_ FfiConverterOptionalMapStringInt64) Write(writer io.Writer, value *map[string]int64) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterMapStringInt64INSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalMapStringInt64 struct{}

func (_ FfiDestroyerOptionalMapStringInt64) Destroy(value *map[string]int64) {
	if value != nil {
		FfiDestroyerMapStringInt64{}.Destroy(*value)
	}
}

type FfiConverterOptionalEventItemOrigin struct{}

var FfiConverterOptionalEventItemOriginINSTANCE = FfiConverterOptionalEventItemOrigin{}

func (c FfiConverterOptionalEventItemOrigin) Lift(rb RustBufferI) *matrix_sdk_ui.EventItemOrigin {
	return LiftFromRustBuffer[*matrix_sdk_ui.EventItemOrigin](c, rb)
}

func (_ FfiConverterOptionalEventItemOrigin) Read(reader io.Reader) *matrix_sdk_ui.EventItemOrigin {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := matrix_sdk_ui.FfiConverterEventItemOriginINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalEventItemOrigin) Lower(value *matrix_sdk_ui.EventItemOrigin) C.RustBuffer {
	return LowerIntoRustBuffer[*matrix_sdk_ui.EventItemOrigin](c, value)
}

func (_ FfiConverterOptionalEventItemOrigin) Write(writer io.Writer, value *matrix_sdk_ui.EventItemOrigin) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		matrix_sdk_ui.FfiConverterEventItemOriginINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalEventItemOrigin struct{}

func (_ FfiDestroyerOptionalEventItemOrigin) Destroy(value *matrix_sdk_ui.EventItemOrigin) {
	if value != nil {
		matrix_sdk_ui.FfiDestroyerEventItemOrigin{}.Destroy(*value)
	}
}

type FfiConverterOptionalTypeTimestamp struct{}

var FfiConverterOptionalTypeTimestampINSTANCE = FfiConverterOptionalTypeTimestamp{}

func (c FfiConverterOptionalTypeTimestamp) Lift(rb RustBufferI) *Timestamp {
	return LiftFromRustBuffer[*Timestamp](c, rb)
}

func (_ FfiConverterOptionalTypeTimestamp) Read(reader io.Reader) *Timestamp {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterTypeTimestampINSTANCE.Read(reader)
	return &temp
}

func (c FfiConverterOptionalTypeTimestamp) Lower(value *Timestamp) C.RustBuffer {
	return LowerIntoRustBuffer[*Timestamp](c, value)
}

func (_ FfiConverterOptionalTypeTimestamp) Write(writer io.Writer, value *Timestamp) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterTypeTimestampINSTANCE.Write(writer, *value)
	}
}

type FfiDestroyerOptionalTypeTimestamp struct{}

func (_ FfiDestroyerOptionalTypeTimestamp) Destroy(value *Timestamp) {
	if value != nil {
		FfiDestroyerTypeTimestamp{}.Destroy(*value)
	}
}

type FfiConverterSequenceUint16 struct{}

var FfiConverterSequenceUint16INSTANCE = FfiConverterSequenceUint16{}

func (c FfiConverterSequenceUint16) Lift(rb RustBufferI) []uint16 {
	return LiftFromRustBuffer[[]uint16](c, rb)
}

func (c FfiConverterSequenceUint16) Read(reader io.Reader) []uint16 {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]uint16, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterUint16INSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceUint16) Lower(value []uint16) C.RustBuffer {
	return LowerIntoRustBuffer[[]uint16](c, value)
}

func (c FfiConverterSequenceUint16) Write(writer io.Writer, value []uint16) {
	if len(value) > math.MaxInt32 {
		panic("[]uint16 is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterUint16INSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceUint16 struct{}

func (FfiDestroyerSequenceUint16) Destroy(sequence []uint16) {
	for _, value := range sequence {
		FfiDestroyerUint16{}.Destroy(value)
	}
}

type FfiConverterSequenceString struct{}

var FfiConverterSequenceStringINSTANCE = FfiConverterSequenceString{}

func (c FfiConverterSequenceString) Lift(rb RustBufferI) []string {
	return LiftFromRustBuffer[[]string](c, rb)
}

func (c FfiConverterSequenceString) Read(reader io.Reader) []string {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]string, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterStringINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceString) Lower(value []string) C.RustBuffer {
	return LowerIntoRustBuffer[[]string](c, value)
}

func (c FfiConverterSequenceString) Write(writer io.Writer, value []string) {
	if len(value) > math.MaxInt32 {
		panic("[]string is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterStringINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceString struct{}

func (FfiDestroyerSequenceString) Destroy(sequence []string) {
	for _, value := range sequence {
		FfiDestroyerString{}.Destroy(value)
	}
}

type FfiConverterSequenceBytes struct{}

var FfiConverterSequenceBytesINSTANCE = FfiConverterSequenceBytes{}

func (c FfiConverterSequenceBytes) Lift(rb RustBufferI) [][]byte {
	return LiftFromRustBuffer[[][]byte](c, rb)
}

func (c FfiConverterSequenceBytes) Read(reader io.Reader) [][]byte {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([][]byte, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterBytesINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceBytes) Lower(value [][]byte) C.RustBuffer {
	return LowerIntoRustBuffer[[][]byte](c, value)
}

func (c FfiConverterSequenceBytes) Write(writer io.Writer, value [][]byte) {
	if len(value) > math.MaxInt32 {
		panic("[][]byte is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterBytesINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceBytes struct{}

func (FfiDestroyerSequenceBytes) Destroy(sequence [][]byte) {
	for _, value := range sequence {
		FfiDestroyerBytes{}.Destroy(value)
	}
}

type FfiConverterSequenceRoom struct{}

var FfiConverterSequenceRoomINSTANCE = FfiConverterSequenceRoom{}

func (c FfiConverterSequenceRoom) Lift(rb RustBufferI) []*Room {
	return LiftFromRustBuffer[[]*Room](c, rb)
}

func (c FfiConverterSequenceRoom) Read(reader io.Reader) []*Room {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*Room, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterRoomINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceRoom) Lower(value []*Room) C.RustBuffer {
	return LowerIntoRustBuffer[[]*Room](c, value)
}

func (c FfiConverterSequenceRoom) Write(writer io.Writer, value []*Room) {
	if len(value) > math.MaxInt32 {
		panic("[]*Room is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterRoomINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceRoom struct{}

func (FfiDestroyerSequenceRoom) Destroy(sequence []*Room) {
	for _, value := range sequence {
		FfiDestroyerRoom{}.Destroy(value)
	}
}

type FfiConverterSequenceSessionVerificationEmoji struct{}

var FfiConverterSequenceSessionVerificationEmojiINSTANCE = FfiConverterSequenceSessionVerificationEmoji{}

func (c FfiConverterSequenceSessionVerificationEmoji) Lift(rb RustBufferI) []*SessionVerificationEmoji {
	return LiftFromRustBuffer[[]*SessionVerificationEmoji](c, rb)
}

func (c FfiConverterSequenceSessionVerificationEmoji) Read(reader io.Reader) []*SessionVerificationEmoji {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*SessionVerificationEmoji, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterSessionVerificationEmojiINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceSessionVerificationEmoji) Lower(value []*SessionVerificationEmoji) C.RustBuffer {
	return LowerIntoRustBuffer[[]*SessionVerificationEmoji](c, value)
}

func (c FfiConverterSequenceSessionVerificationEmoji) Write(writer io.Writer, value []*SessionVerificationEmoji) {
	if len(value) > math.MaxInt32 {
		panic("[]*SessionVerificationEmoji is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterSessionVerificationEmojiINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceSessionVerificationEmoji struct{}

func (FfiDestroyerSequenceSessionVerificationEmoji) Destroy(sequence []*SessionVerificationEmoji) {
	for _, value := range sequence {
		FfiDestroyerSessionVerificationEmoji{}.Destroy(value)
	}
}

type FfiConverterSequenceTimelineDiff struct{}

var FfiConverterSequenceTimelineDiffINSTANCE = FfiConverterSequenceTimelineDiff{}

func (c FfiConverterSequenceTimelineDiff) Lift(rb RustBufferI) []*TimelineDiff {
	return LiftFromRustBuffer[[]*TimelineDiff](c, rb)
}

func (c FfiConverterSequenceTimelineDiff) Read(reader io.Reader) []*TimelineDiff {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*TimelineDiff, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterTimelineDiffINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceTimelineDiff) Lower(value []*TimelineDiff) C.RustBuffer {
	return LowerIntoRustBuffer[[]*TimelineDiff](c, value)
}

func (c FfiConverterSequenceTimelineDiff) Write(writer io.Writer, value []*TimelineDiff) {
	if len(value) > math.MaxInt32 {
		panic("[]*TimelineDiff is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterTimelineDiffINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceTimelineDiff struct{}

func (FfiDestroyerSequenceTimelineDiff) Destroy(sequence []*TimelineDiff) {
	for _, value := range sequence {
		FfiDestroyerTimelineDiff{}.Destroy(value)
	}
}

type FfiConverterSequenceTimelineItem struct{}

var FfiConverterSequenceTimelineItemINSTANCE = FfiConverterSequenceTimelineItem{}

func (c FfiConverterSequenceTimelineItem) Lift(rb RustBufferI) []*TimelineItem {
	return LiftFromRustBuffer[[]*TimelineItem](c, rb)
}

func (c FfiConverterSequenceTimelineItem) Read(reader io.Reader) []*TimelineItem {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]*TimelineItem, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterTimelineItemINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceTimelineItem) Lower(value []*TimelineItem) C.RustBuffer {
	return LowerIntoRustBuffer[[]*TimelineItem](c, value)
}

func (c FfiConverterSequenceTimelineItem) Write(writer io.Writer, value []*TimelineItem) {
	if len(value) > math.MaxInt32 {
		panic("[]*TimelineItem is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterTimelineItemINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceTimelineItem struct{}

func (FfiDestroyerSequenceTimelineItem) Destroy(sequence []*TimelineItem) {
	for _, value := range sequence {
		FfiDestroyerTimelineItem{}.Destroy(value)
	}
}

type FfiConverterSequenceConditionalPushRule struct{}

var FfiConverterSequenceConditionalPushRuleINSTANCE = FfiConverterSequenceConditionalPushRule{}

func (c FfiConverterSequenceConditionalPushRule) Lift(rb RustBufferI) []ConditionalPushRule {
	return LiftFromRustBuffer[[]ConditionalPushRule](c, rb)
}

func (c FfiConverterSequenceConditionalPushRule) Read(reader io.Reader) []ConditionalPushRule {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]ConditionalPushRule, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterConditionalPushRuleINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceConditionalPushRule) Lower(value []ConditionalPushRule) C.RustBuffer {
	return LowerIntoRustBuffer[[]ConditionalPushRule](c, value)
}

func (c FfiConverterSequenceConditionalPushRule) Write(writer io.Writer, value []ConditionalPushRule) {
	if len(value) > math.MaxInt32 {
		panic("[]ConditionalPushRule is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterConditionalPushRuleINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceConditionalPushRule struct{}

func (FfiDestroyerSequenceConditionalPushRule) Destroy(sequence []ConditionalPushRule) {
	for _, value := range sequence {
		FfiDestroyerConditionalPushRule{}.Destroy(value)
	}
}

type FfiConverterSequenceIdentityStatusChange struct{}

var FfiConverterSequenceIdentityStatusChangeINSTANCE = FfiConverterSequenceIdentityStatusChange{}

func (c FfiConverterSequenceIdentityStatusChange) Lift(rb RustBufferI) []IdentityStatusChange {
	return LiftFromRustBuffer[[]IdentityStatusChange](c, rb)
}

func (c FfiConverterSequenceIdentityStatusChange) Read(reader io.Reader) []IdentityStatusChange {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]IdentityStatusChange, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterIdentityStatusChangeINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceIdentityStatusChange) Lower(value []IdentityStatusChange) C.RustBuffer {
	return LowerIntoRustBuffer[[]IdentityStatusChange](c, value)
}

func (c FfiConverterSequenceIdentityStatusChange) Write(writer io.Writer, value []IdentityStatusChange) {
	if len(value) > math.MaxInt32 {
		panic("[]IdentityStatusChange is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterIdentityStatusChangeINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceIdentityStatusChange struct{}

func (FfiDestroyerSequenceIdentityStatusChange) Destroy(sequence []IdentityStatusChange) {
	for _, value := range sequence {
		FfiDestroyerIdentityStatusChange{}.Destroy(value)
	}
}

type FfiConverterSequenceKnockRequest struct{}

var FfiConverterSequenceKnockRequestINSTANCE = FfiConverterSequenceKnockRequest{}

func (c FfiConverterSequenceKnockRequest) Lift(rb RustBufferI) []KnockRequest {
	return LiftFromRustBuffer[[]KnockRequest](c, rb)
}

func (c FfiConverterSequenceKnockRequest) Read(reader io.Reader) []KnockRequest {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]KnockRequest, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterKnockRequestINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceKnockRequest) Lower(value []KnockRequest) C.RustBuffer {
	return LowerIntoRustBuffer[[]KnockRequest](c, value)
}

func (c FfiConverterSequenceKnockRequest) Write(writer io.Writer, value []KnockRequest) {
	if len(value) > math.MaxInt32 {
		panic("[]KnockRequest is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterKnockRequestINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceKnockRequest struct{}

func (FfiDestroyerSequenceKnockRequest) Destroy(sequence []KnockRequest) {
	for _, value := range sequence {
		FfiDestroyerKnockRequest{}.Destroy(value)
	}
}

type FfiConverterSequenceLiveLocationShare struct{}

var FfiConverterSequenceLiveLocationShareINSTANCE = FfiConverterSequenceLiveLocationShare{}

func (c FfiConverterSequenceLiveLocationShare) Lift(rb RustBufferI) []LiveLocationShare {
	return LiftFromRustBuffer[[]LiveLocationShare](c, rb)
}

func (c FfiConverterSequenceLiveLocationShare) Read(reader io.Reader) []LiveLocationShare {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]LiveLocationShare, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterLiveLocationShareINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceLiveLocationShare) Lower(value []LiveLocationShare) C.RustBuffer {
	return LowerIntoRustBuffer[[]LiveLocationShare](c, value)
}

func (c FfiConverterSequenceLiveLocationShare) Write(writer io.Writer, value []LiveLocationShare) {
	if len(value) > math.MaxInt32 {
		panic("[]LiveLocationShare is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterLiveLocationShareINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceLiveLocationShare struct{}

func (FfiDestroyerSequenceLiveLocationShare) Destroy(sequence []LiveLocationShare) {
	for _, value := range sequence {
		FfiDestroyerLiveLocationShare{}.Destroy(value)
	}
}

type FfiConverterSequenceNotificationItemsRequest struct{}

var FfiConverterSequenceNotificationItemsRequestINSTANCE = FfiConverterSequenceNotificationItemsRequest{}

func (c FfiConverterSequenceNotificationItemsRequest) Lift(rb RustBufferI) []NotificationItemsRequest {
	return LiftFromRustBuffer[[]NotificationItemsRequest](c, rb)
}

func (c FfiConverterSequenceNotificationItemsRequest) Read(reader io.Reader) []NotificationItemsRequest {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]NotificationItemsRequest, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterNotificationItemsRequestINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceNotificationItemsRequest) Lower(value []NotificationItemsRequest) C.RustBuffer {
	return LowerIntoRustBuffer[[]NotificationItemsRequest](c, value)
}

func (c FfiConverterSequenceNotificationItemsRequest) Write(writer io.Writer, value []NotificationItemsRequest) {
	if len(value) > math.MaxInt32 {
		panic("[]NotificationItemsRequest is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterNotificationItemsRequestINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceNotificationItemsRequest struct{}

func (FfiDestroyerSequenceNotificationItemsRequest) Destroy(sequence []NotificationItemsRequest) {
	for _, value := range sequence {
		FfiDestroyerNotificationItemsRequest{}.Destroy(value)
	}
}

type FfiConverterSequencePatternedPushRule struct{}

var FfiConverterSequencePatternedPushRuleINSTANCE = FfiConverterSequencePatternedPushRule{}

func (c FfiConverterSequencePatternedPushRule) Lift(rb RustBufferI) []PatternedPushRule {
	return LiftFromRustBuffer[[]PatternedPushRule](c, rb)
}

func (c FfiConverterSequencePatternedPushRule) Read(reader io.Reader) []PatternedPushRule {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]PatternedPushRule, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterPatternedPushRuleINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequencePatternedPushRule) Lower(value []PatternedPushRule) C.RustBuffer {
	return LowerIntoRustBuffer[[]PatternedPushRule](c, value)
}

func (c FfiConverterSequencePatternedPushRule) Write(writer io.Writer, value []PatternedPushRule) {
	if len(value) > math.MaxInt32 {
		panic("[]PatternedPushRule is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterPatternedPushRuleINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequencePatternedPushRule struct{}

func (FfiDestroyerSequencePatternedPushRule) Destroy(sequence []PatternedPushRule) {
	for _, value := range sequence {
		FfiDestroyerPatternedPushRule{}.Destroy(value)
	}
}

type FfiConverterSequencePollAnswer struct{}

var FfiConverterSequencePollAnswerINSTANCE = FfiConverterSequencePollAnswer{}

func (c FfiConverterSequencePollAnswer) Lift(rb RustBufferI) []PollAnswer {
	return LiftFromRustBuffer[[]PollAnswer](c, rb)
}

func (c FfiConverterSequencePollAnswer) Read(reader io.Reader) []PollAnswer {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]PollAnswer, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterPollAnswerINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequencePollAnswer) Lower(value []PollAnswer) C.RustBuffer {
	return LowerIntoRustBuffer[[]PollAnswer](c, value)
}

func (c FfiConverterSequencePollAnswer) Write(writer io.Writer, value []PollAnswer) {
	if len(value) > math.MaxInt32 {
		panic("[]PollAnswer is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterPollAnswerINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequencePollAnswer struct{}

func (FfiDestroyerSequencePollAnswer) Destroy(sequence []PollAnswer) {
	for _, value := range sequence {
		FfiDestroyerPollAnswer{}.Destroy(value)
	}
}

type FfiConverterSequenceReaction struct{}

var FfiConverterSequenceReactionINSTANCE = FfiConverterSequenceReaction{}

func (c FfiConverterSequenceReaction) Lift(rb RustBufferI) []Reaction {
	return LiftFromRustBuffer[[]Reaction](c, rb)
}

func (c FfiConverterSequenceReaction) Read(reader io.Reader) []Reaction {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]Reaction, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterReactionINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceReaction) Lower(value []Reaction) C.RustBuffer {
	return LowerIntoRustBuffer[[]Reaction](c, value)
}

func (c FfiConverterSequenceReaction) Write(writer io.Writer, value []Reaction) {
	if len(value) > math.MaxInt32 {
		panic("[]Reaction is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterReactionINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceReaction struct{}

func (FfiDestroyerSequenceReaction) Destroy(sequence []Reaction) {
	for _, value := range sequence {
		FfiDestroyerReaction{}.Destroy(value)
	}
}

type FfiConverterSequenceReactionSenderData struct{}

var FfiConverterSequenceReactionSenderDataINSTANCE = FfiConverterSequenceReactionSenderData{}

func (c FfiConverterSequenceReactionSenderData) Lift(rb RustBufferI) []ReactionSenderData {
	return LiftFromRustBuffer[[]ReactionSenderData](c, rb)
}

func (c FfiConverterSequenceReactionSenderData) Read(reader io.Reader) []ReactionSenderData {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]ReactionSenderData, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterReactionSenderDataINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceReactionSenderData) Lower(value []ReactionSenderData) C.RustBuffer {
	return LowerIntoRustBuffer[[]ReactionSenderData](c, value)
}

func (c FfiConverterSequenceReactionSenderData) Write(writer io.Writer, value []ReactionSenderData) {
	if len(value) > math.MaxInt32 {
		panic("[]ReactionSenderData is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterReactionSenderDataINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceReactionSenderData struct{}

func (FfiDestroyerSequenceReactionSenderData) Destroy(sequence []ReactionSenderData) {
	for _, value := range sequence {
		FfiDestroyerReactionSenderData{}.Destroy(value)
	}
}

type FfiConverterSequenceRoomDescription struct{}

var FfiConverterSequenceRoomDescriptionINSTANCE = FfiConverterSequenceRoomDescription{}

func (c FfiConverterSequenceRoomDescription) Lift(rb RustBufferI) []RoomDescription {
	return LiftFromRustBuffer[[]RoomDescription](c, rb)
}

func (c FfiConverterSequenceRoomDescription) Read(reader io.Reader) []RoomDescription {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]RoomDescription, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterRoomDescriptionINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceRoomDescription) Lower(value []RoomDescription) C.RustBuffer {
	return LowerIntoRustBuffer[[]RoomDescription](c, value)
}

func (c FfiConverterSequenceRoomDescription) Write(writer io.Writer, value []RoomDescription) {
	if len(value) > math.MaxInt32 {
		panic("[]RoomDescription is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterRoomDescriptionINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceRoomDescription struct{}

func (FfiDestroyerSequenceRoomDescription) Destroy(sequence []RoomDescription) {
	for _, value := range sequence {
		FfiDestroyerRoomDescription{}.Destroy(value)
	}
}

type FfiConverterSequenceRoomHero struct{}

var FfiConverterSequenceRoomHeroINSTANCE = FfiConverterSequenceRoomHero{}

func (c FfiConverterSequenceRoomHero) Lift(rb RustBufferI) []RoomHero {
	return LiftFromRustBuffer[[]RoomHero](c, rb)
}

func (c FfiConverterSequenceRoomHero) Read(reader io.Reader) []RoomHero {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]RoomHero, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterRoomHeroINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceRoomHero) Lower(value []RoomHero) C.RustBuffer {
	return LowerIntoRustBuffer[[]RoomHero](c, value)
}

func (c FfiConverterSequenceRoomHero) Write(writer io.Writer, value []RoomHero) {
	if len(value) > math.MaxInt32 {
		panic("[]RoomHero is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterRoomHeroINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceRoomHero struct{}

func (FfiDestroyerSequenceRoomHero) Destroy(sequence []RoomHero) {
	for _, value := range sequence {
		FfiDestroyerRoomHero{}.Destroy(value)
	}
}

type FfiConverterSequenceRoomMember struct{}

var FfiConverterSequenceRoomMemberINSTANCE = FfiConverterSequenceRoomMember{}

func (c FfiConverterSequenceRoomMember) Lift(rb RustBufferI) []RoomMember {
	return LiftFromRustBuffer[[]RoomMember](c, rb)
}

func (c FfiConverterSequenceRoomMember) Read(reader io.Reader) []RoomMember {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]RoomMember, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterRoomMemberINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceRoomMember) Lower(value []RoomMember) C.RustBuffer {
	return LowerIntoRustBuffer[[]RoomMember](c, value)
}

func (c FfiConverterSequenceRoomMember) Write(writer io.Writer, value []RoomMember) {
	if len(value) > math.MaxInt32 {
		panic("[]RoomMember is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterRoomMemberINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceRoomMember struct{}

func (FfiDestroyerSequenceRoomMember) Destroy(sequence []RoomMember) {
	for _, value := range sequence {
		FfiDestroyerRoomMember{}.Destroy(value)
	}
}

type FfiConverterSequenceSimplePushRule struct{}

var FfiConverterSequenceSimplePushRuleINSTANCE = FfiConverterSequenceSimplePushRule{}

func (c FfiConverterSequenceSimplePushRule) Lift(rb RustBufferI) []SimplePushRule {
	return LiftFromRustBuffer[[]SimplePushRule](c, rb)
}

func (c FfiConverterSequenceSimplePushRule) Read(reader io.Reader) []SimplePushRule {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]SimplePushRule, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterSimplePushRuleINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceSimplePushRule) Lower(value []SimplePushRule) C.RustBuffer {
	return LowerIntoRustBuffer[[]SimplePushRule](c, value)
}

func (c FfiConverterSequenceSimplePushRule) Write(writer io.Writer, value []SimplePushRule) {
	if len(value) > math.MaxInt32 {
		panic("[]SimplePushRule is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterSimplePushRuleINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceSimplePushRule struct{}

func (FfiDestroyerSequenceSimplePushRule) Destroy(sequence []SimplePushRule) {
	for _, value := range sequence {
		FfiDestroyerSimplePushRule{}.Destroy(value)
	}
}

type FfiConverterSequenceUserPowerLevelUpdate struct{}

var FfiConverterSequenceUserPowerLevelUpdateINSTANCE = FfiConverterSequenceUserPowerLevelUpdate{}

func (c FfiConverterSequenceUserPowerLevelUpdate) Lift(rb RustBufferI) []UserPowerLevelUpdate {
	return LiftFromRustBuffer[[]UserPowerLevelUpdate](c, rb)
}

func (c FfiConverterSequenceUserPowerLevelUpdate) Read(reader io.Reader) []UserPowerLevelUpdate {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]UserPowerLevelUpdate, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterUserPowerLevelUpdateINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceUserPowerLevelUpdate) Lower(value []UserPowerLevelUpdate) C.RustBuffer {
	return LowerIntoRustBuffer[[]UserPowerLevelUpdate](c, value)
}

func (c FfiConverterSequenceUserPowerLevelUpdate) Write(writer io.Writer, value []UserPowerLevelUpdate) {
	if len(value) > math.MaxInt32 {
		panic("[]UserPowerLevelUpdate is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterUserPowerLevelUpdateINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceUserPowerLevelUpdate struct{}

func (FfiDestroyerSequenceUserPowerLevelUpdate) Destroy(sequence []UserPowerLevelUpdate) {
	for _, value := range sequence {
		FfiDestroyerUserPowerLevelUpdate{}.Destroy(value)
	}
}

type FfiConverterSequenceUserProfile struct{}

var FfiConverterSequenceUserProfileINSTANCE = FfiConverterSequenceUserProfile{}

func (c FfiConverterSequenceUserProfile) Lift(rb RustBufferI) []UserProfile {
	return LiftFromRustBuffer[[]UserProfile](c, rb)
}

func (c FfiConverterSequenceUserProfile) Read(reader io.Reader) []UserProfile {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]UserProfile, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterUserProfileINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceUserProfile) Lower(value []UserProfile) C.RustBuffer {
	return LowerIntoRustBuffer[[]UserProfile](c, value)
}

func (c FfiConverterSequenceUserProfile) Write(writer io.Writer, value []UserProfile) {
	if len(value) > math.MaxInt32 {
		panic("[]UserProfile is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterUserProfileINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceUserProfile struct{}

func (FfiDestroyerSequenceUserProfile) Destroy(sequence []UserProfile) {
	for _, value := range sequence {
		FfiDestroyerUserProfile{}.Destroy(value)
	}
}

type FfiConverterSequenceAction struct{}

var FfiConverterSequenceActionINSTANCE = FfiConverterSequenceAction{}

func (c FfiConverterSequenceAction) Lift(rb RustBufferI) []Action {
	return LiftFromRustBuffer[[]Action](c, rb)
}

func (c FfiConverterSequenceAction) Read(reader io.Reader) []Action {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]Action, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterActionINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceAction) Lower(value []Action) C.RustBuffer {
	return LowerIntoRustBuffer[[]Action](c, value)
}

func (c FfiConverterSequenceAction) Write(writer io.Writer, value []Action) {
	if len(value) > math.MaxInt32 {
		panic("[]Action is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterActionINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceAction struct{}

func (FfiDestroyerSequenceAction) Destroy(sequence []Action) {
	for _, value := range sequence {
		FfiDestroyerAction{}.Destroy(value)
	}
}

type FfiConverterSequenceAllowRule struct{}

var FfiConverterSequenceAllowRuleINSTANCE = FfiConverterSequenceAllowRule{}

func (c FfiConverterSequenceAllowRule) Lift(rb RustBufferI) []AllowRule {
	return LiftFromRustBuffer[[]AllowRule](c, rb)
}

func (c FfiConverterSequenceAllowRule) Read(reader io.Reader) []AllowRule {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]AllowRule, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterAllowRuleINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceAllowRule) Lower(value []AllowRule) C.RustBuffer {
	return LowerIntoRustBuffer[[]AllowRule](c, value)
}

func (c FfiConverterSequenceAllowRule) Write(writer io.Writer, value []AllowRule) {
	if len(value) > math.MaxInt32 {
		panic("[]AllowRule is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterAllowRuleINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceAllowRule struct{}

func (FfiDestroyerSequenceAllowRule) Destroy(sequence []AllowRule) {
	for _, value := range sequence {
		FfiDestroyerAllowRule{}.Destroy(value)
	}
}

type FfiConverterSequenceFilterTimelineEventType struct{}

var FfiConverterSequenceFilterTimelineEventTypeINSTANCE = FfiConverterSequenceFilterTimelineEventType{}

func (c FfiConverterSequenceFilterTimelineEventType) Lift(rb RustBufferI) []FilterTimelineEventType {
	return LiftFromRustBuffer[[]FilterTimelineEventType](c, rb)
}

func (c FfiConverterSequenceFilterTimelineEventType) Read(reader io.Reader) []FilterTimelineEventType {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]FilterTimelineEventType, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterFilterTimelineEventTypeINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceFilterTimelineEventType) Lower(value []FilterTimelineEventType) C.RustBuffer {
	return LowerIntoRustBuffer[[]FilterTimelineEventType](c, value)
}

func (c FfiConverterSequenceFilterTimelineEventType) Write(writer io.Writer, value []FilterTimelineEventType) {
	if len(value) > math.MaxInt32 {
		panic("[]FilterTimelineEventType is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterFilterTimelineEventTypeINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceFilterTimelineEventType struct{}

func (FfiDestroyerSequenceFilterTimelineEventType) Destroy(sequence []FilterTimelineEventType) {
	for _, value := range sequence {
		FfiDestroyerFilterTimelineEventType{}.Destroy(value)
	}
}

type FfiConverterSequenceMembership struct{}

var FfiConverterSequenceMembershipINSTANCE = FfiConverterSequenceMembership{}

func (c FfiConverterSequenceMembership) Lift(rb RustBufferI) []Membership {
	return LiftFromRustBuffer[[]Membership](c, rb)
}

func (c FfiConverterSequenceMembership) Read(reader io.Reader) []Membership {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]Membership, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterMembershipINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceMembership) Lower(value []Membership) C.RustBuffer {
	return LowerIntoRustBuffer[[]Membership](c, value)
}

func (c FfiConverterSequenceMembership) Write(writer io.Writer, value []Membership) {
	if len(value) > math.MaxInt32 {
		panic("[]Membership is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterMembershipINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceMembership struct{}

func (FfiDestroyerSequenceMembership) Destroy(sequence []Membership) {
	for _, value := range sequence {
		FfiDestroyerMembership{}.Destroy(value)
	}
}

type FfiConverterSequenceOidcPrompt struct{}

var FfiConverterSequenceOidcPromptINSTANCE = FfiConverterSequenceOidcPrompt{}

func (c FfiConverterSequenceOidcPrompt) Lift(rb RustBufferI) []OidcPrompt {
	return LiftFromRustBuffer[[]OidcPrompt](c, rb)
}

func (c FfiConverterSequenceOidcPrompt) Read(reader io.Reader) []OidcPrompt {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]OidcPrompt, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterOidcPromptINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceOidcPrompt) Lower(value []OidcPrompt) C.RustBuffer {
	return LowerIntoRustBuffer[[]OidcPrompt](c, value)
}

func (c FfiConverterSequenceOidcPrompt) Write(writer io.Writer, value []OidcPrompt) {
	if len(value) > math.MaxInt32 {
		panic("[]OidcPrompt is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterOidcPromptINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceOidcPrompt struct{}

func (FfiDestroyerSequenceOidcPrompt) Destroy(sequence []OidcPrompt) {
	for _, value := range sequence {
		FfiDestroyerOidcPrompt{}.Destroy(value)
	}
}

type FfiConverterSequencePushCondition struct{}

var FfiConverterSequencePushConditionINSTANCE = FfiConverterSequencePushCondition{}

func (c FfiConverterSequencePushCondition) Lift(rb RustBufferI) []PushCondition {
	return LiftFromRustBuffer[[]PushCondition](c, rb)
}

func (c FfiConverterSequencePushCondition) Read(reader io.Reader) []PushCondition {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]PushCondition, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterPushConditionINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequencePushCondition) Lower(value []PushCondition) C.RustBuffer {
	return LowerIntoRustBuffer[[]PushCondition](c, value)
}

func (c FfiConverterSequencePushCondition) Write(writer io.Writer, value []PushCondition) {
	if len(value) > math.MaxInt32 {
		panic("[]PushCondition is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterPushConditionINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequencePushCondition struct{}

func (FfiDestroyerSequencePushCondition) Destroy(sequence []PushCondition) {
	for _, value := range sequence {
		FfiDestroyerPushCondition{}.Destroy(value)
	}
}

type FfiConverterSequenceRoomDirectorySearchEntryUpdate struct{}

var FfiConverterSequenceRoomDirectorySearchEntryUpdateINSTANCE = FfiConverterSequenceRoomDirectorySearchEntryUpdate{}

func (c FfiConverterSequenceRoomDirectorySearchEntryUpdate) Lift(rb RustBufferI) []RoomDirectorySearchEntryUpdate {
	return LiftFromRustBuffer[[]RoomDirectorySearchEntryUpdate](c, rb)
}

func (c FfiConverterSequenceRoomDirectorySearchEntryUpdate) Read(reader io.Reader) []RoomDirectorySearchEntryUpdate {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]RoomDirectorySearchEntryUpdate, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterRoomDirectorySearchEntryUpdateINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceRoomDirectorySearchEntryUpdate) Lower(value []RoomDirectorySearchEntryUpdate) C.RustBuffer {
	return LowerIntoRustBuffer[[]RoomDirectorySearchEntryUpdate](c, value)
}

func (c FfiConverterSequenceRoomDirectorySearchEntryUpdate) Write(writer io.Writer, value []RoomDirectorySearchEntryUpdate) {
	if len(value) > math.MaxInt32 {
		panic("[]RoomDirectorySearchEntryUpdate is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterRoomDirectorySearchEntryUpdateINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceRoomDirectorySearchEntryUpdate struct{}

func (FfiDestroyerSequenceRoomDirectorySearchEntryUpdate) Destroy(sequence []RoomDirectorySearchEntryUpdate) {
	for _, value := range sequence {
		FfiDestroyerRoomDirectorySearchEntryUpdate{}.Destroy(value)
	}
}

type FfiConverterSequenceRoomListEntriesDynamicFilterKind struct{}

var FfiConverterSequenceRoomListEntriesDynamicFilterKindINSTANCE = FfiConverterSequenceRoomListEntriesDynamicFilterKind{}

func (c FfiConverterSequenceRoomListEntriesDynamicFilterKind) Lift(rb RustBufferI) []RoomListEntriesDynamicFilterKind {
	return LiftFromRustBuffer[[]RoomListEntriesDynamicFilterKind](c, rb)
}

func (c FfiConverterSequenceRoomListEntriesDynamicFilterKind) Read(reader io.Reader) []RoomListEntriesDynamicFilterKind {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]RoomListEntriesDynamicFilterKind, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterRoomListEntriesDynamicFilterKindINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceRoomListEntriesDynamicFilterKind) Lower(value []RoomListEntriesDynamicFilterKind) C.RustBuffer {
	return LowerIntoRustBuffer[[]RoomListEntriesDynamicFilterKind](c, value)
}

func (c FfiConverterSequenceRoomListEntriesDynamicFilterKind) Write(writer io.Writer, value []RoomListEntriesDynamicFilterKind) {
	if len(value) > math.MaxInt32 {
		panic("[]RoomListEntriesDynamicFilterKind is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterRoomListEntriesDynamicFilterKindINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceRoomListEntriesDynamicFilterKind struct{}

func (FfiDestroyerSequenceRoomListEntriesDynamicFilterKind) Destroy(sequence []RoomListEntriesDynamicFilterKind) {
	for _, value := range sequence {
		FfiDestroyerRoomListEntriesDynamicFilterKind{}.Destroy(value)
	}
}

type FfiConverterSequenceRoomListEntriesUpdate struct{}

var FfiConverterSequenceRoomListEntriesUpdateINSTANCE = FfiConverterSequenceRoomListEntriesUpdate{}

func (c FfiConverterSequenceRoomListEntriesUpdate) Lift(rb RustBufferI) []RoomListEntriesUpdate {
	return LiftFromRustBuffer[[]RoomListEntriesUpdate](c, rb)
}

func (c FfiConverterSequenceRoomListEntriesUpdate) Read(reader io.Reader) []RoomListEntriesUpdate {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]RoomListEntriesUpdate, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterRoomListEntriesUpdateINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceRoomListEntriesUpdate) Lower(value []RoomListEntriesUpdate) C.RustBuffer {
	return LowerIntoRustBuffer[[]RoomListEntriesUpdate](c, value)
}

func (c FfiConverterSequenceRoomListEntriesUpdate) Write(writer io.Writer, value []RoomListEntriesUpdate) {
	if len(value) > math.MaxInt32 {
		panic("[]RoomListEntriesUpdate is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterRoomListEntriesUpdateINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceRoomListEntriesUpdate struct{}

func (FfiDestroyerSequenceRoomListEntriesUpdate) Destroy(sequence []RoomListEntriesUpdate) {
	for _, value := range sequence {
		FfiDestroyerRoomListEntriesUpdate{}.Destroy(value)
	}
}

type FfiConverterSequenceRoomMessageEventMessageType struct{}

var FfiConverterSequenceRoomMessageEventMessageTypeINSTANCE = FfiConverterSequenceRoomMessageEventMessageType{}

func (c FfiConverterSequenceRoomMessageEventMessageType) Lift(rb RustBufferI) []RoomMessageEventMessageType {
	return LiftFromRustBuffer[[]RoomMessageEventMessageType](c, rb)
}

func (c FfiConverterSequenceRoomMessageEventMessageType) Read(reader io.Reader) []RoomMessageEventMessageType {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]RoomMessageEventMessageType, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterRoomMessageEventMessageTypeINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceRoomMessageEventMessageType) Lower(value []RoomMessageEventMessageType) C.RustBuffer {
	return LowerIntoRustBuffer[[]RoomMessageEventMessageType](c, value)
}

func (c FfiConverterSequenceRoomMessageEventMessageType) Write(writer io.Writer, value []RoomMessageEventMessageType) {
	if len(value) > math.MaxInt32 {
		panic("[]RoomMessageEventMessageType is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterRoomMessageEventMessageTypeINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceRoomMessageEventMessageType struct{}

func (FfiDestroyerSequenceRoomMessageEventMessageType) Destroy(sequence []RoomMessageEventMessageType) {
	for _, value := range sequence {
		FfiDestroyerRoomMessageEventMessageType{}.Destroy(value)
	}
}

type FfiConverterSequenceSlidingSyncVersion struct{}

var FfiConverterSequenceSlidingSyncVersionINSTANCE = FfiConverterSequenceSlidingSyncVersion{}

func (c FfiConverterSequenceSlidingSyncVersion) Lift(rb RustBufferI) []SlidingSyncVersion {
	return LiftFromRustBuffer[[]SlidingSyncVersion](c, rb)
}

func (c FfiConverterSequenceSlidingSyncVersion) Read(reader io.Reader) []SlidingSyncVersion {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]SlidingSyncVersion, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterSlidingSyncVersionINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceSlidingSyncVersion) Lower(value []SlidingSyncVersion) C.RustBuffer {
	return LowerIntoRustBuffer[[]SlidingSyncVersion](c, value)
}

func (c FfiConverterSequenceSlidingSyncVersion) Write(writer io.Writer, value []SlidingSyncVersion) {
	if len(value) > math.MaxInt32 {
		panic("[]SlidingSyncVersion is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterSlidingSyncVersionINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceSlidingSyncVersion struct{}

func (FfiDestroyerSequenceSlidingSyncVersion) Destroy(sequence []SlidingSyncVersion) {
	for _, value := range sequence {
		FfiDestroyerSlidingSyncVersion{}.Destroy(value)
	}
}

type FfiConverterSequenceTraceLogPacks struct{}

var FfiConverterSequenceTraceLogPacksINSTANCE = FfiConverterSequenceTraceLogPacks{}

func (c FfiConverterSequenceTraceLogPacks) Lift(rb RustBufferI) []TraceLogPacks {
	return LiftFromRustBuffer[[]TraceLogPacks](c, rb)
}

func (c FfiConverterSequenceTraceLogPacks) Read(reader io.Reader) []TraceLogPacks {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]TraceLogPacks, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterTraceLogPacksINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceTraceLogPacks) Lower(value []TraceLogPacks) C.RustBuffer {
	return LowerIntoRustBuffer[[]TraceLogPacks](c, value)
}

func (c FfiConverterSequenceTraceLogPacks) Write(writer io.Writer, value []TraceLogPacks) {
	if len(value) > math.MaxInt32 {
		panic("[]TraceLogPacks is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterTraceLogPacksINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceTraceLogPacks struct{}

func (FfiDestroyerSequenceTraceLogPacks) Destroy(sequence []TraceLogPacks) {
	for _, value := range sequence {
		FfiDestroyerTraceLogPacks{}.Destroy(value)
	}
}

type FfiConverterSequenceWidgetEventFilter struct{}

var FfiConverterSequenceWidgetEventFilterINSTANCE = FfiConverterSequenceWidgetEventFilter{}

func (c FfiConverterSequenceWidgetEventFilter) Lift(rb RustBufferI) []WidgetEventFilter {
	return LiftFromRustBuffer[[]WidgetEventFilter](c, rb)
}

func (c FfiConverterSequenceWidgetEventFilter) Read(reader io.Reader) []WidgetEventFilter {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]WidgetEventFilter, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterWidgetEventFilterINSTANCE.Read(reader))
	}
	return result
}

func (c FfiConverterSequenceWidgetEventFilter) Lower(value []WidgetEventFilter) C.RustBuffer {
	return LowerIntoRustBuffer[[]WidgetEventFilter](c, value)
}

func (c FfiConverterSequenceWidgetEventFilter) Write(writer io.Writer, value []WidgetEventFilter) {
	if len(value) > math.MaxInt32 {
		panic("[]WidgetEventFilter is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterWidgetEventFilterINSTANCE.Write(writer, item)
	}
}

type FfiDestroyerSequenceWidgetEventFilter struct{}

func (FfiDestroyerSequenceWidgetEventFilter) Destroy(sequence []WidgetEventFilter) {
	for _, value := range sequence {
		FfiDestroyerWidgetEventFilter{}.Destroy(value)
	}
}

type FfiConverterMapStringInt32 struct{}

var FfiConverterMapStringInt32INSTANCE = FfiConverterMapStringInt32{}

func (c FfiConverterMapStringInt32) Lift(rb RustBufferI) map[string]int32 {
	return LiftFromRustBuffer[map[string]int32](c, rb)
}

func (_ FfiConverterMapStringInt32) Read(reader io.Reader) map[string]int32 {
	result := make(map[string]int32)
	length := readInt32(reader)
	for i := int32(0); i < length; i++ {
		key := FfiConverterStringINSTANCE.Read(reader)
		value := FfiConverterInt32INSTANCE.Read(reader)
		result[key] = value
	}
	return result
}

func (c FfiConverterMapStringInt32) Lower(value map[string]int32) C.RustBuffer {
	return LowerIntoRustBuffer[map[string]int32](c, value)
}

func (_ FfiConverterMapStringInt32) Write(writer io.Writer, mapValue map[string]int32) {
	if len(mapValue) > math.MaxInt32 {
		panic("map[string]int32 is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(mapValue)))
	for key, value := range mapValue {
		FfiConverterStringINSTANCE.Write(writer, key)
		FfiConverterInt32INSTANCE.Write(writer, value)
	}
}

type FfiDestroyerMapStringInt32 struct{}

func (_ FfiDestroyerMapStringInt32) Destroy(mapValue map[string]int32) {
	for key, value := range mapValue {
		FfiDestroyerString{}.Destroy(key)
		FfiDestroyerInt32{}.Destroy(value)
	}
}

type FfiConverterMapStringInt64 struct{}

var FfiConverterMapStringInt64INSTANCE = FfiConverterMapStringInt64{}

func (c FfiConverterMapStringInt64) Lift(rb RustBufferI) map[string]int64 {
	return LiftFromRustBuffer[map[string]int64](c, rb)
}

func (_ FfiConverterMapStringInt64) Read(reader io.Reader) map[string]int64 {
	result := make(map[string]int64)
	length := readInt32(reader)
	for i := int32(0); i < length; i++ {
		key := FfiConverterStringINSTANCE.Read(reader)
		value := FfiConverterInt64INSTANCE.Read(reader)
		result[key] = value
	}
	return result
}

func (c FfiConverterMapStringInt64) Lower(value map[string]int64) C.RustBuffer {
	return LowerIntoRustBuffer[map[string]int64](c, value)
}

func (_ FfiConverterMapStringInt64) Write(writer io.Writer, mapValue map[string]int64) {
	if len(mapValue) > math.MaxInt32 {
		panic("map[string]int64 is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(mapValue)))
	for key, value := range mapValue {
		FfiConverterStringINSTANCE.Write(writer, key)
		FfiConverterInt64INSTANCE.Write(writer, value)
	}
}

type FfiDestroyerMapStringInt64 struct{}

func (_ FfiDestroyerMapStringInt64) Destroy(mapValue map[string]int64) {
	for key, value := range mapValue {
		FfiDestroyerString{}.Destroy(key)
		FfiDestroyerInt64{}.Destroy(value)
	}
}

type FfiConverterMapStringString struct{}

var FfiConverterMapStringStringINSTANCE = FfiConverterMapStringString{}

func (c FfiConverterMapStringString) Lift(rb RustBufferI) map[string]string {
	return LiftFromRustBuffer[map[string]string](c, rb)
}

func (_ FfiConverterMapStringString) Read(reader io.Reader) map[string]string {
	result := make(map[string]string)
	length := readInt32(reader)
	for i := int32(0); i < length; i++ {
		key := FfiConverterStringINSTANCE.Read(reader)
		value := FfiConverterStringINSTANCE.Read(reader)
		result[key] = value
	}
	return result
}

func (c FfiConverterMapStringString) Lower(value map[string]string) C.RustBuffer {
	return LowerIntoRustBuffer[map[string]string](c, value)
}

func (_ FfiConverterMapStringString) Write(writer io.Writer, mapValue map[string]string) {
	if len(mapValue) > math.MaxInt32 {
		panic("map[string]string is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(mapValue)))
	for key, value := range mapValue {
		FfiConverterStringINSTANCE.Write(writer, key)
		FfiConverterStringINSTANCE.Write(writer, value)
	}
}

type FfiDestroyerMapStringString struct{}

func (_ FfiDestroyerMapStringString) Destroy(mapValue map[string]string) {
	for key, value := range mapValue {
		FfiDestroyerString{}.Destroy(key)
		FfiDestroyerString{}.Destroy(value)
	}
}

type FfiConverterMapStringIgnoredUser struct{}

var FfiConverterMapStringIgnoredUserINSTANCE = FfiConverterMapStringIgnoredUser{}

func (c FfiConverterMapStringIgnoredUser) Lift(rb RustBufferI) map[string]IgnoredUser {
	return LiftFromRustBuffer[map[string]IgnoredUser](c, rb)
}

func (_ FfiConverterMapStringIgnoredUser) Read(reader io.Reader) map[string]IgnoredUser {
	result := make(map[string]IgnoredUser)
	length := readInt32(reader)
	for i := int32(0); i < length; i++ {
		key := FfiConverterStringINSTANCE.Read(reader)
		value := FfiConverterIgnoredUserINSTANCE.Read(reader)
		result[key] = value
	}
	return result
}

func (c FfiConverterMapStringIgnoredUser) Lower(value map[string]IgnoredUser) C.RustBuffer {
	return LowerIntoRustBuffer[map[string]IgnoredUser](c, value)
}

func (_ FfiConverterMapStringIgnoredUser) Write(writer io.Writer, mapValue map[string]IgnoredUser) {
	if len(mapValue) > math.MaxInt32 {
		panic("map[string]IgnoredUser is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(mapValue)))
	for key, value := range mapValue {
		FfiConverterStringINSTANCE.Write(writer, key)
		FfiConverterIgnoredUserINSTANCE.Write(writer, value)
	}
}

type FfiDestroyerMapStringIgnoredUser struct{}

func (_ FfiDestroyerMapStringIgnoredUser) Destroy(mapValue map[string]IgnoredUser) {
	for key, value := range mapValue {
		FfiDestroyerString{}.Destroy(key)
		FfiDestroyerIgnoredUser{}.Destroy(value)
	}
}

type FfiConverterMapStringNotificationItem struct{}

var FfiConverterMapStringNotificationItemINSTANCE = FfiConverterMapStringNotificationItem{}

func (c FfiConverterMapStringNotificationItem) Lift(rb RustBufferI) map[string]NotificationItem {
	return LiftFromRustBuffer[map[string]NotificationItem](c, rb)
}

func (_ FfiConverterMapStringNotificationItem) Read(reader io.Reader) map[string]NotificationItem {
	result := make(map[string]NotificationItem)
	length := readInt32(reader)
	for i := int32(0); i < length; i++ {
		key := FfiConverterStringINSTANCE.Read(reader)
		value := FfiConverterNotificationItemINSTANCE.Read(reader)
		result[key] = value
	}
	return result
}

func (c FfiConverterMapStringNotificationItem) Lower(value map[string]NotificationItem) C.RustBuffer {
	return LowerIntoRustBuffer[map[string]NotificationItem](c, value)
}

func (_ FfiConverterMapStringNotificationItem) Write(writer io.Writer, mapValue map[string]NotificationItem) {
	if len(mapValue) > math.MaxInt32 {
		panic("map[string]NotificationItem is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(mapValue)))
	for key, value := range mapValue {
		FfiConverterStringINSTANCE.Write(writer, key)
		FfiConverterNotificationItemINSTANCE.Write(writer, value)
	}
}

type FfiDestroyerMapStringNotificationItem struct{}

func (_ FfiDestroyerMapStringNotificationItem) Destroy(mapValue map[string]NotificationItem) {
	for key, value := range mapValue {
		FfiDestroyerString{}.Destroy(key)
		FfiDestroyerNotificationItem{}.Destroy(value)
	}
}

type FfiConverterMapStringReceipt struct{}

var FfiConverterMapStringReceiptINSTANCE = FfiConverterMapStringReceipt{}

func (c FfiConverterMapStringReceipt) Lift(rb RustBufferI) map[string]Receipt {
	return LiftFromRustBuffer[map[string]Receipt](c, rb)
}

func (_ FfiConverterMapStringReceipt) Read(reader io.Reader) map[string]Receipt {
	result := make(map[string]Receipt)
	length := readInt32(reader)
	for i := int32(0); i < length; i++ {
		key := FfiConverterStringINSTANCE.Read(reader)
		value := FfiConverterReceiptINSTANCE.Read(reader)
		result[key] = value
	}
	return result
}

func (c FfiConverterMapStringReceipt) Lower(value map[string]Receipt) C.RustBuffer {
	return LowerIntoRustBuffer[map[string]Receipt](c, value)
}

func (_ FfiConverterMapStringReceipt) Write(writer io.Writer, mapValue map[string]Receipt) {
	if len(mapValue) > math.MaxInt32 {
		panic("map[string]Receipt is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(mapValue)))
	for key, value := range mapValue {
		FfiConverterStringINSTANCE.Write(writer, key)
		FfiConverterReceiptINSTANCE.Write(writer, value)
	}
}

type FfiDestroyerMapStringReceipt struct{}

func (_ FfiDestroyerMapStringReceipt) Destroy(mapValue map[string]Receipt) {
	for key, value := range mapValue {
		FfiDestroyerString{}.Destroy(key)
		FfiDestroyerReceipt{}.Destroy(value)
	}
}

type FfiConverterMapStringSequenceString struct{}

var FfiConverterMapStringSequenceStringINSTANCE = FfiConverterMapStringSequenceString{}

func (c FfiConverterMapStringSequenceString) Lift(rb RustBufferI) map[string][]string {
	return LiftFromRustBuffer[map[string][]string](c, rb)
}

func (_ FfiConverterMapStringSequenceString) Read(reader io.Reader) map[string][]string {
	result := make(map[string][]string)
	length := readInt32(reader)
	for i := int32(0); i < length; i++ {
		key := FfiConverterStringINSTANCE.Read(reader)
		value := FfiConverterSequenceStringINSTANCE.Read(reader)
		result[key] = value
	}
	return result
}

func (c FfiConverterMapStringSequenceString) Lower(value map[string][]string) C.RustBuffer {
	return LowerIntoRustBuffer[map[string][]string](c, value)
}

func (_ FfiConverterMapStringSequenceString) Write(writer io.Writer, mapValue map[string][]string) {
	if len(mapValue) > math.MaxInt32 {
		panic("map[string][]string is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(mapValue)))
	for key, value := range mapValue {
		FfiConverterStringINSTANCE.Write(writer, key)
		FfiConverterSequenceStringINSTANCE.Write(writer, value)
	}
}

type FfiDestroyerMapStringSequenceString struct{}

func (_ FfiDestroyerMapStringSequenceString) Destroy(mapValue map[string][]string) {
	for key, value := range mapValue {
		FfiDestroyerString{}.Destroy(key)
		FfiDestroyerSequenceString{}.Destroy(value)
	}
}

type FfiConverterMapTagNameTagInfo struct{}

var FfiConverterMapTagNameTagInfoINSTANCE = FfiConverterMapTagNameTagInfo{}

func (c FfiConverterMapTagNameTagInfo) Lift(rb RustBufferI) map[TagName]TagInfo {
	return LiftFromRustBuffer[map[TagName]TagInfo](c, rb)
}

func (_ FfiConverterMapTagNameTagInfo) Read(reader io.Reader) map[TagName]TagInfo {
	result := make(map[TagName]TagInfo)
	length := readInt32(reader)
	for i := int32(0); i < length; i++ {
		key := FfiConverterTagNameINSTANCE.Read(reader)
		value := FfiConverterTagInfoINSTANCE.Read(reader)
		result[key] = value
	}
	return result
}

func (c FfiConverterMapTagNameTagInfo) Lower(value map[TagName]TagInfo) C.RustBuffer {
	return LowerIntoRustBuffer[map[TagName]TagInfo](c, value)
}

func (_ FfiConverterMapTagNameTagInfo) Write(writer io.Writer, mapValue map[TagName]TagInfo) {
	if len(mapValue) > math.MaxInt32 {
		panic("map[TagName]TagInfo is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(mapValue)))
	for key, value := range mapValue {
		FfiConverterTagNameINSTANCE.Write(writer, key)
		FfiConverterTagInfoINSTANCE.Write(writer, value)
	}
}

type FfiDestroyerMapTagNameTagInfo struct{}

func (_ FfiDestroyerMapTagNameTagInfo) Destroy(mapValue map[TagName]TagInfo) {
	for key, value := range mapValue {
		FfiDestroyerTagName{}.Destroy(key)
		FfiDestroyerTagInfo{}.Destroy(value)
	}
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
type Timestamp = uint64
type FfiConverterTypeTimestamp = FfiConverterUint64
type FfiDestroyerTypeTimestamp = FfiDestroyerUint64

var FfiConverterTypeTimestampINSTANCE = FfiConverterUint64{}

const (
	uniffiRustFuturePollReady      int8 = 0
	uniffiRustFuturePollMaybeReady int8 = 1
)

type rustFuturePollFunc func(C.uint64_t, C.UniffiRustFutureContinuationCallback, C.uint64_t)
type rustFutureCompleteFunc[T any] func(C.uint64_t, *C.RustCallStatus) T
type rustFutureFreeFunc func(C.uint64_t)

//export matrix_sdk_ffi_uniffiFutureContinuationCallback
func matrix_sdk_ffi_uniffiFutureContinuationCallback(data C.uint64_t, pollResult C.int8_t) {
	h := cgo.Handle(uintptr(data))
	waiter := h.Value().(chan int8)
	waiter <- int8(pollResult)
}

func uniffiRustCallAsync[E any, T any, F any](
	errConverter BufReader[*E],
	completeFunc rustFutureCompleteFunc[F],
	liftFunc func(F) T,
	rustFuture C.uint64_t,
	pollFunc rustFuturePollFunc,
	freeFunc rustFutureFreeFunc,
) (T, *E) {
	defer freeFunc(rustFuture)

	pollResult := int8(-1)
	waiter := make(chan int8, 1)

	chanHandle := cgo.NewHandle(waiter)
	defer chanHandle.Delete()

	for pollResult != uniffiRustFuturePollReady {
		pollFunc(
			rustFuture,
			(C.UniffiRustFutureContinuationCallback)(C.matrix_sdk_ffi_uniffiFutureContinuationCallback),
			C.uint64_t(chanHandle),
		)
		pollResult = <-waiter
	}

	var goValue T
	var ffiValue F
	var err *E

	ffiValue, err = rustCallWithError(errConverter, func(status *C.RustCallStatus) F {
		return completeFunc(rustFuture, status)
	})
	if err != nil {
		return goValue, err
	}
	return liftFunc(ffiValue), nil
}

//export matrix_sdk_ffi_uniffiFreeGorutine
func matrix_sdk_ffi_uniffiFreeGorutine(data C.uint64_t) {
	handle := cgo.Handle(uintptr(data))
	defer handle.Delete()

	guard := handle.Value().(chan struct{})
	guard <- struct{}{}
}

// Creates a [`RoomMessageEventContentWithoutRelation`] given a
// [`MessageContent`] value.
func ContentWithoutRelationFromMessage(message MessageContent) (*RoomMessageEventContentWithoutRelation, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[ClientError](FfiConverterClientError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_func_content_without_relation_from_message(FfiConverterMessageContentINSTANCE.Lower(message), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *RoomMessageEventContentWithoutRelation
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterRoomMessageEventContentWithoutRelationINSTANCE.Lift(_uniffiRV), nil
	}
}

// Create a caption edit.
//
// If no `formatted_caption` is provided, then it's assumed the `caption`
// represents valid Markdown that can be used as the formatted caption.
func CreateCaptionEdit(caption *string, formattedCaption *FormattedBody, mentions *Mentions) EditedContent {
	return FfiConverterEditedContentINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_func_create_caption_edit(FfiConverterOptionalStringINSTANCE.Lower(caption), FfiConverterOptionalFormattedBodyINSTANCE.Lower(formattedCaption), FfiConverterOptionalMentionsINSTANCE.Lower(mentions), _uniffiStatus),
		}
	}))
}

func GenTransactionId() string {
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_func_gen_transaction_id(_uniffiStatus),
		}
	}))
}

// Create the actual url that can be used to setup the WebView or IFrame
// that contains the widget.
//
// # Arguments
// * `widget_settings` - The widget settings to generate the url for.
// * `room` - A Matrix room which is used to query the logged in username
// * `props` - Properties from the client that can be used by a widget to adapt
// to the client. e.g. language, font-scale...
func GenerateWebviewUrl(widgetSettings WidgetSettings, room *Room, props ClientProperties) (string, error) {
	res, err := uniffiRustCallAsync[ParseError](
		FfiConverterParseErrorINSTANCE,
		// completeFn
		func(handle C.uint64_t, status *C.RustCallStatus) RustBufferI {
			res := C.ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer(handle, status)
			return GoRustBuffer{
				inner: res,
			}
		},
		// liftFn
		func(ffi RustBufferI) string {
			return FfiConverterStringINSTANCE.Lift(ffi)
		},
		C.uniffi_matrix_sdk_ffi_fn_func_generate_webview_url(FfiConverterWidgetSettingsINSTANCE.Lower(widgetSettings), FfiConverterRoomINSTANCE.Lower(room), FfiConverterClientPropertiesINSTANCE.Lower(props)),
		// pollFn
		func(handle C.uint64_t, continuation C.UniffiRustFutureContinuationCallback, data C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer(handle, continuation, data)
		},
		// freeFn
		func(handle C.uint64_t) {
			C.ffi_matrix_sdk_ffi_rust_future_free_rust_buffer(handle)
		},
	)

	return res, err
}

// The Capabilities required to run a element call widget.
//
// This is intended to be used in combination with: `acquire_capabilities` of
// the `CapabilitiesProvider`.
//
// `acquire_capabilities` can simply return the `WidgetCapabilities` from this
// function. Even if there are non intersecting permissions to what the widget
// requested.
//
// Editing and extending the capabilities from this function is also possible,
// but should only be done as temporal workarounds until this function is
// adjusted
func GetElementCallRequiredPermissions(ownUserId string, ownDeviceId string) WidgetCapabilities {
	return FfiConverterWidgetCapabilitiesINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_func_get_element_call_required_permissions(FfiConverterStringINSTANCE.Lower(ownUserId), FfiConverterStringINSTANCE.Lower(ownDeviceId), _uniffiStatus),
		}
	}))
}

// Sets up logs and the tokio runtime for the current application.
//
// If `use_lightweight_tokio_runtime` is set to true, this will set up a
// lightweight tokio runtime, for processes that have memory limitations (like
// the NSE process on iOS). Otherwise, this can remain false, in which case a
// multithreaded tokio runtime will be set up.
func InitPlatform(config TracingConfiguration, useLightweightTokioRuntime bool) {
	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_matrix_sdk_ffi_fn_func_init_platform(FfiConverterTracingConfigurationINSTANCE.Lower(config), FfiConverterBoolINSTANCE.Lower(useLightweightTokioRuntime), _uniffiStatus)
		return false
	})
}

// Verifies the passed `String` matches the expected room alias format:
//
// This means it's lowercase, with no whitespace chars, has a single leading
// `#` char and a single `:` separator between the local and domain parts, and
// the local part only contains characters that can't be percent encoded.
func IsRoomAliasFormatValid(alias string) bool {
	return FfiConverterBoolINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.uniffi_matrix_sdk_ffi_fn_func_is_room_alias_format_valid(FfiConverterStringINSTANCE.Lower(alias), _uniffiStatus)
	}))
}

// Log an event.
//
// The target should be something like a module path, and can be referenced in
// the filter string given to `setup_tracing`. `level` and `target` for a
// callsite are fixed at the first `log_event` call for that callsite and can
// not be changed afterwards, i.e. the level and target passed for second and
// following `log_event`s with the same callsite will be ignored.
//
// This function leaks a little bit of memory for each unique (file + line +
// level + target) it is called with. Please make sure that the number of
// different combinations of those parameters this can be called with is
// constant in the final executable.
func LogEvent(file string, line *uint32, level LogLevel, target string, message string) {
	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.uniffi_matrix_sdk_ffi_fn_func_log_event(FfiConverterStringINSTANCE.Lower(file), FfiConverterOptionalUint32INSTANCE.Lower(line), FfiConverterLogLevelINSTANCE.Lower(level), FfiConverterStringINSTANCE.Lower(target), FfiConverterStringINSTANCE.Lower(message), _uniffiStatus)
		return false
	})
}

// Helper function to parse a string into a ElementWellKnown struct
func MakeElementWellKnown(string string) (ElementWellKnown, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[ClientError](FfiConverterClientError{}, func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_func_make_element_well_known(FfiConverterStringINSTANCE.Lower(string), _uniffiStatus),
		}
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue ElementWellKnown
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterElementWellKnownINSTANCE.Lift(_uniffiRV), nil
	}
}

func MakeWidgetDriver(settings WidgetSettings) (WidgetDriverAndHandle, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[ParseError](FfiConverterParseError{}, func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_func_make_widget_driver(FfiConverterWidgetSettingsINSTANCE.Lower(settings), _uniffiStatus),
		}
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue WidgetDriverAndHandle
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterWidgetDriverAndHandleINSTANCE.Lift(_uniffiRV), nil
	}
}

// Generates a `matrix.to` permalink to the given room alias.
func MatrixToRoomAliasPermalink(roomAlias string) (string, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[ClientError](FfiConverterClientError{}, func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_func_matrix_to_room_alias_permalink(FfiConverterStringINSTANCE.Lower(roomAlias), _uniffiStatus),
		}
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue string
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterStringINSTANCE.Lift(_uniffiRV), nil
	}
}

// Generates a `matrix.to` permalink to the given userID.
func MatrixToUserPermalink(userId string) (string, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[ClientError](FfiConverterClientError{}, func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_func_matrix_to_user_permalink(FfiConverterStringINSTANCE.Lower(userId), _uniffiStatus),
		}
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue string
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterStringINSTANCE.Lift(_uniffiRV), nil
	}
}

func MessageEventContentFromHtml(body string, htmlBody string) *RoomMessageEventContentWithoutRelation {
	return FfiConverterRoomMessageEventContentWithoutRelationINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_html(FfiConverterStringINSTANCE.Lower(body), FfiConverterStringINSTANCE.Lower(htmlBody), _uniffiStatus)
	}))
}

func MessageEventContentFromHtmlAsEmote(body string, htmlBody string) *RoomMessageEventContentWithoutRelation {
	return FfiConverterRoomMessageEventContentWithoutRelationINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_html_as_emote(FfiConverterStringINSTANCE.Lower(body), FfiConverterStringINSTANCE.Lower(htmlBody), _uniffiStatus)
	}))
}

func MessageEventContentFromMarkdown(md string) *RoomMessageEventContentWithoutRelation {
	return FfiConverterRoomMessageEventContentWithoutRelationINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown(FfiConverterStringINSTANCE.Lower(md), _uniffiStatus)
	}))
}

func MessageEventContentFromMarkdownAsEmote(md string) *RoomMessageEventContentWithoutRelation {
	return FfiConverterRoomMessageEventContentWithoutRelationINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown_as_emote(FfiConverterStringINSTANCE.Lower(md), _uniffiStatus)
	}))
}

func MessageEventContentNew(msgtype MessageType) (*RoomMessageEventContentWithoutRelation, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[ClientError](FfiConverterClientError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.uniffi_matrix_sdk_ffi_fn_func_message_event_content_new(FfiConverterMessageTypeINSTANCE.Lower(msgtype), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *RoomMessageEventContentWithoutRelation
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterRoomMessageEventContentWithoutRelationINSTANCE.Lift(_uniffiRV), nil
	}
}

// `WidgetSettings` are usually created from a state event.
// (currently unimplemented)
//
// In some cases the client wants to create custom `WidgetSettings`
// for specific rooms based on other conditions.
// This function returns a `WidgetSettings` object which can be used
// to setup a widget using `run_client_widget_api`
// and to generate the correct url for the widget.
//
// # Arguments
//
// * `props` - A struct containing the configuration parameters for a element
// call widget.
func NewVirtualElementCallWidget(props VirtualElementCallWidgetOptions) (WidgetSettings, error) {
	_uniffiRV, _uniffiErr := rustCallWithError[ParseError](FfiConverterParseError{}, func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_func_new_virtual_element_call_widget(FfiConverterVirtualElementCallWidgetOptionsINSTANCE.Lower(props), _uniffiStatus),
		}
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue WidgetSettings
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterWidgetSettingsINSTANCE.Lift(_uniffiRV), nil
	}
}

// Parse a matrix entity from a given URI, be it either
// a `matrix.to` link or a `matrix:` URI
func ParseMatrixEntityFrom(uri string) *MatrixEntity {
	return FfiConverterOptionalMatrixEntityINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_func_parse_matrix_entity_from(FfiConverterStringINSTANCE.Lower(uri), _uniffiStatus),
		}
	}))
}

// Transforms a Room's display name into a valid room alias name.
func RoomAliasNameFromRoomDisplayName(roomName string) string {
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_func_room_alias_name_from_room_display_name(FfiConverterStringINSTANCE.Lower(roomName), _uniffiStatus),
		}
	}))
}

func SdkGitSha() string {
	return FfiConverterStringINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_func_sdk_git_sha(_uniffiStatus),
		}
	}))
}

func SuggestedPowerLevelForRole(role matrix_sdk.RoomMemberRole) int64 {
	return FfiConverterInt64INSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int64_t {
		return C.uniffi_matrix_sdk_ffi_fn_func_suggested_power_level_for_role(RustBufferFromExternal(matrix_sdk.FfiConverterRoomMemberRoleINSTANCE.Lower(role)), _uniffiStatus)
	}))
}

func SuggestedRoleForPowerLevel(powerLevel int64) matrix_sdk.RoomMemberRole {
	return matrix_sdk.FfiConverterRoomMemberRoleINSTANCE.Lift(rustCall(func(_uniffiStatus *C.RustCallStatus) RustBufferI {
		return GoRustBuffer{
			inner: C.uniffi_matrix_sdk_ffi_fn_func_suggested_role_for_power_level(FfiConverterInt64INSTANCE.Lower(powerLevel), _uniffiStatus),
		}
	}))
}
